<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Python Crash Course-note10]]></title>
      <url>/2018/04/19/Python%20Crash%20Course-note10/</url>
      <content type="html"><![CDATA[<p>-测试</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">测试代码</font></strong><br>python标准库中的模块unittest提供了代码测试工具。<br>单元测试用于核实函数的某个方面没有问题。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//name.py</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(first,last)</span>:</span></div><div class="line">		full_name=first+<span class="string">" "</span>+last</div><div class="line">		<span class="keyword">return</span> full_name.title()</div><div class="line"></div><div class="line">//Test.py</div><div class="line"><span class="keyword">import</span> unittest</div><div class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> name</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCase</span><span class="params">(unittest.TestCase)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_firt_last_name</span><span class="params">(self)</span>:</span></div><div class="line">        formatted_name=name(<span class="string">'janis'</span>,<span class="string">'joplin'</span>)</div><div class="line">        self.assertEqual(formatted_name,<span class="string">'Janis Joplin'</span>)//判断结果是否相同</div><div class="line"></div><div class="line">unittest.main()</div><div class="line"></div><div class="line">//OUTPUT</div><div class="line">.</div><div class="line">----------------------------------------------------------------------</div><div class="line">Ran <span class="number">1</span> test <span class="keyword">in</span> <span class="number">0.000</span>s</div><div class="line"></div><div class="line">OK</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：测试代码的方法名必须以test_打头；这样才能运行test.py时自动运行。<br>可以添加多个测试</p>
<p><strong>测试类</strong><br>断言方法检查该满足的条件是否满足。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>assertEqual(a,b)</td>
<td style="text-align:center">核实a==b</td>
</tr>
<tr>
<td>assertNotEqual(a,b)</td>
<td style="text-align:center">核实a!=b</td>
</tr>
<tr>
<td>assertTrue(x)</td>
<td style="text-align:center">核实x为True</td>
</tr>
<tr>
<td>assertFalse(x)</td>
<td style="text-align:center">核实x为False</td>
</tr>
<tr>
<td>assertIn(item,list)</td>
<td style="text-align:center">核实item在list中</td>
</tr>
<tr>
<td>assertNotIn(item,list)</td>
<td style="text-align:center">核实item不在list中</td>
</tr>
</tbody>
</table>
<p>测试类其实与测试函数无异，主要测试的也是类中的方法。</p>
<p><strong>方法setUp()</strong><br>python将现运行setUp()，在运行各个以test_打头的方法。</p>
<p>因此，创建系统实例可以在setUp()中进行。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note9]]></title>
      <url>/2018/04/18/Python%20Crash%20Course-note9/</url>
      <content type="html"><![CDATA[<p>-文件写入与读取<br>-异常提示<br>-逻辑重构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">文件和异常</font></strong><br><strong>读取文件</strong><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//digits.txt</div><div class="line"><span class="number">3.14159265358979</span></div><div class="line">//reader.py</div><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'digits.txt'</span>) <span class="keyword">as</span> file_object:</div><div class="line">	contents=file_object.<span class="built_in">read</span>()</div><div class="line">	print(contents)</div><div class="line">//OUTPUT</div><div class="line"><span class="number">3.14159265358979</span></div><div class="line">/<span class="literal">space</span></div></pre></td></tr></table></figure></p>
<p>后面有一个空格，是因为当read(）到达文件末尾时返回一个空字符串，而输出时就会成为一个空行。如果要删除末尾空行，可以使用rstip()来删除空格<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="name">contents</span>.rstrip())</div></pre></td></tr></table></figure></p>
<p>open(）函数接受一个参数（要打开的文件的名称）。<br>关键字with在不再需要访问文件后将其关闭。也就是自动控制文件的关闭。事实上，也可以用close()函数来主动控制文件的关闭，但是如果出bug，会导致close()无法执行，可能会导致文件受损。</p>
<p><strong>文件路径</strong><br>当直接传递函数open()的参数是不带路径的时候，python只能在当前执行的文件(.py程序文件）所在的目录中查找文件。</p>
<p>但如果不在同一目录下时，需要给出一个完整的绝对路径来定义打开的文件位置。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'text_files\filename.txt'</span>) <span class="keyword">as</span> file_object:</div><div class="line">//EXAMPLE</div><div class="line">file_path=<span class="string">'C:\Users\ehmatthes\other_files\text_files\filename.txt'</span></div><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'file_path'</span>) <span class="keyword">as</span> file_object:</div></pre></td></tr></table></figure>
<p><strong>逐行读取</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//example</div><div class="line">filename=<span class="string">'digits.txt'</span></div><div class="line"></div><div class="line">with <span class="keyword">open</span>(filename) <span class="keyword">as</span> file_objec<span class="variable">t:</span></div><div class="line">	<span class="keyword">for</span> <span class="built_in">line</span> in file_obec<span class="variable">t:</span></div><div class="line">		<span class="keyword">print</span>(<span class="built_in">line</span>)</div></pre></td></tr></table></figure></p>
<p>每行的末尾隐含了一个换行符,在print时就会把换行符打印出来，因而会产生多余的空行。删除空行和之前一样使用rstrip()函数。</p>
<p><strong>创建一个包含文件各行内容的列表</strong><br>使用readline()函数来读入每一行。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">filename=<span class="string">'digits.txt'</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename) <span class="keyword">as</span> file_object:</div><div class="line">	<span class="keyword">lines</span>=file_obect.readlines()</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="built_in">line</span> <span class="keyword">in</span> <span class="keyword">lines</span>:</div><div class="line">	print(<span class="built_in">line</span>.rstrip())</div></pre></td></tr></table></figure></p>
<p>创建了一个包含各行内容的列表lines，再逐行打印列表元素内容。</p>
<hr>
<p><strong>写入文件</strong><br>要将文本写入文件，在调用open()函数的需要多给一个参数’w’。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">filename=<span class="string">'programming.txt'</span></div><div class="line"></div><div class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">'w'</span>) <span class="keyword">as</span> file_object:</div><div class="line">	file_object.<span class="built_in">write</span>(<span class="string">" I love programming."</span>)</div></pre></td></tr></table></figure></p>
<p>给’w’参数告诉python以<strong>写入模式</strong>来打开这个文件。<br>有4种模式：<br>1.’r’—读取模式<br>2.’w’—写入模式<br>3.’a’—附加模式</p>
<ol>
<li>‘r+’读取和写入模式</li>
</ol>
<p>如果未给模式实参，将自动以默认的只读模式打开文件。</p>
<p>使用文件对象的方法write()来写入文件。</p>
<p><strong>写入到原有文件</strong><br>如果不希望覆盖原有文件的内容，而是在原有文件的基础上写入文本。<br>只需要将模式实参设为’a’即可。</p>
<hr>
<p><strong>异常</strong><br><strong>使用try-except代码块</strong><br>当认为可能发生了错误时，可编写try-except代码块来处理可能引发的异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">	print(<span class="number">5</span>/<span class="number">0</span>)</div><div class="line"><span class="keyword">except</span> ZeroDivisionError:</div><div class="line">	print(<span class="string">"You can't divide by zero!"</span>)</div></pre></td></tr></table></figure>
<p>将导致错误的代码行放在一个try代码块中。如果代码块中的代码运行无问题，跳过except代码块。<br>如果try代码块中引发了与except代码块中指定类型的错误，就会执行其中的代码。</p>
<p><strong>else代码块</strong><br>在try-except代码块的基础上增加else代码块，放入依赖于try代码块执行成功的代码块。</p>
<hr>
<p><strong>分析文本</strong><br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;titile=<span class="string">"Alice in wonderland"</span></div><div class="line">&gt;&gt;&gt;title.split<span class="comment">()</span></div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">[<span class="string">'Alice'</span>,<span class="string">'in'</span>,<span class="string">'Wonderland'</span>]</div></pre></td></tr></table></figure></p>
<p>方法spilt()以空格为分隔符把字符串拆分成多个部分，并将其存入列表中。</p>
<hr>
<p><strong>存储数据</strong><br>如果要使用户在关闭程序时，保存用户提供的信息，可以使用模块json来存储数据。</p>
<p><strong>json的方法</strong><br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> json</div><div class="line">numbers=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>]</div><div class="line"></div><div class="line">filename=<span class="string">'numbers.json'</span></div><div class="line"><span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</div><div class="line">	json.dump(numbers,f_obj)</div></pre></td></tr></table></figure></p>
<p>导入模块json，以写入模式打开创建的.json文件，在使用dump()写入数字列表到f_obj文件中。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import json</div><div class="line"><span class="attribute">filename</span>=<span class="string">'numbers.json'</span></div><div class="line">with open(filename) as f_obj:</div><div class="line">	<span class="attribute">numbers</span>=json.load(f_obj)</div><div class="line"><span class="builtin-name">print</span>(numbers)</div></pre></td></tr></table></figure>
<p>与上面对应的就是，读取已经存储在.json中的数据。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//简单的用户信息存储提示</span></div><div class="line"><span class="keyword">import</span> json</div><div class="line">filename=<span class="string">'username.json'</span></div><div class="line"><span class="keyword">try</span>:</div><div class="line">	<span class="keyword">with</span> open(filename) <span class="keyword">as</span> f_obj:</div><div class="line">		username=json.load(f_obj)</div><div class="line">except FileNotFoundError:</div><div class="line">	username=input(<span class="string">"What is your name?"</span>)</div><div class="line">	<span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f_obj:</div><div class="line">		json.dump(username,f_obj)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	<span class="built_in">print</span>(welcome back!)</div></pre></td></tr></table></figure>
<p><strong>重构</strong><br>重构就是将代码划分为一系列完成具体工作的函数。<br>与C++无异。注意重构逻辑即可。</p>
<p>–</p>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note8]]></title>
      <url>/2018/04/17/Python%20Crash%20Course-note8/</url>
      <content type="html"><![CDATA[<p>-类的使用</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong><font size="5">类</font></strong><br><strong>创建类</strong><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(<span class="keyword">self</span>,name,age)</span></span><span class="symbol">:</span></div><div class="line">		<span class="keyword">self</span>.name=name</div><div class="line">		<span class="keyword">self</span>.age=age</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sit</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">		print(<span class="keyword">self</span>.name.title()+<span class="string">" is now sitting."</span>)</div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">		print(<span class="keyword">self</span>.name.title()+<span class="string">"rolled over"</span>)</div></pre></td></tr></table></figure></p>
<p><strong>根据类创建实例</strong><br>书中方法有误，没有给参数，无法创建实例,改动如下。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>():</span></div><div class="line">	def init(<span class="built_in">self</span>,name,age):</div><div class="line">		<span class="built_in">self</span>.name=name</div><div class="line">		<span class="built_in">self</span>.age=age</div><div class="line">	def sit(<span class="built_in">self</span>):</div><div class="line">		<span class="built_in">print</span>(<span class="built_in">self</span>.name.title()+<span class="string">" is now sitting."</span>)</div><div class="line">	def roll(<span class="built_in">self</span>):</div><div class="line">		<span class="built_in">print</span>(<span class="built_in">self</span>.name.title()+<span class="string">"rolled over"</span>)</div><div class="line"></div><div class="line">my_dog=Dog()</div><div class="line">my_dog.init(<span class="comment">'QJ',6)</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"my_dog's name is "</span>+my_dog.name.title()+<span class="string">"."</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"my dog is "</span>+str(my_dog.age)+<span class="string">" years old"</span>)</div><div class="line">//OUTPUT</div><div class="line">my_dog<span class="comment">'s name is Qj.</span></div><div class="line">my dog is <span class="number">6</span> years old</div></pre></td></tr></table></figure></p>
<p><strong>访问属性与调用方法</strong><br>只需在实例后加个成员运算符（.)即可调用实例的方法与成员变量，从而实现访问属性与调用方法。这一点与C++无异。</p>
<hr>
<p><strong>继承</strong><br>一个类继承另一个类，可以获得被继承类的所有属性和方法。<br>被继承类称为父类，继承类称为子类。</p>
<p>当子类继承父类时，在创建子类时，在括号中要加上父类的名称。<br>super()是一个来调用父类的方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//普通方法</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Base init"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        Base.__init__(self) <span class="comment">#普通方法</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"Leaf init"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line"></div><div class="line">     leaf = Leaf()</div></pre></td></tr></table></figure></p>
<p>使用非绑定的类方法（用类名来引用的方法），并在参数列表中，引入待绑定的对象（self），从而达到调用父类的目的。</p>
<p>这样做的缺点是，当一个子类的父类发生变化时（如类Leaf的父类由Base变为C时），必须遍历整个类定义，把所有的通过非绑定的方法的类名全部替换过来。</p>
<p>如果代码量庞大，这样的修改可能是灾难性的。</p>
<p>super()函数就是为解决该问题而设计的。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>(<span class="title">object</span>):</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        print <span class="string">"Base init"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span>(<span class="title">Base</span>):</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></div><div class="line">        <span class="keyword">super</span>(Leaf, <span class="keyword">self</span>).__init_<span class="number">_</span>() <span class="comment">#super方法！！！</span></div><div class="line">        print <span class="string">"Leaf init"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name_<span class="number">_</span> == <span class="string">'__main__'</span><span class="symbol">:</span></div><div class="line"></div><div class="line">     leaf = Leaf()</div></pre></td></tr></table></figure></p>
<p><strong>重写父类方法</strong><br>如果在子类中希望重写父类的方法，只需要像新定义一个函数一般进行覆盖即可。</p>
<p><strong>导入类</strong><br>原本中有car.py，可以进行覆盖。<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> car <span class="keyword">import</span> car</div></pre></td></tr></table></figure></p>
<p>在car.py中，导入car类</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note7]]></title>
      <url>/2018/04/16/Python%20Crash%20Course-note7/</url>
      <content type="html"><![CDATA[<p>-函数</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">函数</font></strong><br><strong>定义函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_user</span><span class="params">()</span>:</span></div><div class="line">	print(<span class="string">"Hello!"</span>)</div><div class="line"></div><div class="line">greet_user()</div></pre></td></tr></table></figure></p>
<p>使用关键字def来定义函数，其后调用函数，将完成打印。</p>
<p><strong>函数参数</strong><br>在函数定义括号内添加参数。使用与C++无异。</p>
<p><strong>形参与实参</strong><br>调用函数时传用的为实参，函数定义中为形参。</p>
<p>如果有多个参数的情况下，需要对应实参的位置来传递。</p>
<p><strong>参数的默认值</strong><br>在编写函数的时候，可以给每个形参指定默认值。<br>默认值的指定与C++无异。</p>
<p><strong>返回值</strong><br>函数返回的值称为返回值。使用return语句返回到调用函数的代码行。<br>返回值的使用与C++无异。</p>
<p><strong>可选实参</strong><br>如果多个实参情况下可能某个实参不提供，那么可以将其设置为可选的。方法是将需要设置为可选的参数赋默认值-空字符串，并将其移到形参列表的末尾。</p>
<p><strong>传递任意数量的实参</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">def</span> <span class="selector-tag">pizza</span>(*toppings):</div><div class="line">	<span class="selector-tag">print</span>(toppings)</div><div class="line"><span class="selector-tag">pizza</span>(<span class="string">'a'</span>)</div><div class="line"><span class="selector-tag">pizza</span>(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)</div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">(<span class="string">'a'</span>,)</div><div class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</div></pre></td></tr></table></figure></p>
<p>使用*topppings可以接受任意数量的参数。</p>
<p><strong>结合使用位置实参和任意数量实参</strong><br>如果需要结合使用，将接纳任意数量实参的形参放在函数定义中最后。</p>
<p><strong>使用任意数量的关键字实参</strong><br>如果是希望函数能够接受任意数量的键值对，使用**user，相当于二维数组，来传递键值对。</p>
<p><strong>将函数存储在模块中</strong><br>对应C++就是类似头文件。<br>先在一个py中写下函数定义。<br>再在需要使用这些函数的py中使用import关键字将函数定义的py导入使用。</p>
<p><strong>导入特定的函数</strong><br>不导入整个模块，导入特定函数，使用的语法<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> module_name <span class="keyword">import</span> function_name</div><div class="line">```	</div><div class="line">可以一次导入多个，使用逗号分隔</div></pre></td></tr></table></figure></p>
<p>from module_name import function1,function2,function3<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**使用<span class="keyword">as</span>起别名**</div></pre></td></tr></table></figure></p>
<p>from pizza import make_pizza as mp<br>//定义别名mp<br>```<br>这个C++中的typedef有类似的功能。</p>
<p>也可以使用as来给模块定别名</p>
<p><strong>导入模块中所有函数</strong><br>使用星号运算符（*）可以导入所有函数。<br>与C++,JAVA都类似。</p>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note6]]></title>
      <url>/2018/04/15/Python%20Crash%20Course-note6/</url>
      <content type="html"><![CDATA[<p>-输入input<br>-whlie循环</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong><font size="5">用户输入和while循环</font></strong><br><strong>函数input()的工作原理</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">message=input(<span class="string">"input and repeat: "</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(message)</span></span></div><div class="line"><span class="comment">//input</span></div><div class="line">james</div><div class="line"><span class="comment">//output</span></div><div class="line">james</div></pre></td></tr></table></figure></p>
<p>函数input()接受一个参数，即键入值；input()函数会先输出信息，然后等待输入，并在回车键键入后继续运行。</p>
<p><strong>使用int()来获取数值输入</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">messgae=input(<span class="string">"How old are u:"</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(message)</span></span></div><div class="line">message=int(message)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(message)</span></span></div><div class="line"><span class="comment">//input</span></div><div class="line"><span class="number">19</span></div><div class="line"><span class="comment">//output</span></div><div class="line"><span class="number">19</span></div><div class="line"><span class="number">19</span></div></pre></td></tr></table></figure></p>
<p>这个例子可能不是很体现的出来，但是使用input()时，python会将输入解读为字符串。<br>使用int()是希望能够进行强制类型转换，将字符换类型转换成int类型。</p>
<p><strong>求模运算符</strong><br>%运算符：使用与C++无异。</p>
<hr>
<p><strong>while循环</strong><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">number</span>=<span class="number">1</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">number</span>&lt;=<span class="number">5</span>:</div><div class="line">	<span class="built_in">print</span>(<span class="keyword">number</span>)</div><div class="line">	<span class="keyword">number</span>+=<span class="number">1</span></div><div class="line">//OUTPUT</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p>
<p><strong>使用break退出循环</strong><br>与if联用，与C++无异；</p>
<p><strong>使用continue</strong><br>与if联用，与C++无异。</p>
<p><strong>使用while循环来处理列表与字典</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">unconfirmed=[<span class="string">'alice'</span>,<span class="string">'brian'</span>,<span class="string">'candace'</span>]</div><div class="line">confirmed=[]</div><div class="line"></div><div class="line"><span class="keyword">while</span> unconfirmed:</div><div class="line">	user=unconfirm.<span class="keyword">pop</span>()</div><div class="line">	confirmed.<span class="keyword">append</span>(user)</div><div class="line"><span class="keyword">print</span>(confirmed)</div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">[<span class="string">'candace'</span>, <span class="string">'brian'</span>, <span class="string">'alice'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>删除列表元素</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//删除列表中特殊值的元素</span></div><div class="line">pets=[<span class="string">'dog'</span>,<span class="string">'cat'</span>,<span class="string">'fish'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(pets)</span></span></div><div class="line"></div><div class="line">while <span class="string">'cat'</span> <span class="keyword">in</span> pets:</div><div class="line">	pets.remove(<span class="string">'cat'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(pets)</span></span></div><div class="line"><span class="comment">//output</span></div><div class="line">[<span class="string">'dog'</span>, <span class="string">'cat'</span>, <span class="string">'fish'</span>]</div><div class="line">[<span class="string">'dog'</span>, <span class="string">'fish'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>使用输入来填充字典</strong><br>设置一个标志Flag，来标志是否继续进行字典的填充，若否，则令Flag=false</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note5]]></title>
      <url>/2018/04/15/Python%20Crash%20Course-note5/</url>
      <content type="html"><![CDATA[<p>-字典</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong><font size="5">字典</font></strong><br><strong>使用字典</strong><br>在python中，<strong>字典</strong>是一系列<strong>键-值对</strong>。每一个键都与一个值相关联，可以使用键来访问与之相关联的值。字典中的值可以是任何python对象。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//字典用放在花括号&#123;&#125;中的一些列键值对表示</div><div class="line">alien=&#123;<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>&#125;</div></pre></td></tr></table></figure></p>
<p>键和值之间用冒号分隔，而键-值对之间用逗号分隔。</p>
<p><strong>访问字典中的值</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alien=&#123;<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>&#125;</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(alien[<span class="string">'color'</span>])</span></span></div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">green</div></pre></td></tr></table></figure></p>
<p><strong>添加键-值对</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alien=&#123;<span class="string">'color'</span>:<span class="string">'green'</span>,<span class="string">'points'</span>:<span class="number">5</span>&#125;</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(alien)</span></span></div><div class="line"></div><div class="line">alien[<span class="string">'x'</span>]=<span class="number">25</span></div><div class="line">alien[<span class="string">'y'</span>]=<span class="number">20</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(alien)</span></span></div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>&#125;</div><div class="line">&#123;<span class="string">'color'</span>: <span class="string">'green'</span>, <span class="string">'points'</span>: <span class="number">5</span>, <span class="string">'x'</span>: <span class="number">25</span>, <span class="string">'y'</span>: <span class="number">20</span>&#125;</div></pre></td></tr></table></figure></p>
<p>python中不关心键值对的添加顺序，而只关心键和值之间的对应关系；</p>
<p><strong>创建空字典</strong><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">alien</span>=&#123;&#125;</div><div class="line">alien[<span class="string">'a'</span>]=<span class="string">'b'</span></div></pre></td></tr></table></figure></p>
<p>先创建，再逐个添加</p>
<p><strong>修改字典中的值</strong><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alien=&#123;&#125;</div><div class="line">alien[<span class="string">'a'</span>]=<span class="string">'b'</span></div><div class="line">alien[<span class="string">'a'</span>]=<span class="string">'c'</span></div></pre></td></tr></table></figure></p>
<p>直接进行重新赋值覆盖即可</p>
<p><strong>删除键-值对</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">alien=&#123;&#125;</div><div class="line">alien[<span class="string">'a'</span>]=<span class="string">'b'</span></div><div class="line">alien[<span class="string">'b'</span>]=<span class="string">'c'</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(alien)</span></span></div><div class="line"><span class="function"><span class="title">del</span><span class="params">(alien[<span class="string">'a'</span>])</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(alien)</span></span></div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line">&#123;<span class="string">'a'</span>: <span class="string">'b'</span>, <span class="string">'b'</span>: <span class="string">'c'</span>&#125;</div><div class="line">&#123;<span class="string">'b'</span>: <span class="string">'c'</span>&#125;</div></pre></td></tr></table></figure></p>
<p>使用del语句删除即可。</p>
<p><strong>遍历字典</strong><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">user=&#123;</div><div class="line">    <span class="string">'username'</span>:<span class="string">'james'</span>,</div><div class="line">    <span class="string">'fist'</span>:<span class="string">'lebron'</span>,</div><div class="line">    <span class="string">'last'</span>:<span class="string">'jerome'</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> user.items():</div><div class="line">    print(<span class="string">"\nKey:"</span>+key)</div><div class="line">    print(<span class="string">"Value:"</span>+value)</div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line"></div><div class="line"><span class="string">Key:</span>username</div><div class="line"><span class="string">Value:</span>james</div><div class="line"></div><div class="line"><span class="string">Key:</span>fist</div><div class="line"><span class="string">Value:</span>lebron</div><div class="line"></div><div class="line"><span class="string">Key:</span>last</div><div class="line"><span class="string">Value:</span>jerome</div></pre></td></tr></table></figure></p>
<p><strong>items():</strong><br>返回可遍历的(键, 值) 元组数组。</p>
<p><strong>遍历字典中的所有键</strong><br>在不需要使用字典中的值时，使用方法keys()遍历字典中的键。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user=&#123;</div><div class="line">    <span class="string">'username'</span>:<span class="string">'james'</span>,</div><div class="line">    <span class="string">'fist'</span>:<span class="string">'lebron'</span>,</div><div class="line">    <span class="string">'last'</span>:<span class="string">'jerome'</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> <span class="built_in">name</span> <span class="built_in">in</span> user.keys():</div><div class="line">    print(<span class="string">"\n"</span>+<span class="built_in">name</span>)</div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line"></div><div class="line">username</div><div class="line"></div><div class="line">fist</div><div class="line"></div><div class="line">last</div></pre></td></tr></table></figure></p>
<p><strong>顺序遍历字典中的键</strong><br>字典记录键和值之间的关联关系，但获取字典的元素时，获取顺序是不可预测的。如果要顺序遍历，则可以使用函数sorted(）来获取按特定顺序排列的键排列的副本。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">user=&#123;</div><div class="line">    <span class="string">'username'</span>:<span class="string">'james'</span>,</div><div class="line">    <span class="string">'fist'</span>:<span class="string">'lebron'</span>,</div><div class="line">    <span class="string">'last'</span>:<span class="string">'jerome'</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> <span class="built_in">name</span> <span class="built_in">in</span> sorted(user.keys()):</div><div class="line">    print(<span class="string">"\n"</span>+<span class="built_in">name</span>)</div><div class="line"><span class="comment">//OUTPUT</span></div><div class="line"></div><div class="line">username</div><div class="line"></div><div class="line">fist</div><div class="line"></div><div class="line">last</div></pre></td></tr></table></figure></p>
<p><strong>遍历字典中的所有值</strong><br>使用方法values()遍历字典中的所有值。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">user=&#123;</div><div class="line">    <span class="string">'username'</span>:<span class="string">'james'</span>,</div><div class="line">    <span class="string">'fist'</span>:<span class="string">'lebron'</span>,</div><div class="line">    <span class="string">'last'</span>:<span class="string">'jerome'</span>,</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> <span class="built_in">number</span> <span class="keyword">in</span> user.values():</div><div class="line">	print(<span class="built_in">number</span>)</div><div class="line"><span class="comment">//output</span></div><div class="line">james</div><div class="line">lebron</div><div class="line">jerome</div></pre></td></tr></table></figure></p>
<p><strong>字典的嵌套</strong><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">alien1=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div><div class="line">alien2=[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</div><div class="line">alien3=[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>]</div><div class="line">alien=[alien1,alien2,alien3]</div><div class="line">for alien in alien:</div><div class="line">    print(alien)</div><div class="line">//<span class="symbol">OUTPUT</span></div><div class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</div><div class="line">[<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>]</div><div class="line">[<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>]</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note4]]></title>
      <url>/2018/04/15/Python%20Crash%20Course-note4/</url>
      <content type="html"><![CDATA[<p>-if语句</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>if语句</strong><br><strong>示例程序</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cars=[<span class="symbol">'absore</span>',bmw<span class="string">','</span>core']</div><div class="line"><span class="keyword">for</span> car <span class="keyword">in</span> cars:</div><div class="line">	<span class="keyword">if</span> car==<span class="symbol">'bmw</span>':</div><div class="line">		print(car.upper())</div><div class="line">	<span class="keyword">else</span></div><div class="line">		print(car.titile())</div><div class="line"><span class="comment">//输出</span></div><div class="line">Absore</div><div class="line">BMW</div><div class="line">Core</div></pre></td></tr></table></figure></p>
<p>循环检查当前car是否为bmw，是则全大写打印，否则首字母大写打印。</p>
<p><strong>条件测试</strong><br>python检查是否相等时区分大小写。<br>如果大小写无关紧要，而只想检查变量的值，可将变量的值转换为小写，在进行比较。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">car=<span class="string">'Audi'</span></div><div class="line"><span class="keyword">if</span> car.<span class="built_in">lower</span>()==<span class="string">'audi'</span>:</div><div class="line">    <span class="built_in">print</span>(<span class="string">"true"</span>)</div><div class="line">//输出<span class="literal">true</span></div><div class="line">```		</div><div class="line"></div><div class="line">**检查不相等**</div><div class="line">要检查不相等，使用不等运算符！=即可，用法与其他语言无异。</div><div class="line"></div><div class="line">**检查多个条件**</div><div class="line">**与**：<span class="keyword">and</span><span class="comment">---等价于C++的&amp;&amp;运算符</span></div><div class="line">**或**：<span class="keyword">or</span><span class="comment">---等价于C++的||</span></div></pre></td></tr></table></figure></p>
<p>age=19<br>if age&gt;18 and age&gt;17:<br>    print(“true”)<br>if age&gt;18 or age&gt;19:<br>    print(“true”)<br> //output<br> true<br> true<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*<span class="strong">*检查特定值是否在列表中*</span><span class="strong">*</span></div><div class="line"><span class="strong">*</span><span class="strong">*关键字in*</span><span class="strong">*：判断在列表中</span></div><div class="line"><span class="strong">*</span><span class="strong">*关键中not in*</span><span class="strong">*：判断不在列表中</span></div></pre></td></tr></table></figure></p>
<p>al=[‘a’,’b’,’c’,’d’]<br>A = ‘a’<br>E= ‘e’<br>if A in al:<br>    print(“true”)<br>if E not in al:<br>    print(“true”)<br>//output<br>true<br>true<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**<span class="meta">if</span>-<span class="meta">elif</span>-<span class="meta">else</span>结构**</div></pre></td></tr></table></figure></p>
<p>age=19<br>if age<18: 28="" print("young")="" elif="" age<28:="" print("28")="" else:="" print("old")="" output="" <figure="" class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">*<span class="strong">*列表判空*</span><span class="strong">*</span></div></pre></td></tr></table></18:></p>
<p>age=[]<br>if age:<br>    print(“not empty”)<br>else:<br>    print(“empty”)<br>//output<br>empty<br>```</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note3]]></title>
      <url>/2018/04/13/Python%20Crash%20Course-note3/</url>
      <content type="html"><![CDATA[<p>-列表操作与元组</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong><font size="5">操作列表<font></font></font></strong><br><strong>1.遍历整个列表</strong><br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">magicians=[<span class="string">'alice'</span>,<span class="string">'david'</span>,<span class="string">'carolina'</span>]</div><div class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</div><div class="line">	<span class="built_in">print</span>(magician)</div><div class="line"><span class="comment">//输出</span></div><div class="line">alice</div><div class="line">david</div><div class="line">carolina</div></pre></td></tr></table></figure></p>
<p>循环定义magician从magicians中取出元素，再进行打印。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//怎么退出循环</span></div><div class="line">magicians=[<span class="string">'alice'</span>,<span class="string">'david'</span>,<span class="string">'carolina'</span>]</div><div class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</div><div class="line">	print(magician)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"good job"</span>)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">alice</div><div class="line">david</div><div class="line">carolina</div><div class="line">good job</div></pre></td></tr></table></figure>
<p>python中通过缩进来判断程序块，同样，循环也是通过缩进来控制；</p>
<hr>
<p><strong><font size="5">创建数值列表</font></strong><br><strong>1.range()的使用</strong><br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for <span class="keyword">value</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>):</div><div class="line">	<span class="built_in">print</span>(<span class="keyword">value</span>)</div></pre></td></tr></table></figure></p>
<p>range()打印1~4,并不打印5；</p>
<p><strong>2.使用range()来创建数字列表</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用list()转换成列表</span></div><div class="line">numbers=<span class="type">list</span>(range(<span class="number">1</span>,<span class="number">6</span>))</div><div class="line">print(numbers)</div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>补充：range()可以指定数字间隔<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">numbers=<span class="type">list</span>(range(<span class="number">2</span>,<span class="number">11</span>,<span class="number">2</span>))</div><div class="line">print(numbers)</div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</div></pre></td></tr></table></figure></p>
<p>函数range()从2开始数，然后不断地加2，直到达到或超过终值11。</p>
<p><strong>3.乘方运算</strong><br>python中两个星号（**）表示乘方运算。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">squares=[]</div><div class="line"><span class="keyword">for</span> <span class="keyword">value</span> <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</div><div class="line">	squares.append(<span class="keyword">value</span>**<span class="number">2</span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">81</span>,<span class="number">100</span>]</div></pre></td></tr></table></figure></p>
<p>如要使用立方只需用**3；</p>
<p><strong>4.计算函数</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">digits=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">16</span>]</div><div class="line">print(min(digits))</div><div class="line">print(max(digits))</div><div class="line">print(sum(digits))</div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">49</span></div></pre></td></tr></table></figure></p>
<p><strong>5.列表解析</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">squares=[value**<span class="number">2</span> for value in range(<span class="number">1</span>,<span class="number">11</span>)]</div><div class="line">print(squares)</div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>,<span class="number">49</span>,<span class="number">64</span>,<span class="number">81</span>,<span class="number">100</span>]</div></pre></td></tr></table></figure></p>
<p>列表解析将for循环和创建新元素的代码合成为一行，自动附加新元素，填充列表；</p>
<hr>
<p><strong><font size="5">使用列表的一部分</font></strong><br><strong>1.切片</strong><br>创建切片，指定要使用的第一个元素和最后一个元素的索引；在到达指定的第二个索引前面的元素后停止。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">players=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(players[<span class="number">0</span>:<span class="number">2</span>])</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</div></pre></td></tr></table></figure></p>
<p>如果没有指定第一个索引，python从列表开头开始提取；<br>同样地，如果没有指定第二个索引，python将一直提取到列表末尾；</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果要提取列表最后三个元素</span></div><div class="line">players=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(player[-<span class="number">3</span>:])</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</div></pre></td></tr></table></figure>
<p><strong>2.遍历切片</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用for循环来遍历切片</span></div><div class="line">players=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>]</div><div class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</div><div class="line">	print(player)</div><div class="line"><span class="comment">//输出</span></div><div class="line">a</div><div class="line">b</div><div class="line">c</div></pre></td></tr></table></figure></p>
<p><strong>3.复制列表</strong><br>复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引([:])；<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">food=[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>]</div><div class="line">food1=food[:]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food1)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>]</div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>]</div></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//区别</span></div><div class="line">food=[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>]</div><div class="line">food1=food</div><div class="line">food1.append(<span class="string">'a'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food1)</span></span></div><div class="line">food.append(<span class="string">'b'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(food1)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>，<span class="string">'a'</span>]</div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>，<span class="string">'a'</span>]</div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>，<span class="string">'a'</span>,<span class="string">'b'</span>]</div><div class="line">[<span class="string">'egg'</span>,<span class="string">'tomato'</span>,<span class="string">'potato'</span>，<span class="string">'a'</span>,<span class="string">'b'</span>]</div></pre></td></tr></table></figure>
<p>如果不使用[:]对列表进行复制的话，实质上food与food1指向同一个列表，也就是说对其中任何一个操作，另一个也随之改变，因为两者是同一个列表。</p>
<hr>
<p><strong><font size="5">元组</font></strong><br><strong>元组</strong>就是不可变的列表。</p>
<p><strong>定义元组</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">length=(<span class="number">200</span>,<span class="number">50</span>)</div><div class="line">print(length[<span class="number">0</span>])</div><div class="line">print(length[<span class="number">1</span>])</div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">50</span></div></pre></td></tr></table></figure></p>
<p>定义元组与列表的区别：<br>1.使用圆括号()而不是方括号[]来标识<br>2.元素不带引号</p>
<p>如果尝试修改元组的元素大小，python会报错。</p>
<p><strong>元组的遍历</strong><br>元组的遍历与普通列表遍历无异。使用for循环即可实现。</p>
<p><strong>修改元组变量</strong><br>元组的变量是不能直接单个进行修改的。元组是固定不变的。要想修改元组的元素，只能等效的去修改元组变量。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">length=(<span class="number">200</span>,<span class="number">50</span>)</div><div class="line">print(length[<span class="number">0</span>])</div><div class="line">print(length[<span class="number">1</span>])</div><div class="line">length=(<span class="number">250</span>,<span class="number">50</span>)</div><div class="line">print(\nlength[<span class="number">0</span>])</div><div class="line">print(length[<span class="number">1</span>])</div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">200</span></div><div class="line"><span class="number">50</span></div><div class="line"><span class="number">250</span></div><div class="line"><span class="number">50</span></div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：这种修改元组的方式是声明新元组进行覆盖，python允许这样做，因此不会报错。</p>
<hr>
<p><strong>设置代码格式</strong><br><strong>提高代码可读性：</strong><br>1.缩进<br>PEP8建议每级缩进使用4个空格。<br>2.行长<br>PEP8建议注释行长不超过72字符。<br>一般建议每行不超过80字符。<br>3.空行<br>需要使用空行来组织程序文件，但也不能滥用；</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note2]]></title>
      <url>/2018/04/13/Python%20Crash%20Course-note2/</url>
      <content type="html"><![CDATA[<p>-列表</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>列表</strong><br>列表由一系列按特定顺序排列的元素组成。<br>在Python中，用方括号（[ ]）来表示列表，并用逗号来分隔其中的元素。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bicycle=[<span class="string">'trek'</span>,<span class="string">'cannondale'</span>,<span class="string">'redline'</span>,<span class="string">'hikd'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(bicycle)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="comment">//将打印列表的内部表示，包括方括号</span></div><div class="line">[<span class="string">'trek'</span>,<span class="string">'cannondale'</span>,<span class="string">'redline'</span>,<span class="string">'hikd'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>访问列表元素</strong><br>要访问列表元素，只需要和数组一样提供索引<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">print</span><span class="params">(bicycle[<span class="number">0</span>])</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">trek</div></pre></td></tr></table></figure></p>
<p><strong>修改列表元素</strong><br>与数组修改元素无异<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">bicycle[0]</span>=<span class="string">'james'</span></div></pre></td></tr></table></figure></p>
<p><strong>在列表中添加元素</strong><br>添加元素是列表区别于数组的一个新特性<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">motorcycles=[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line">motorcycles.append(<span class="string">'james'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>,<span class="string">'james'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>列表中插入元素</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">motorcycles=[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line">motorcycles.insert(<span class="number">0</span>,<span class="string">'ducati'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line">[<span class="string">'ducati'</span>,<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>在列表中删除元素</strong><br>1.使用del语句删除元素<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">motorcycles=[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"><span class="selector-tag">del</span> motorcycles[<span class="number">0</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div><div class="line">[<span class="string">'yamha'</span>,<span class="string">'suzuki'</span>]</div></pre></td></tr></table></figure></p>
<p>2.使用pop()删除元素<br>方法pop()可删除列表末尾的元素，并可以接着使用它。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">motorcycles=[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>,<span class="string">'suzuki'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"></div><div class="line">popped_motorcycle = motorcycles.pop()</div><div class="line"><span class="function"><span class="title">printf</span><span class="params">(motorcycles)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(popped_motorcycle)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>,<span class="string">'suzuki'</span>]</div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>]</div><div class="line">suziki</div></pre></td></tr></table></figure></p>
<p>pop()在删除列表值的同时给变量赋上列表中被删除的值。</p>
<p>3.弹出列表中任何位置的值<br>pop方法适用于列表中任何位置.只需在pop方法中给一个参数代表弹出值位置即可。</p>
<p>4.根据值删除元素<br>如果只知道删除值的大小而不知道删除值的位置，可以使用remove()<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">motorcycles=[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>,<span class="string">'suzuki'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line">motorcycles.remove(<span class="string">'suzuki'</span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(motorcycles)</span></span></div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>,<span class="string">'suzuki'</span>]</div><div class="line">[<span class="string">'honda'</span>,<span class="string">'yamaha'</span>]</div></pre></td></tr></table></figure></p>
<hr>
<p><strong><font size="5">组织列表</font></strong><br><strong>使用sort()排序</strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cars=[<span class="string">'bmw'</span>,<span class="string">'audi'</span>,<span class="string">'toyota'</span>,<span class="string">'subaru'</span>]</div><div class="line">cars.<span class="keyword">sort</span>()</div><div class="line"><span class="keyword">print</span>(cars)</div><div class="line">cars.<span class="keyword">sort</span>(<span class="keyword">reverse</span>=<span class="keyword">true</span>)</div><div class="line"><span class="keyword">print</span>(cars)</div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'audi'</span>,<span class="string">'bmw'</span>,<span class="string">'subaru'</span>,<span class="string">'toyota'</span>]  <span class="comment">//按字母顺序排列</span></div><div class="line">[<span class="string">'toyota'</span>,<span class="string">'subaru'</span>,<span class="string">'bmw'</span>,<span class="string">'audi'</span>]  <span class="comment">//按字母顺序相反排列</span></div></pre></td></tr></table></figure></p>
<p>这种排序是永久的；<br>如果希望不改变列表排列顺序，进行临时排列；<br>则可以使用sorted()<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cars=[<span class="string">'bmw'</span>,<span class="string">'audi'</span>,<span class="string">'toyota'</span>,<span class="string">'subaru'</span>]</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(sorted(cars)</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(cars)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">[<span class="string">'audi'</span>,<span class="string">'bmw'</span>,<span class="string">'subaru'</span>,<span class="string">'toyota'</span>] </div><div class="line">[<span class="string">'bmw'</span>,<span class="string">'audi'</span>,<span class="string">'toyota'</span>,<span class="string">'subaru'</span>]</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>反转排序</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cars=[<span class="string">'bmw'</span>,<span class="string">'audi'</span>,<span class="string">'toyota'</span>,<span class="string">'subaru'</span>]</div><div class="line">cars.reverse()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(cars)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="comment">//reverse()将列表顺序倒置</span></div><div class="line">[<span class="string">'subaru'</span>,<span class="string">'toyota'</span>,<span class="string">'audi'</span>,<span class="string">'bmw'</span>]</div></pre></td></tr></table></figure></p>
<p><strong>确定列表长度</strong><br>len()可用于确定列表长度。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1012题解]]></title>
      <url>/2018/04/05/PAT-B1012%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="简单模拟"><a href="#简单模拟" class="headerlink" title="-简单模拟"></a>-简单模拟</h2><p>PAT-B1012. 数字分类 (20)<br>时间限制<br>100 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>8000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字：</p>
<p>A1 = 能被5整除的数字中所有偶数的和；<br>A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；<br>A3 = 被5除后余2的数字的个数；<br>A4 = 被5除后余3的数字的平均数，精确到小数点后1位；<br>A5 = 被5除后余4的数字中最大数字。<br>输入格式：</p>
<p>每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。</p>
<p>输出格式：</p>
<p>对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p>
<p>若其中某一类数字不存在，则在相应位置输出“N”。</p>
<p>输入样例1：<br>13 1 2 3 4 5 6 7 8 9 10 20 16 18<br>输出样例1：<br>30 11 2 9.7 9<br>输入样例2：<br>8 1 2 4 5 6 7 9 16<br>输出样例2：<br>N 11 2 N 9</p>
<hr>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;cstdio&gt;</span></div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> number[<span class="number">5</span>]=<span class="string">&#123;0&#125;</span>;</div><div class="line">	<span class="keyword">int</span> count[<span class="number">5</span>]=<span class="string">&#123;0&#125;</span>;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> flag=<span class="number">1</span>;</div><div class="line">	scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		scanf(<span class="string">"%d"</span>,&amp;a);</div><div class="line">		<span class="keyword">if</span>(a%5==<span class="number">0</span>)&#123;</div><div class="line">			<span class="keyword">if</span>(a%2==<span class="number">0</span>)&#123;</div><div class="line">				count[<span class="number">0</span>]+=a;</div><div class="line">				number[<span class="number">0</span>]++;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a%5==<span class="number">1</span>)&#123;</div><div class="line">			count[<span class="number">1</span>]+=flag*a;</div><div class="line">			flag*=-<span class="number">1</span>;</div><div class="line">			number[<span class="number">1</span>]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a%5==<span class="number">2</span>)&#123;</div><div class="line">			count[<span class="number">2</span>]++;</div><div class="line">			number[<span class="number">2</span>]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a%5==<span class="number">3</span>)&#123;</div><div class="line">			count[<span class="number">3</span>]+=a;</div><div class="line">			number[<span class="number">3</span>]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;</div><div class="line">			<span class="keyword">if</span>(a&gt;count[<span class="number">4</span>])</div><div class="line">				count[<span class="number">4</span>]=a;</div><div class="line">			number[<span class="number">4</span>]++;	</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(number[<span class="number">0</span>]!=<span class="number">0</span>)</div><div class="line">		<span class="keyword">printf</span>(<span class="string">"%d "</span>,count[<span class="number">0</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">printf</span>(<span class="string">"N "</span>);</div><div class="line">	<span class="keyword">if</span>(number[<span class="number">1</span>]!=<span class="number">0</span>)</div><div class="line">		<span class="keyword">printf</span>(<span class="string">"%d "</span>,count[<span class="number">1</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">printf</span>(<span class="string">"N "</span>);</div><div class="line">	<span class="keyword">if</span>(number[<span class="number">2</span>]!=<span class="number">0</span>)</div><div class="line">		<span class="keyword">printf</span>(<span class="string">"%d "</span>,count[<span class="number">2</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">printf</span>(<span class="string">"N "</span>);</div><div class="line">	<span class="keyword">if</span>(number[<span class="number">3</span>]!=<span class="number">0</span>)</div><div class="line">		<span class="keyword">printf</span>(<span class="string">"%.1f "</span>,(double)count[<span class="number">3</span>]/number[<span class="number">3</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">printf</span>(<span class="string">"N "</span>);</div><div class="line">	<span class="keyword">if</span>(number[<span class="number">4</span>]!=<span class="number">0</span>)</div><div class="line">		<span class="keyword">printf</span>(<span class="string">"%d"</span>,count[<span class="number">4</span>]);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">printf</span>(<span class="string">"N"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1018题解]]></title>
      <url>/2018/04/05/PAT-B1018%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-B1018. 锤子剪刀布 (20)</p>
<p>时间限制<br>100 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>8000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p>
<p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p>
<p>输入格式：</p>
<p>输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。</p>
<p>输出格式：</p>
<p>输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。</p>
<p>输入样例：<br>10<br>C J<br>J B<br>C B<br>B B<br>B C<br>C C<br>C B<br>J B<br>B C<br>J J<br>输出样例：<br>5 3 2<br>2 3 5<br>B B</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">charge</span><span class="params">(<span class="keyword">char</span> &amp;a)</span></span>&#123;</div><div class="line">	<span class="keyword">if</span>(a==<span class="string">'B'</span>)</div><div class="line">		a=<span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(a==<span class="string">'C'</span>)</div><div class="line">		a=<span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(a==<span class="string">'J'</span>)</div><div class="line">		a=<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">char</span> mp[<span class="number">3</span>]=&#123;<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'J'</span>&#125;;</div><div class="line">	<span class="keyword">int</span> flag1,flag2=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">char</span> a,b;</div><div class="line">	<span class="keyword">int</span> count1[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">int</span> count2[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">int</span> label1[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">int</span> label2[<span class="number">3</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</div><div class="line">		charge(a);</div><div class="line">		charge(b);</div><div class="line">		<span class="keyword">if</span>(a==b)&#123;</div><div class="line">			count1[<span class="number">1</span>]++;</div><div class="line">			count2[<span class="number">1</span>]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>((a+<span class="number">1</span>)%<span class="number">3</span>==b)&#123;   <span class="comment">//甲赢 </span></div><div class="line">			count1[<span class="number">0</span>]++; </div><div class="line">			count2[<span class="number">2</span>]++;</div><div class="line">			label1[a]++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>((b+<span class="number">1</span>)%<span class="number">3</span>==a)&#123;	  <span class="comment">//乙赢 </span></div><div class="line">			count1[<span class="number">2</span>]++;</div><div class="line">			count2[<span class="number">0</span>]++; </div><div class="line">			label2[b]++;</div><div class="line">		&#125;					</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;count1[i];</div><div class="line">		<span class="keyword">if</span>(i!=<span class="number">2</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;count2[i];</div><div class="line">		<span class="keyword">if</span>(i!=<span class="number">2</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(label1[i]&gt;label1[flag1])</div><div class="line">			flag1=i;</div><div class="line">		<span class="keyword">if</span>(label2[i]&gt;label2[flag2])</div><div class="line">			flag2=i;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;mp[flag1]&lt;&lt;<span class="string">" "</span>&lt;&lt;mp[flag2]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Crash Course-note1]]></title>
      <url>/2018/03/23/Python%20Crash%20Course-note1/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>Hello world</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello world"</span>)</span></span></div><div class="line"><span class="comment">//变量形式</span></div><div class="line">message=<span class="string">"Hello world"</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(message)</span></span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>变量命名规则</strong><br>1.变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头。<br>2.变良名不能包含空格，但可使用下划线来分隔。<br>3.不能将python关键字和函数名用作变量名。<br>4.变量名应既简短又具有描述性。<br>5.慎用小写字母l和大写字母O。</p>
<hr>
<p><strong><font size="5">字符串</font></strong><br>字符串就是一系列字符。在python中，使用单引号或双引号括起来都行。</p>
<p><strong>使用方法修改字符串大小写</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name=<span class="string">"ada lovelace"</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(name.title()</span></span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line">Ada Lovelace</div></pre></td></tr></table></figure></p>
<p>方法是python对数据可进行的一种操作。每个方法后都跟着一对括号，因为通常需要额外的信息来完成工作。这种信息是括号内提供的。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">name=<span class="string">"James"</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(name.upper()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(name.lower()</span></span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line">JAMES</div><div class="line">james</div></pre></td></tr></table></figure>
<p>title()以首字母大写的方式显示每个单词，upper()以每个字母都大写显示，lower以每个字母都小写显示</p>
<p><strong>合并（拼接）字符串</strong><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">first=<span class="string">"Lebron"</span></div><div class="line">second=<span class="string">"James"</span></div><div class="line">full=first+<span class="string">" "</span>+second</div><div class="line">print(full)</div><div class="line">//输出</div><div class="line">Lebron James</div></pre></td></tr></table></figure></p>
<p>Python使用+来合并字符串；</p>
<p><strong>使用制表符或换行符</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">"Languages:<span class="subst">\n</span>Python<span class="subst">\n</span>C<span class="subst">\n</span>JavaScript"</span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line">Languages：</div><div class="line">Python</div><div class="line">C</div><div class="line">JavaScript</div><div class="line"></div><div class="line">print(<span class="string">"Languages:<span class="subst">\n</span><span class="subst">\t</span>Python<span class="subst">\n</span><span class="subst">\t</span>C<span class="subst">\n</span><span class="subst">\t</span>JavaScript"</span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line">	Languages：</div><div class="line">	Python</div><div class="line">	C</div><div class="line">	JavaScript</div></pre></td></tr></table></figure></p>
<p><strong>删除空白</strong><br>Python能够找出字符串开头和末尾的空白。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">language=<span class="string">"Python "</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(language)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(language.rstrip()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(language)</span></span></div><div class="line"><span class="comment">//输出</span></div><div class="line">有空格</div><div class="line">无空格</div><div class="line">有空格</div><div class="line"><span class="comment">//这种方法是暂时的，若要将空格删除保存</span></div><div class="line">language=language.rstrip()</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(language)</span></span></div><div class="line"><span class="comment">//此后，language保存为Python</span></div></pre></td></tr></table></figure></p>
<p>Python还可以剔除字符串开头的空白，或者同时提出字符串两端的空白。使用lstrip()和strip()分别可以实现。</p>
<p><strong>避免语法错误</strong><br>如果字符串中有单引号时，如果使用单引号来标识字符串，则会让Python不知道哪里是字符串的结束而出错。因此，如果字符串中有单引号，应用双引号来标识字符串。三引号最保险，但不常用。</p>
<hr>
<p><strong><font size="5">数字</font></strong><br><strong>整数运算</strong><br>其他与算数运算基本无异。<br>Python使用**来表示乘方<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(<span class="number">2</span>**<span class="number">3</span>)</div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="number">8</span></div></pre></td></tr></table></figure></p>
<p><strong>浮点数运算</strong><br>浮点数运算也与平常无异。<br>不过，浮点数包含的小数位数可能是不确定的。需要进行处理多余小数位。</p>
<p><strong>使用str()转换类型</strong><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">age=23</div><div class="line">message=<span class="string">"Happy"</span>+age+<span class="string">"ed Birthday!"</span></div><div class="line">print(message)</div><div class="line">//error</div><div class="line">age=23</div><div class="line">message=<span class="string">"Happy"</span>+str(age)+<span class="string">"ed Birthday!"</span></div><div class="line">print(message)</div><div class="line">//输出</div><div class="line">Happy 23rd birthday</div></pre></td></tr></table></figure></p>
<hr>
<p><strong><font size="5">注释</font></strong><br>注释的写法：C/C++用//<br>Python中用#来注释</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash">TEST</span></div></pre></td></tr></table></figure>
<hr>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自顶向下-note2]]></title>
      <url>/2018/03/18/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-note2/</url>
      <content type="html"><![CDATA[<p>-应用层协议<br>-FTP<br>-HTTP<br>-电子邮件系统</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><font size="5">『第二章 应用层』</font><br><font size="5">『2.1 应用层协议原理』</font><br><strong><font size="5">网络应用程序体系结构</font></strong><br>研究网络应用的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序。<br>应用程序体系结构由应用程序研发者设计、规定了如何在各终端系统上阻止该程序。<br>应用程序体系结构有两种主流的体系结构：<strong>客户-服务器结构</strong>和<strong>对等（P2P）体系结构</strong>。<br><br><strong>客户-服务器结构</strong><br>1.其中，有一个总是打开的主机成为<strong>服务器</strong>。<br>2.在客户-服务器结构中，客户之间并不直接通信。<br>3.服务器具有固定的、周知的地址，称为<strong>IP地址</strong>，客户通过向服务器的IP地址发送分组来与其联系。<br><font color="#00008B" size="4">具有客户-服务器体系结构的非常著名的应用程序包括Web、FTP、Telnet和电子邮件</font>

<p><strong>P2P体系结构</strong><br>1.对位于数据中心的专用服务器有最小的（或没有）依赖<br>2.应用程序在间断连接的主机之间使用直接通信，这些主机对被称为<strong>对等方</strong></p>
<font color="#00008B" size="4">许多目前流行的、流量密集型的应用都是P2P体系结构的，包括文件共享、对等方协助下载加速器（迅雷）、因特网电话（skype）和IPTV（迅雷看看和PPstream）</font>

<p>P2P具有<strong>自扩展性</strong>。在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作量，但每个对等方通过向其他对等方分发文件也为系统增加了服务能力。</p>
<hr>
<p><strong><font size="5">进程通信</font></strong><br>在操作系统的术语中，进行通信的实际上是<strong>进程</strong>，而不是程序。<br>一个进程可以被认为是运行在端系统中的一个程序。当进程运行在相同的端系统上时，它们使用进程间通信机制相互通信。<br>进程间通信的规则由端系统上的操作系统确定。</p>
<p>在两个不同端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>而相互通信。<br>发送进程生成并向网络中发送报文；<br>接受进程接受这些报文并可能通过将报文发送回去进行响应。</p>
<p><strong>1.客户和服务器进程</strong><br>网络应用程序有成对的进程组成，这些进程通过网络相互发送报文。对每对通信进程，通常将这两个进程之一标识为<strong>客户</strong>，而另一个进程标识为<strong>服务器</strong>。</p>
<font color="#00008B" size="4">在给定的一对进程之间的通信会话场景中，发起通信（即在该回话开始时发送与其他进程的联系）的进程被称为<strong>客户</strong>，在会话开始时等待联系的进程是<strong>服务器</strong></font>

<p><strong>2.进程与计算机网络之间的接口</strong><br>进程通过一个称为<strong>套接字</strong>的软件接口向网络发送报文和从网络接受报文。<br>套接字也成为应用程序和网络之间的<strong>应用程序编程接口</strong></p>
<p><strong>3.进程寻址</strong><br>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接受进程需要有一个地址。为了标识该接受进程，需要定义两种信息：①主机的地址；②定义在目的主机中的接受进程的标识符。</p>
<font color="#00008B" size="4">在因特网中，<strong>主机</strong>由其IP地址标识</font><br>除了知道报文送往目的地的主机地址以外，发送进程还必须指定运行在接受主机上的接受进程。<br>目的地<strong>端口号</strong>就用于这个目的。<br><br>—<br><strong><font size="5">可供应用程序使用的运输服务</font></strong><br>套接字是应用程序进程和运输层协议之间的接口。<br>一个运输层协议可以提供以下集中服务：<br>1.可靠数据传输<br>2.吞吐量<br>3.定时<br>4.安全性<br><br><br><strong>可靠数据传输</strong><br>运输层协议能够潜在的向应用程序提供一个重要服务是进程到进程的可靠数据传输。当一个运输协议提供这种服务时，发送进程只要将其数据传递进套接字，就可以完全相信该数据能无差错地到达接收进程。<br><br><strong>吞吐量</strong><br>运输层协议能够以某种特定速率提供确保的可用吞吐量。<br>具有吞吐量要求的应用程序被称为<strong>带宽敏感应用</strong><br>相对的，<strong>弹性应用</strong>则可根据情况或多或少的利用可供使用的吞吐量。<br><br><strong>定时</strong><br>运输层协议可以提供定时保证。一个保证的例子如：发送方注入进套接字中的每个比特到达接收方的套接字不迟于100ms<br><br><strong>安全性</strong><br>运输协议能够加密由发送进程传输的所有数据，在接受主机中，运输层协议能够在将数据交付给接收进程之前解密这些数据。<br><br>—<br><strong><font size="5">因特网提供的传输服务</font></strong><br>因特网为应用程序提供两个运输层协议 ，即<strong>UDP</strong>和<strong>TCP</strong>。<br><br><strong>TCP服务</strong><br>TCP服务模型包括<strong>面向连接服务</strong>和<strong>可靠数据传输服务</strong>。当某个应用程序调用TCP作为其运输协议时，该应用程序就能获得来自TCP的这两种服务。<br><strong>面向连接的服务</strong>：在应用层数据报文开始流动之前，TCP让客户和服务器互相交换运输层控制信息。这个所谓握手过程提示客户和服务器，使它们为大量分组的到来做好准备。在握手阶段后，一个<strong>TCP连接</strong>就在两个进程的套接字之间建立了。这条连接是全双工的。当应用程序结束报文发送时，必须拆除该连接。<br><strong>可靠的数据传送服务</strong><br>通信进程能够依靠TCP，无差错、按适当顺序交付所有发送的数据。当应用程序的一段将字节流传进套接字时，它能够依靠TCP将相同的字节流交付给接收方的套接字，而保证没有字节的丢失和冗余。<br><br>TCP协议还具有拥塞控制机制。当发送方和接收方之间的网络发生拥塞时，TCP的拥塞控制机制会抑制发送进程。<br><font color="#00008B" size="4">无论是TCP还是UDP都没有提供任何加密机制。研制了TCP的加强版本，称为<strong>安全套接字层</strong>，SSL。SSL不是与TCP和UDP在同一层次上的第三种因特网传输协议，而是一种对TCP的加强，这种强化是在应用层上实现的。</font>

<p><strong>UDP服务</strong><br>UDP是一种不提供不必要服务的轻量级运输协议，它仅仅提供最小服务。UDP是无连接的，因此在两个进程通信前没有握手过程。UDP协议提供一种不可靠数据传送服务。UDP没有拥塞控制机制。</p>
<hr>
<p><strong><font size="5">应用层协议</font></strong><br><strong>应用层协议</strong>定义了运行在不同端系统上的应用程序进程如何相互传递报文；<br>应用层协议定义了：<br>1.交换的报文类型，例如：请求报文和响应报文<br>2.各种报文类型的语法，如报文中的各个字段及这些字段是如何描述的<br>3.字段的语义，即这些字段中包含的信息的含义<br>4.一个进程何时以及如何发送报文，对报文进行响应的规则</p>
<hr>
<font size="5">『2.2 Web和HTTP』</font><br><strong><font size="5">HTTP概况</font></strong><br>Web的应用层协议是<strong>超文本传输协议</strong>，<strong>HTTP</strong>，它是Web的核心。<br>HTTP由两个程序实现：一个客户程序和一个服务器程序。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP报文进行会话。HTTP定义了这些报文的结构以及客户和程序进行报文交换的方式。<br><br><br><strong>Web页面</strong>是由<strong>对象</strong>组成的。一个<strong>对象</strong>只是一个文件。多数Web页面含有一个HTML基本文件以及几个引用对象。HTML基本文件通过对象的URL地址引用页面中的其他对象。每个<strong>URL地址</strong>由两部分组成：存放对象的服务器主机名和对象的路径名。<br><br><strong>Web服务器</strong>实现了HTTP的服务器端，用于存储Web对象，每个对象由URL寻址。<br><br><font color="#00008B" size="4">HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。</font>

<p>HTTP使用TCP作为它的支撑运输协议。HTTP并不保存关于客户的任何信息，所以HTTP是一个<strong>无状态协议</strong>。</p>
<p><strong>非持续连接和持续连接</strong><br><strong>非持续连接</strong>：每个请求/响应对是经一个单独的TCP连接发送<br><strong>持续连接</strong>：所有的请求以及响应经相同的TCP连接发送 </p>
<p><strong>往返时间</strong>：往返时间（RTT）是指一个短分组从客户到服务器然后再返回客户所花费的时间。<br><strong>“三次握手”过程</strong>：客户向服务器发送一个小TCP报文段，服务器用一个小TCP报文段做出确认和响应。最后，客户向服务器返回确认。完成三次握手后，向该TCP连接发送一个HTTP请求报文。</p>
<font color="#00008B" size="4">粗略来讲，总的响应时间就是两个RTT加上服务器传输HTML的时间。</font>



<hr>
<p><strong><font size="5">HTTP报文格式</font></strong><br>HTTP报文有两种：<br>1.请求报文<br>2.响应报文</p>
<p><strong><font size="5">请求报文</font></strong><br>HTTP请求报文的第一行叫做<strong>请求行</strong>，其后继的行叫做<strong>首部行</strong>。<br><strong>请求行</strong>有3个字段:<br>1.方法字段<br>2.URL字段<br>3.HTTP版本字段</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> HTTP/1.1</div></pre></td></tr></table></figure>
<p>方法字段可以取几种不同的值：<strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>、<strong>PUT</strong>和<strong>DELETE</strong>。绝大部分HTTP请求报文使用GET方法。URL字段带有请求对象的标识。</p>
<p><strong>首部行</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Host： </div><div class="line">www<span class="selector-class">.someschool</span><span class="selector-class">.edu</span></div></pre></td></tr></table></figure></p>
<p>首部行指明了对象所在的主机。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connection： <span class="built_in">close</span></div></pre></td></tr></table></figure>
<p>告诉服务器不希望麻烦地使用持续连接，它要求服务器在发送完被请求对象后就关闭这条连接。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">User</span>-agent： Mozilla/<span class="number">5.0</span></div></pre></td></tr></table></figure>
<p>指明用户代理，即向服务器发送请求的浏览器类型。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Accept</span>-language： fr</div></pre></td></tr></table></figure>
<p>表示用户想得到该对象的法语版本</p>
<p><strong><font size="5">响应报文</font></strong><br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line">Connection： close</div><div class="line"><span class="built_in">Date</span>： Tue， <span class="number">09</span> Aug <span class="number">2011</span> <span class="number">15</span>:<span class="number">44</span>:<span class="number">04</span> GMT</div><div class="line">Server: Apache/<span class="number">2.2</span><span class="number">.3</span> (CentOS)</div><div class="line">Last<span class="params">-Modified</span>: Tue，<span class="number">09</span> Aug <span class="number">2011</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">03</span> GMT</div><div class="line">Content<span class="params">-Length</span>: <span class="number">6821</span></div><div class="line">Content<span class="params">-Type</span>: text/html</div><div class="line"></div><div class="line">(<span class="built_in">data</span> <span class="built_in">data</span> <span class="built_in">data</span> <span class="built_in">data</span> <span class="built_in">data</span> <span class="params">...</span>)</div></pre></td></tr></table></figure></p>
<p>这个响应报文有三个部分：一个初始<strong>状态行</strong>，6个<strong>首部行</strong>，然后是<strong>实体主体</strong>。<br>实体主体部分是报文的主要部分，它包含了所请求的对象本身（表示为data data data data data …）。<br>状态行有三个字段：<strong>协议版本字段</strong>、<strong>状态码</strong>和相应<strong>状态信息</strong>。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</div><div class="line"><span class="comment">//该状态行指示服务器正在使用HTTP/1.1，并且一切正常</span></div></pre></td></tr></table></figure></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Connection： <span class="built_in">close</span></div><div class="line"><span class="comment">//该首部行告诉客户，发送完报文后将关闭该TCP连接。</span></div></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Date</span>： <span class="selector-tag">Tue</span>， <span class="selector-tag">09</span> <span class="selector-tag">Aug</span> <span class="selector-tag">2011</span> <span class="selector-tag">15</span><span class="selector-pseudo">:44</span><span class="selector-pseudo">:04</span> <span class="selector-tag">GMT</span></div><div class="line"><span class="comment">//该首部行指示服务器产生并发送该响应报文的日期和时间</span></div></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Server</span>: Apache/<span class="number">2.2</span><span class="number">.3</span> (CentOS)</div><div class="line"><span class="comment">//该首部行指示该报文是由一台Apache Web服务器产生的</span></div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Last-<span class="string">Modified:</span> Tue，<span class="number">09</span> Aug <span class="number">2011</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">03</span> GMT</div><div class="line"><span class="comment">//该首部行指示了对象创建或者最后修改的时间</span></div></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Content-<span class="string">Length:</span> <span class="number">6821</span></div><div class="line"><span class="comment">//该首部行指示了被发送对象的字节数</span></div></pre></td></tr></table></figure>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Content-<span class="built_in">Type</span>: <span class="built_in">text</span>/html</div><div class="line"><span class="comment">//该首部行指示了实体主体中的对象是HTML文本</span></div></pre></td></tr></table></figure>
<p> 状态码及其相应的短语指示了请求的结果：</p>
<font color="#00008B" size="3"> 200 OK: 请求成功，信息在返回的响应报文中<br> 301 Moved Permanently： 请求的对象已经被永久转移了，新的URL定义在响应报文的<br>Location：首部行中。客户软件将自动获取新的URL。<br> 400 Bad Request： 一个通用差错代码，指示该请求不能被服务器理解。<br> 404 Not Found： 被请求的文档不在服务器上。<br> 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。<br></font>


<hr>
<p><strong><font size="5">用户与服务器的交互</font></strong><br>Web站点希望能够识别用户，为此，HTTP使用了<strong>cookie</strong><br>cookie技术有4个组件：<br>1.在HTTP响应报文中的一个cookie首部行；<br>2.在HTTP请求报文中的一个cookie首部行；<br>3.在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理；<br>4.位于Web站点的一个后端数据库。</p>
<hr>
<p><strong><font size="5">Web缓存</font></strong><br><strong>Web缓存器</strong>也叫<strong>代理服务器</strong>，它是能够代表初始Web服务器来满足HTTP请求的网络实体。Web缓存器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本。</p>
<p>因特网部署Web缓存器有两个原因。<br>首先，Web缓存器可以大大减少对客户请求的响应时间。<br>其次，Web缓存器能够大大减少一个机构的接入链路到因特网的通信量。</p>
<p><strong>条件GET方法</strong><br>条件GET请求报文：<br>1.请求报文使用GET方法<br>2.请求报文中包含一个“If-Modified-Since: ”首部行</p>
<hr>
<font size="5">『2.3 文本传输协议：FTP』</font><br><strong>HTTP</strong>和<strong>FTP</strong>都是文本传输协议，并且有很多共同的特点。例如：都运行在TCP上。<br>然而，这两个应用层协议也有一些重要区别，最显著的就是FTP使用两个并行的TCP连接来传输文件：<strong>控制连接</strong>和<strong>数据连接</strong>。<br><strong>控制连接</strong>：用于两主机之间传输控制信息，如用户标识，口令，改变远程目录的命令以及“存放”和“获取”文件的命令。<br><strong>数据连接</strong>：用于实际发送一份文件。<br>FTP使用控制连接来传输控制信息，因此FTP控制信息是<strong>带外</strong>传送的。<br>HTTP协议是在传输文件的同一个TCP连接中发送请求和响应首部行的。HTTP是<strong>带内</strong>发送控制信息的。<br><font color="#00008B" size="3">FTP服务器必须在整个会话期间保留用户的<strong>状态</strong>。HTTP则是无状态的，它不必对任何用户状态进行追踪</font>

<p><strong>FTP命令</strong></p>
<font color="#00008B" size="3">常见的命令如下：<br>USER username: 用于向服务器传送用户标识<br>PASS password: 用于向服务器发送用户口令<br>LIST: 用于请求服务器会送当前远程目录中的所有文件列表。该文件列表是经一个（新建且非持续连接）数据连接传送的，而不是在控制TCP连接上传送。<br>RETR filename: 用于在远程主机的当前目录检索文件。该命令引起远程主机发起一个数据连接，并经该数据连接发送所请求的文件。<br>STOR filename: 用于在远程主机的当前目录上存放文件。</font>

<hr>
<font size="5">『2.4 因特网中的电子邮件』</font><br>因特网电子邮件系统主要由三个主要部分：<strong>用户代理</strong>，<strong>邮件服务器</strong>和<strong>简单邮件传输协议</strong>。<br><strong>SMTP</strong>是因特网电子邮件中主要的应用层协议。它使用TCP可靠数据传输服务，从发送方的邮件服务器向接收方的邮件服务器发送邮件。<br><br><strong><font size="5">SMTP</font></strong><br>SMTP是电子邮件应用的核心。<br><strong>HTTP</strong>：<br>1.从Web服务器向Web客户传送文件<br>2.进行文件传输时，使用持续连接<br>3.HTTP是<strong>拉协议</strong>，从服务器拉取信息<br>4.HTTP数据不受限制<br>5.HTTP把每个对象封装到他自己的HTTP响应报文中<br><strong>SMTP</strong>：<br>1.从发送邮件服务器到接收邮件服务器<br>2.进行文件传输时，使用持续连接<br>3.SMTP是<strong>推协议</strong>，发送邮件服务器把文件推向接收邮件服务器<br>4.SMTP要求每个报文使用7比特ASCII码格式<br>5.SMTP吧所有报文对象放在一个报文之中<br><br>—<br><strong>邮件访问协议</strong><br>部分流行的邮件访问协议，包括<strong>第三版的邮局协议（POP3）</strong>，<strong>因特网邮件访问协议(IMAP)</strong>以及<strong>HTTP</strong>。<br><br><strong>POP3</strong><br>POP3是一个极为简单的邮件访问协议。<br>随着建立TCP连接，POP3按照三个阶段进行工作：<strong>特许</strong>、<strong>事务处理</strong>以及<strong>更新</strong>。<br>在<strong>特许阶段</strong>，用户代理发送用户民和口令以鉴别用户。<br>在<strong>事务处理阶段</strong>，用户代理取回报文。<br>在<strong>更新阶段</strong>，它出现在客户发出了quit命令之后，目的是结束该POP3会话。<br><br>在POP3的事务处理过程中，用户代理发出一些命令，服务器对每个命令做出回答。回答可能有两种：+OK（服务器表示前面的命令是正常的），-ERR（服务器用来指示前面的命令出错）<br><br><strong>IMAP</strong><br>IMAP比POP3有更多的特色，但是同时，也比POP3复杂的多。<br>IMAP服务器把每个报文与一个文件夹联系起来。<br>IMAP协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令。IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的条件。IMAP另一个重要特性是它具有允许用户代理获取报文组件的命令。<br><br><br>—<br><font size="5">『2.5 DNS：因特网的目录服务』</font><br>主机的一种标识方法是用它的<strong>主机名</strong>，如cnn.com、www.yahoo.com等。但是主机名几乎没有提供关于主机在因特网中位置的信息。主机也可以使用<strong>IP地址</strong>进行标识。一个IP地址由4个字节组成，并有着严格的层次结构。<br><br><strong>DNS</strong><br><strong>域名系统（DNS）</strong>的主要任务就是将人们喜欢的主机名标识方式转换成路由器喜欢的IP地址标识方式。<br>DNS是：<br>1.一个由分层的<strong>DNS服务器</strong>实现的分布式数据库；<br>2.一个使得主机能够查询分布式数据库的应用层协议。<br><br><font color="#00008B" size="3">DNS协议运行在UDP之上</font>

<p>DNS通常是由其他应用层协议所使用的，包括<strong>HTTP</strong>、<strong>SMTP</strong>和<strong>FTP</strong>，将用户提供的主机名解析为IP地址。<br>除了进行主机名到IP地址的转换之外，DNS还提供了一些重要的服务：<br>1.<strong>主机别名</strong><br>2.<strong>邮件服务器别名</strong><br>3.<strong>负载分配</strong> DNS也用于在冗余的服务器上进行负载分配。繁忙站点被荣誉分布在多台服务器上。</p>
<hr>
<p><strong>DNS工作机理</strong><br>集中式设计有很多问题：<br>1.单点故障<br>2.通信容量<br>3.远距离的集中式数据库<br>4.维护</p>
<p><font color="#00008B" size="3">DNS采用了分布式的设计方案</font><br>有三种类型DNS服务器：<br>1.根DNS服务器<br>2.顶级域服务器（TLD）<br>3.权威DNS服务器<br>还有另一类服务器，<strong>本地DNS服务器</strong>，但严格来说不属于层次结构。</p>
<p><strong>DNS缓存</strong><br>为了改善时延性能并减少在因特网上到处传输的DNS报文数量。<br>在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。</p>
<p><strong>DNS记录和报文</strong><br>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录（RR）</strong>。RR提供了主机名到IP地址的映射。</p>
<p><strong>资源记录</strong>是一个包含了下列字段的4字组：<br>（Name ，Value，Type，TTL）<br><strong>TTL</strong>是该记录的生存时间，它决定了资源纪律应当从缓存中删除的时间。Name和Value的值取决于Type：<br>1.如果Type=A，则Name是主机名，Value是该主机名对应的IP地址。<br>2.如果Type=NS，则Name是个域，Value是个知道如何获取该域名中主机IP地址的权威DNS服务器的主机名。<br>3.如果Type=CNAME，Value是别名为Name的主机对应的规范主机名。<br>4.如果Type=MX，则Value是个别名为Name的邮件服务器的规范主机名。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器学习之西瓜书-note1]]></title>
      <url>/2018/03/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%A5%BF%E7%93%9C%E4%B9%A6-note1/</url>
      <content type="html"><![CDATA[<p>-诸论<br>-基本术语介绍</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">『第一章 诸论』</font></strong><br><strong><font size="5">『1.1 引言』</font></strong><br><strong>学习算法</strong>：机器学习所研究的主要内容，是关于在计算机上从数据中产生“模型”的算法，即“学习算法”。</p>
<p><strong>学习算法的作用</strong>：<br>1.基于提供的经验数据产生模型；<br>2.面对新情况时，模型可提供相应的判断。</p>
<p><strong>模型</strong>：泛指从数据中学得的结果。</p>
<hr>
<p><strong><font size="5">『1.2 基本术语』</font></strong><br><strong>数据集</strong>：记录的集合<br><strong>示例/样本/特征向量</strong>：每条记录或空间中的每个点<br><strong>属性/特征</strong>：反映事件或对象在某方面的表现或性质的事项<br><strong>属性值</strong>：属性上的取值<br><strong>属性空间/样本空间/输入空间</strong>：属性张成的空间<br><strong>维数</strong>：示例的属性描述个数<br><strong>学习/训练</strong>：从数据中学的模型的过程<br><strong>训练数据</strong>：训练过程中使用的数据<br><strong>训练样本</strong>：训练过程中使用数据的每个样本<br><strong>训练集</strong>：训练样本组成的集合<br><strong>假设</strong>：学得模型对应了关于数据的某种潜在数据<br><strong>真实/真相</strong>：这种潜在规律本身<br><strong>学习器</strong>：学习算法在给定数据和参数空间上的实例化<br><strong>标记</strong>：关于示例结果的信息<br><strong>样例</strong>：拥有了标记信息的示例<br><strong>标记空间/输出空间</strong>：所有标记的集合<br><img src="//img-blog.csdn.net/20180316232806599" alt="这里写图片描述"><br><strong>测试</strong>：学得模型后，使用其进行预测的过程<br><strong>测试样本</strong>：被预测的样本<br><strong>聚类</strong>：将新联系中的样例分成若干组<br><strong>簇</strong>：每组称为一个簇，这些自动形成的簇可能对应一些潜在的概念划分<br><img src="//img-blog.csdn.net/20180317012109324?" alt="这里写图片描述"></p>
<font size="5">机器学习的目标是使学得的模型能很好地适用于新样本，而不仅仅是在训练样本上工作得很好</font><br><strong>泛化能力</strong>：学得模型适用于新样本的能力<br><br>—<br><strong><font size="5">『1.3 假设空间』</font></strong><br>归纳与演绎是科学推理的两大基本手段；<br><img src="//img-blog.csdn.net/20180317012914931?" alt="这里写图片描述"><br><br>归纳学习有狭义与广义之分；<br>广义的归纳学习大体相当于从样例中学习；<br>狭义的归纳学习要求从训练数据中学得概念。因此也称为<strong>概念学习/概念形成</strong><br><br>概念学习中最基本的是<strong>布尔概念学习</strong>。也就是对“是”“不是”这样的可表示为0/1布尔值的目标概念的学习。<br><br><strong>学习过程</strong>可看作一个在所有假设组成的空间中进行搜索的过程，<strong>搜索目标</strong>是找到与训练集匹配的假设。<br><br><strong>假设空间</strong>：机器学习中可能的函数构成的空间称为“假设空间”<br><strong>版本空间</strong>：一个与训练集一致的“假设集合”<br><br>『假设空间规模问题』<br>1.如果某一属性值无论取什么值都合适，用通配符”<em>“来表示<br>2.概念根本就不存在，用ø来表示<br>书中西瓜的例子，有”色泽“”根蒂“”敲声“三种属性，每个属性又有“三种”可能值，但是事实上面临的假设空间大小规模为4</em>4<em>4+1=65。这是因为“无论取什么值都合适”也是一种属性值。也就是说，事实上，每种属性有四种取值，3+都合适。<br>4（色泽）</em>4（根蒂）<em>4（敲声）+1（好瓜概念不存在）=65<br><br><br><br><br>—<br><strong><font size="5">『1.4 归纳偏好』</font></strong><br><em>*归纳偏好/偏好</em></em>：机器学习算法在学习过程中对某种类型假设的偏好<br><br><font size="5">任何一个“正确”的模型的学习算法必须有某种偏好</font>

<p><strong>“奥卡姆剃刀”原则</strong>：若有多个假设与观察一致，则选最简单的那个<br>奥卡姆剃刀并非唯一可行的原则，奥卡姆剃刀本身就存在不同的诠释</p>
<p><strong>”没有免费的午餐“定理（NFL定理）</strong>：总误差与算法无关<br><strong>1</strong>.没有一个学习算法可以在任何领域总是产生最准确的学习器。不管采用何种学习算法，至少存在一个目标函数，能够使得随机猜测算法是更好的算法。<br><strong>2</strong>.NFL定理最重要的寓意：脱离具体问题，空泛地谈论”什么学习算法更好“毫无意义，因为若考虑所有潜在的问题，则所有学习算法一样好。</p>
<hr>
<p><strong><font size="5">『习题』</font></strong><br><strong>1.1</strong> 表1.1中若只包含编号为1和4的两个样例，试给出相应的版本空间。<br><strong>答</strong>：因为编号1和编号4的三个属性值均不相同。与训练集一致的假设集合为版本空间。<br>其取值则共有七种，其合取式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">（色泽＝青绿）∧（根蒂＝ ∗ ）∧（敲声＝ ∗ ）</div><div class="line"></div><div class="line">（色泽＝ ∗ ）∧（根蒂＝蜷缩）∧（敲声＝ ∗ ）</div><div class="line"></div><div class="line">（色泽＝ ∗ ）∧（根蒂＝ ∗ ）∧（敲声＝浊响）</div><div class="line"></div><div class="line">（色泽＝青绿）∧（根蒂＝蜷缩）∧（敲声＝ ∗ ）</div><div class="line"></div><div class="line">（色泽＝青绿）∧（根蒂＝ ∗ ）∧（敲声＝浊响）</div><div class="line"></div><div class="line">（色泽＝ ∗ ）∧（根蒂＝蜷缩）∧（敲声＝浊响）</div><div class="line"></div><div class="line">（色泽＝青绿）∧（根蒂＝蜷缩）∧（敲声＝浊响）</div></pre></td></tr></table></figure>
<p><strong>1.2</strong> 与使用单个合取式来进行假设表示相比，使用“析合范式”将使得假设空间具有更强的表示能力。例如：<br>好瓜←→（(色泽=<em>)∧(根蒂=蜷缩)∧(敲声=</em>)）∨（(色泽=乌黑)∧(根蒂=*)∧(敲声=沉闷)）<br>会把“（(色泽=青绿)∧(根蒂=蜷缩)∧(敲声=清脆)）”以及“（(色泽=乌黑)∧(根蒂=硬挺)∧(敲声=沉闷)）”都分类为“好瓜”。<br>若使用最多包含k个合取式的析合范式来表达表1.1西瓜分类问题的假设空间，试估算共有多少种可能的假设。</p>
<p><strong>答</strong>：此表的色泽属性只有：1.青绿、2.乌黑 两种属性值，故其假设空间规模大小为： 3×4×4+1=49种。<br>k的最大值为49。<br>因此，可能的假设有2<sup>49</sup>中可能的假设。</p>
<p><strong>1.3</strong>1.3 若数据包含噪声，则假设空间中有可能不存在与所有训练样本都一致的假设。在此情形下，试设计一种归纳偏好用于假设选择。<br><strong>答</strong>：在训练过程中选取满足样本最多的假设</p>
<p><strong>1.4</strong> 本章1.4节在论述“没有免费的午餐”定理时，默认使用了“分类错误率”作为性能度量来对分类器进行评估。若换用其他性能度量l,试证明没有免费的午餐”定理仍成立。<br><strong>答</strong>：还是考虑二分类的问题， NFL首先要保证真实目标函数​ 均匀分布，对于有​个样本的二分类问题，显然​共有​ 种情况。其中一半是与假设一致的，此时，​应该是个常数，隐含的条件就是（一个比较合理的充分条件）​ 。如果不满足，NFL不成立。</p>
<p><strong>1.5</strong>试述机器学习能在互联网搜索的哪些环节起什么作用。<br><strong>答</strong>：<br>最常见的，消息推送，比如淘宝发送的某些感兴趣的商品。（商品推荐，物品推荐）<br>网站相关度排行，通过点击量，网页内容进行综合分析。<br>图片搜索，现在大部分是通过标签来搜索，不过基于像素的搜索总会有把。</p>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Machine learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自顶向下-note1]]></title>
      <url>/2018/03/16/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B-note1/</url>
      <content type="html"><![CDATA[<p>-计算机网络基础<br>-分组交换电路交换<br>-分层模型</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>ISP：因特网服务提供商<br>TCP：传输控制协议<br>IP：网际协议<br>API：应用程序编程接口<br>端系统：与因特网相连的计算机和其它设备<br>主机：与端系统无差异</p>
<hr>
<p>物理媒体划分为两类：<br>1.导引性媒体<br>2.非导引性媒体</p>
<p>UTP：无屏蔽双绞线，常用于局域网（LAN）中。所能达到的数据传输速率取决于线的粗细以及传输方和接收方之间的距离。</p>
<hr>
<p>FDM：频分复用<br>TDM：时分复用<br>IXP：因特网交换点</p>
<p>分组交换总时延包括结点处理时延、排队时延、传输时延和传播时延。</p>
<hr>
<p><strong>传输时延和传播时延的区别</strong><br>  传输时延假定分组以先到先服务的方式传输——这在分组交换网络中是常见的方式，仅当所有已经到达的分组被传输后，才能传输我们的分组。用L比特表示分组的长度，用R bps表示从路由器A到路由器B的链路传输速率。传输时延是L/R。这是将所有分组比特推向链路所需要的时间。实际的传输时延通常在毫秒到微秒级。传播时延一旦一个比特被推向链路，该比特需要向路由器B传播，从该链路的起点到路由器B的传播所需要的时间是传播时延。该比特以该链路的传播速率传播，该传播速率取决于该链路的物理媒介，其速率范围是 m/s，这等于或略小于光速。传播时延等于两台路由器之间的距离除以传播速率，即传播时延是d/s，期中d是两台路由器之间的距离，s是该链路的传播速率。传播时延在毫秒级。传播时延和传输时延的比较计算机网络领域的新手有时难以理解传输时延和传播时延之间的差异，该差异虽说细小但是很重要。传输时延是路由器将分组推出所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。传播时延是一个比特从一台路由器向另一台路由器传播所需要的时间，它是两台路由器之间距离的函数，但与分组的长度或链路的传输速率无关。</p>
<hr>
<p>协议栈：综合所有层次中的协议，就为协议栈</p>
<p>五层模型：物理层、链路层、网络层、运输层和应用层。</p>
<p>应用层协议：<br>HTTP：提供了web文档的请求和传送<br>SMTP：提供了电子邮件报文的传输<br>FTP：提供里两个端系统之间的文件传送<br>应用层中的信息分组称为<strong>报文</strong></p>
<p>运输层协议：<br>TCP：向它的应用程序提供了面向连接的服务。确保传递和流量控制，拥塞控制。<br>UDP：向它的应用程序提供无连接的服务。无可靠性、无流量控制和拥塞控制。<br>运输层中的信息分组称为<strong>报文段</strong></p>
<p>网络层协议：<br>IP协议<br>路由选择协议<br>网络层中的信息分组称为<strong>数据报</strong></p>
<p>链路层中的信息分组称为<strong>帧</strong></p>
<p>物理层中的信息分组称为<strong>比特</strong></p>
<hr>
<p><strong>OSI参考模型</strong><br>OSI参考模型中的七层是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。<br>表示层的作用是使通信的应用程序能够解释交换数据的含义。<br>会话层提供了数据交换定界和同步功能。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-note2]]></title>
      <url>/2018/03/12/python-note2/</url>
      <content type="html"><![CDATA[<p>-基本知识<br>-条件语句</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>if语句</strong><br>if语句用于检查语句<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例</span></div><div class="line">number=<span class="number">23</span></div><div class="line">guess = <span class="keyword">int</span> (<span class="keyword">input</span>(<span class="string">'Enter an integer:'</span>))</div><div class="line"></div><div class="line"><span class="keyword">if</span> guess==number:</div><div class="line">	<span class="meta">#新块开始</span></div><div class="line">	<span class="keyword">print</span>(<span class="string">'yes ,you guess it'</span>)</div><div class="line">	<span class="keyword">print</span>(<span class="string">'...'</span>)</div><div class="line">	<span class="meta">#新块结束</span></div><div class="line">elif guess&lt;number:</div><div class="line">	<span class="keyword">print</span>(<span class="string">'1'</span>)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	<span class="keyword">print</span>(<span class="string">'no'</span>)</div></pre></td></tr></table></figure></p>
<p>与C/C++不同的是，python的if选择语句不在使用括号，而在语句结尾添加：<br>while语句也是如此，就不再赘述</p>
<hr>
<p><strong>for循环</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">case</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">1</span>,<span class="number">5</span>):</div><div class="line">	print(i)</div><div class="line"><span class="keyword">else</span>:</div><div class="line">	print(<span class="symbol">'The</span> <span class="keyword">for</span> <span class="keyword">loop</span> <span class="keyword">is</span> over')</div><div class="line">#output</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div><div class="line">The <span class="keyword">for</span> <span class="keyword">loop</span> <span class="keyword">is</span> over</div></pre></td></tr></table></figure></p>
<p>range(1,5)输出序列【1,2,3,4】<br>如果向range函数提供三个参数，range(1,5,2)输出序列【1，3】<br>第三个参数是作为递增的间隔。</p>
<p>break和continue与C/C++中无异</p>
<hr>
<p><strong>函数</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//范例</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">()</span>:</span></div><div class="line"><span class="comment">#该块属于这一函数</span></div><div class="line">	print(<span class="string">'hello world'</span>)</div><div class="line"><span class="comment">#函数结束</span></div><div class="line">	say_hello()</div><div class="line">	say_hello()</div></pre></td></tr></table></figure></p>
<p>添加参数的函数与C/C++中无异</p>
<hr>
<p><strong>global语句</strong><br>如果要在函数中改变全局变量，需要用到global关键字，将其声明为并非局部变量。<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">x</span>=<span class="number">50</span></div><div class="line"></div><div class="line">def func():</div><div class="line">	<span class="keyword">global</span> <span class="keyword">x</span></div><div class="line">	print('<span class="keyword">x</span> is',<span class="keyword">x</span>)</div><div class="line">	<span class="keyword">x</span>=<span class="number">2</span></div><div class="line">	print('changed <span class="keyword">global</span> <span class="keyword">x</span> <span class="keyword">to</span>',<span class="keyword">x</span>)</div><div class="line">	func()</div><div class="line">	print('value of <span class="keyword">x</span> is',<span class="keyword">x</span>)</div></pre></td></tr></table></figure></p>
<hr>
<p>默认参数值与C++相同</p>
<hr>
<p><strong>条件语句的开始与结束</strong><br>python的块是由缩进来决定的。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#缩进决定条件语句的开始与结束</span></div><div class="line"><span class="built_in">number</span> = <span class="number">23</span></div><div class="line">guess int(input('Enter a <span class="built_in">integer</span>: '))</div><div class="line"><span class="keyword">if</span> <span class="built_in">number</span>==guess:</div><div class="line">	print('<span class="number">1</span><span class="string">")</span></div><div class="line"><span class="string">	print("</span><span class="number">2</span><span class="string">")</span></div></pre></td></tr></table></figure></p>
<p>什么意思呢？就是说python的条件语句的开始与结束是缩进决定的。开始缩进则进入，结束缩进则退出。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[电路交换与分组交换]]></title>
      <url>/2018/03/12/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E4%B8%8E%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>-区别三种交换技术</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>电路交换</strong><br>由于电路交换在通信之前要在通信双方之间建立一条被双方独占的物理通路（由通信双方之间的交换设备和链路逐段连接而成），因而有以下优缺点。<br>  优点：<br>  ①由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。<br>  ②通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强。<br>  ③双方通信时按发送顺序传送数据，不存在失序问题。<br>  ④电路交换既适用于传输模拟信号，也适用于传输数字信号。<br>  ⑤电路交换的交换的交换设备（交换机等）及控制均较简单。<br>  缺点：<br>  ①电路交换的平均连接建立时间对计算机通信来说嫌长。<br>  ②电路交换连接建立后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用低。</p>
<h2 id="③电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。"><a href="#③电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。" class="headerlink" title="  ③电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。"></a>  ③电路交换时，数据直达，不同类型、不同规格、不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制。</h2><p><strong>报文交换</strong><br>报文交换是以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换结点采用存储转发的传输方式，因而有以下优缺点：<br>  优点：<br>  ①报文交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送报文。<br>  ②由于采用存储转发的传输方式，使之具有下列优点：a.在报文交换中便于设置代码检验和数据重发设施，加之交换结点还具有路径选择，就可以做到某条传输路径发生故障时，重新选择另一条路径传输数据，提高了传输的可靠性；b.在存储转发中容易实现代码转换和速率匹配，甚至收发双方可以不同时处于可用状态。这样就便于类型、规格和速度不同的计算机之间进行通信；c.提供多目标服务，即一个报文可以同时发送到多个目的地址，这在电路交换中是很难实现的；d.允许建立数据传输的优先级，使优先级高的报文优先转换。<br>  ③通信双方不是固定占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率。<br>  缺点：<br>  ①由于数据进入交换结点后要经历存储、转发这一过程，从而引起转发时延（包括接收报文、检验正确性、排队、发送时间等），而且网络的通信量愈大，造成的时延就愈大，因此报文交换的实时性差，不适合传送实时或交互式业务的数据。<br>  ②报文交换只适用于数字信号。<br>  ③由于报文长度没有限制，而每个中间结点都要完整地接收传来的整个报文，当输出线路不空闲时，还可能要存储几个完整报文等待转发，要求网络中每个结点有较大的缓冲区。为了降低成本，减少结点的缓冲存储器的容量，有时要把等待转发的报文存在磁盘上，进一步增加了传送时延。</p>
<hr>
<p>  <strong>分组交换</strong><br>  分组交换仍采用存储转发传输方式，但将一个长报文先分割为若干个较短的分组，然后把这些分组（携带源、目的地址和编号信息）逐个地发送出去，因此分组交换除了具有报文的优点外，与报文交换相比有以下优缺点：<br>  优点：<br>  ①加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了报文的传输时间。此外，传输一个分组所需的缓冲区比传输一份报文所需的缓冲区小得多，这样因缓冲区不足而等待发送的机率及等待的时间也必然少得多。<br>  ②简化了存储管理。因为分组的长度固定，相应的缓冲区的大小也固定，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。<br>  ③减少了出错机率和重发数据量。因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。<br>  ④由于分组短小，更适用于采用优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适些。<br>  缺点：<br>  ①尽管分组交换比报文交换的传输时延少，但仍存在存储转发时延，而且其结点交换机必须具有更强的处理能力。<br>  ②分组交换与报文交换一样，每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约增大5%～10%，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。<br>  ③当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。若采用虚电路服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</p>
<hr>
<p>  总之，若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</p>
<hr>
<p>更多请查看个人博客：https：//beatjerome.github.io</p>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1011题解]]></title>
      <url>/2018/03/04/PAT-A1011%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ol>
<li>World Cup Betting (20)</li>
</ol>
<p>时间限制<br>400 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>16000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets.</p>
<p>Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%.</p>
<p>For example, 3 games’ odds are given as the following:</p>
<p> W    T    L<br>1.1  2.5  1.7<br>1.2  3.0  1.6<br>4.1  1.2  1.1<br>To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1<em>3.0</em>2.5<em>65%-1)</em>2 = 37.98 yuans (accurate up to 2 decimal places).</p>
<p>Input</p>
<p>Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L.</p>
<p>Output</p>
<p>For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space.</p>
<p>Sample Input<br>1.1 2.5 1.7<br>1.2 3.0 1.6<br>4.1 1.2 1.1<br>Sample Output<br>T T W 37.98</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">char</span> s[<span class="number">3</span>]=&#123;<span class="string">'W'</span>,<span class="string">'T'</span>,<span class="string">'L'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">double</span> ans=<span class="number">1.0</span>,tem,a;</div><div class="line">	<span class="keyword">int</span> index;    <span class="comment">//记录最大的下标</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</div><div class="line">		tem=<span class="number">0.0</span>;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a);</div><div class="line">			<span class="keyword">if</span>(a&gt;tem)&#123;</div><div class="line">				tem=a;</div><div class="line">				index=j;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		ans*=tem;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"%c "</span>,s[index]);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%.2f"</span>,(ans*<span class="number">0.65</span><span class="number">-1</span>)*<span class="number">2</span>);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1028题解]]></title>
      <url>/2018/03/03/PAT-B1028%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-查找</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ol>
<li>人口普查(20)<br>时间限制<br>200 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>8000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</li>
</ol>
<p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>
<p>输入格式：</p>
<p>输入在第一行给出正整数N，取值在(0, 105]；随后N行，每行给出1个人的姓名（由不超过5个英文字母组成的字符串）、以及按“yyyy/mm/dd”（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>
<p>输出格式：</p>
<p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>
<p>输入样例：<br>5<br>John 2001/05/12<br>Tom 1814/09/06<br>Ann 2121/01/30<br>James 1814/09/05<br>Steve 1967/11/20<br>输出样例：<br>3 Tom John</p>
<hr>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">#include&lt;cstdio&gt;</div><div class="line">struct people&#123;</div><div class="line">	<span class="built_in">char</span> name[<span class="number">5</span>];</div><div class="line">	<span class="built_in">int</span> <span class="built_in">year</span>;  <span class="comment">//出生年份</span></div><div class="line">	<span class="built_in">int</span> <span class="built_in">month</span>; <span class="comment">//出生月份</span></div><div class="line">	<span class="built_in">int</span> <span class="built_in">day</span>;   <span class="comment">//出生日期 </span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">bool young(people a)&#123;   </div><div class="line"><span class="comment">//判断是否年轻过头 </span></div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>&gt;<span class="number">2014</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>==<span class="number">2014</span>&amp;&amp;a.<span class="built_in">month</span>&gt;<span class="number">9</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>==<span class="number">2014</span>&amp;&amp;a.<span class="built_in">month</span>==<span class="number">9</span>&amp;&amp;a.<span class="built_in">day</span>&gt;<span class="number">6</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool old(people b)&#123;    </div><div class="line"><span class="comment">//判断是否老过头 </span></div><div class="line">	<span class="keyword">if</span>(b.<span class="built_in">year</span>&lt;<span class="number">1814</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(b.<span class="built_in">year</span>==<span class="number">1814</span>&amp;&amp;b.<span class="built_in">month</span>&lt;<span class="number">9</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(b.<span class="built_in">year</span>==<span class="number">1814</span>&amp;&amp;b.<span class="built_in">month</span>==<span class="number">9</span>&amp;&amp;b.<span class="built_in">day</span>&lt;<span class="number">6</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">bool younger(people a,people b)&#123;</div><div class="line"><span class="comment">//判断ab中谁年轻 </span></div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>&gt;b.<span class="built_in">year</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>==b.<span class="built_in">year</span>&amp;&amp;a.<span class="built_in">month</span>&gt;b.<span class="built_in">month</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">if</span>(a.<span class="built_in">year</span>==b.<span class="built_in">year</span>&amp;&amp;a.<span class="built_in">month</span>==b.<span class="built_in">month</span>&amp;&amp;a.<span class="built_in">day</span>&gt;b.<span class="built_in">day</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">int</span> main()&#123;</div><div class="line">	<span class="built_in">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="built_in">int</span> n;</div><div class="line">	people a;</div><div class="line">	people oldest;</div><div class="line">	oldest.<span class="built_in">day</span>=<span class="number">6</span>;</div><div class="line">	oldest.<span class="built_in">month</span>=<span class="number">9</span>;</div><div class="line">	oldest.<span class="built_in">year</span>=<span class="number">2014</span>;</div><div class="line">	people youngest;</div><div class="line">	youngest.<span class="built_in">day</span>=<span class="number">0</span>;</div><div class="line">	youngest.<span class="built_in">month</span>=<span class="number">0</span>;</div><div class="line">	youngest.<span class="built_in">year</span>=<span class="number">0</span>; </div><div class="line">	scanf(<span class="string">"%d"</span>,&amp;n);</div><div class="line">	<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">		scanf(<span class="string">"%s %d/%d/%d"</span>,a.name,&amp;a.<span class="built_in">year</span>,&amp;a.<span class="built_in">month</span>,&amp;a.<span class="built_in">day</span>);</div><div class="line">		<span class="keyword">if</span>(young(a)==<span class="keyword">false</span>&amp;&amp;old(a)==<span class="keyword">false</span>)&#123;</div><div class="line">			count++;</div><div class="line">			<span class="keyword">if</span>(younger(a,oldest)==<span class="keyword">false</span>)</div><div class="line">				oldest=a;</div><div class="line">			<span class="keyword">if</span>(younger(a,youngest)==<span class="keyword">true</span>)</div><div class="line">				youngest=a;</div><div class="line">		&#125;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(count==<span class="number">0</span>)</div><div class="line">		printf(<span class="string">"0\n"</span>);</div><div class="line">	<span class="keyword">else</span></div><div class="line">		printf(<span class="string">"%d %s %s\n"</span>,count,oldest.name,youngest.name);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1041题解]]></title>
      <url>/2018/03/03/PAT-B1041%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-查找算法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><ol>
<li>考试座位号(15)<br>时间限制<br>400 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>8000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>每个PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</li>
</ol>
<p>输入格式：</p>
<p>输入第一行给出一个正整数N（&lt;=1000），随后N行，每行给出一个考生的信息：“准考证号 试机座位号 考试座位号”。其中准考证号由14位数字组成，座位从1到N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数M（&lt;=N），随后一行中给出M个待查询的试机座位号码，以空格分隔。</p>
<p>输出格式：</p>
<p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1个空格分隔。</p>
<p>输入样例：<br>4<br>10120150912233 2 4<br>10120150912119 4 1<br>10120150912126 1 3<br>10120150912002 3 2<br>2<br>3 4<br>输出样例：<br>10120150912002 2<br>10120150912119 1</p>
<hr>
<p>AC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const int maxn=1010;</div><div class="line">struct student&#123;</div><div class="line">	long long id;   //准考证号</div><div class="line">	int examseat;   //考试座位号 </div><div class="line">&#125;testseat[maxn];    //以试机座位号作为下标来记录考生</div><div class="line">int main()&#123;</div><div class="line">	int n,m,seat,examseat;</div><div class="line">	long long id;</div><div class="line">	scanf(&quot;%d&quot;,&amp;n);     //考生人数 </div><div class="line">	for(int i=0;i&lt;n;i++)&#123;</div><div class="line">		scanf(&quot;%lld %d %d&quot;,&amp;id,&amp;seat,&amp;examseat);</div><div class="line">		testseat[seat].id=id;</div><div class="line">		testseat[seat].examseat=examseat;</div><div class="line">	&#125;</div><div class="line">	scanf(&quot;%d&quot;,&amp;m);		//查询个数 </div><div class="line">	for(int i=0;i&lt;m;i++)&#123;</div><div class="line">		scanf(&quot;%d&quot;,&amp;seat);</div><div class="line">		printf(&quot;%lld %d\n&quot;,testseat[seat].id,testseat[seat].examseat);</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用这种存储方式，时间复杂度较低</p>
<hr>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1009题解]]></title>
      <url>/2018/03/03/PAT-A1009%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-多项式乘法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-A1009. Product of Polynomials (25)<br>时间限制<br>400 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>16000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>This time, you are supposed to find A*B where A and B are two polynomials.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>
<p>Output Specification:</p>
<p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place.</p>
<p>Sample Input<br>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5<br>Sample Output<br>3 3 3.6 2 6.0 1 1.6</p>
<hr>
<p>题目大意：读入格式与A1002相同，不过这里求的是多项式乘法</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">poly</span>&#123;</span></div><div class="line">	<span class="keyword">int</span> <span class="built_in">exp</span>; 		<span class="comment">//指数</span></div><div class="line">	<span class="keyword">double</span> cof; 	<span class="comment">//系数 </span></div><div class="line">&#125;poly[<span class="number">1010</span>];</div><div class="line"><span class="keyword">double</span> answer[<span class="number">2010</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> k,count=<span class="number">0</span>;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;poly[i].<span class="built_in">exp</span>,&amp;poly[i].cof);</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">		<span class="keyword">int</span> <span class="built_in">exp</span>;</div><div class="line">		<span class="keyword">double</span> cof;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;<span class="built_in">exp</span>,&amp;cof);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</div><div class="line">			answer[<span class="built_in">exp</span>+poly[j].<span class="built_in">exp</span>]+=cof*poly[j].cof;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(answer[i]!=<span class="number">0.0</span>)</div><div class="line">			count++;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">		<span class="keyword">if</span>(answer[i]!=<span class="number">0</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">" %d %0.1f"</span>,i,answer[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1002题解]]></title>
      <url>/2018/03/03/PAT-A1002%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-多项式加法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-A1002. A+B for Polynomials (25)<br>时间限制<br>400 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>16000 B<br>判题程序<br>Standard<br>作者<br>CHEN, Yue<br>This time, you are supposed to find A+B where A and B are two polynomials.</p>
<p>Input</p>
<p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000.</p>
<p>Output</p>
<p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<p>Sample Input<br>2 1 2.4 0 3.2<br>2 2 1.5 1 0.5<br>Sample Output<br>3 2 1.5 1 2.9 0 3.2</p>
<hr>
<p>题目大意：题目很简单，给你多项式项数，给出系数和幂次，进行两个多项式的求和</p>
<hr>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> max=<span class="number">1010</span>;</div><div class="line">	<span class="keyword">double</span> p[max]=&#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> k,n,count=<span class="number">0</span>;</div><div class="line">	<span class="keyword">double</span> a;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;n,&amp;a);</div><div class="line">		p[n]+=a;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %lf"</span>,&amp;n,&amp;a);</div><div class="line">		p[n]+=a;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max;i++)&#123;</div><div class="line">		<span class="keyword">if</span>(p[i]!=<span class="number">0</span>)</div><div class="line">			count++;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=max<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">		<span class="keyword">if</span>(p[i]!=<span class="number">0</span>)</div><div class="line">			<span class="built_in">printf</span>(<span class="string">" %d %0.1f"</span>,i,p[i]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1010题解]]></title>
      <url>/2018/03/02/PAT-B1010%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-B1010. 一元多项式求导 (25)<br>时间限制<br>400 ms<br>内存限制<br>65536 kB<br>代码长度限制<br>8000 B<br>判题程序<br>Standard<br>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）</p>
<p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p>
<p>输入样例：<br>3 4 -5 2 6 1 -2 0<br>输出样例：<br>12 3 -10 1 6 0</p>
<hr>
<p>参考：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> a[<span class="number">1010</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">int</span> k,e;</div><div class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k&gt;&gt;e)&#123;</div><div class="line">		a[e]=k;</div><div class="line">	&#125;</div><div class="line">	a[<span class="number">0</span>]=<span class="number">0</span>;   <span class="comment">//常数项求导得0</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</div><div class="line">		a[i<span class="number">-1</span>]=a[i]*i;</div><div class="line">		a[i]=<span class="number">0</span>;</div><div class="line">		<span class="keyword">if</span>(a[i<span class="number">-1</span>]!=<span class="number">0</span>)</div><div class="line">			count++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(count==<span class="number">0</span>)</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"0 0"</span>;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">			<span class="keyword">if</span>(a[i]!=<span class="number">0</span>)&#123;</div><div class="line">				<span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</div><div class="line">				count--;</div><div class="line">				<span class="keyword">if</span>(count!=<span class="number">0</span>)</div><div class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python-note1]]></title>
      <url>/2018/02/27/python-note1/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>开始hello world</strong><br>在python解释器提示符，输入<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"Hello world!"</span>)</span></span></div></pre></td></tr></table></figure></p>
<p>回车，屏幕上打印出Hello world！字样</p>
<hr>
<p><strong>注释</strong><br>注释是任何存在于#号右侧的文字</p>
<hr>
<p><strong>单引号</strong><br>可以使用单引号来指定字符串，例如’what is love’<br>所有引号内空间，包括空格与制表符，都将按原样保留。<br><strong>双引号</strong><br>被双引号包括的字符串和被单引号阔气的字符串的工作机制完全相同。<br><strong>三引号</strong><br>可以通过使用’’’来指定字符串。在三引号之间可以自由的使用单引号和双引号<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">'''</div><div class="line">one </div><div class="line">two</div><div class="line">there</div><div class="line">'''</div></pre></td></tr></table></figure></p>
<p><strong>与C/C++不一样的是，python的字符串是不可变的。一旦创造了一串字符串，就不能在改变了。</strong></p>
<hr>
<p><strong>format()方法</strong><br>format()方法可以使我们从其他信息中构建字符串。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#范例</span></div><div class="line"><span class="string">age=20</span></div><div class="line"><span class="string">name='james'</span></div><div class="line"><span class="string">print('&#123;0&#125;</span> <span class="string">was</span> <span class="string">&#123;1&#125;</span> <span class="string">years</span> <span class="string">old'.format(name,age))</span></div><div class="line"><span class="string">print('Why</span> <span class="string">is</span> <span class="string">&#123;0&#125;</span> <span class="string">playing</span> <span class="string">with</span> <span class="string">python')</span></div><div class="line"><span class="bullet">-</span><span class="meta">---</span></div><div class="line"><span class="string">输出：</span></div><div class="line"><span class="string">james</span> <span class="string">was</span> <span class="number">20</span> <span class="string">years</span> <span class="string">old</span></div><div class="line"><span class="string">Why</span> <span class="string">is</span> <span class="string">james</span> <span class="string">playing</span> <span class="string">with</span> <span class="string">python</span></div></pre></td></tr></table></figure></p>
<p>{0}对应的是变量name，它是该格式化方法中的第一个参数。<br>{1}对应的是变量age，它是该格式化方法中的第二个参数。<br>数字只是一个可选选项，不是必须的，因此可以略去中括号的数字。</p>
<p>python中的format方法所做的事情便是将每个参数替换至格式所在的位置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#format方法的详细格式</div><div class="line">#对于浮点数<span class="string">'0.333'</span>保留小数点后三位</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'&#123;0:.3f&#125;'</span>.format(<span class="number">1.0</span>/<span class="number">3</span>)</span></span></div><div class="line">#使用下划线填充，并保持文字处于中间位置</div><div class="line">#使用（^）定义字符串长度为<span class="number">11</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'&#123;0:_^11&#125;'</span>.format(<span class="string">'hello'</span>)</span></span></div><div class="line">#基于关键字的输出</div><div class="line"><span class="function"><span class="title">printf</span><span class="params">(<span class="string">'&#123;name&#125; wrote &#123;book&#125;'</span>.format(name=<span class="string">'James'</span>,book=<span class="string">'Essential python'</span>)</span></span>)</div><div class="line"><span class="comment">//以上代码输出</span></div><div class="line"><span class="number">0.333</span></div><div class="line">___hello___</div><div class="line">James wrote Essential python</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>换行</strong><br>print总是会以一个不可见的“新一行”字符（\n）结尾，因此重复调用print将会自动换行<br>为了防止这一现象的发生，可以通过end指定其应以空白结尾：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'a'</span>,end=<span class="string">''</span>)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'b'</span>,end=<span class="string">''</span>)</span></span></div><div class="line"><span class="comment">//输出结果</span></div><div class="line">ab</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'a'</span>,end=<span class="string">' '</span>)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'b'</span>,end=<span class="string">' '</span>)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">'c'</span>)</span></span></div><div class="line"><span class="comment">//输出结果</span></div><div class="line"><span class="selector-tag">a</span> <span class="selector-tag">b</span> c</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>转义序列</strong><br>如果希望生成包含单引号的字符串，不能指定“What’s your name?”，这会让python对于何处是字符串的开始和结束感到疑惑。因此，必须指定单引号不代表字符串的结尾。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#两种方式指定</span></div><div class="line">'What\'s your name?'</div><div class="line">"What's your name?<span class="string">"</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>标识符</strong><br>命名标识符时，需要遵循以下规则：<br>1.第一个字符必须是字母表中的字母或下划线<br>2.标识符的其他部分可以由字符、下划线、数字（0~9）组成。<br>3.标识符名称区分大小写</p>
<hr>
<p><strong>逻辑行与物理行</strong><br>物理行是指编写程序时所看到的内容。<br>逻辑行是Python所看到的单个语句。<br>如果要在一行物理行中指定多行逻辑行，必须通过分好（；）来明确表明逻辑行或语句的结束。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#逻辑等同的几个例子</span></div><div class="line"><span class="comment">#example 1</span></div><div class="line"><span class="attribute">i</span>=5</div><div class="line"><span class="builtin-name">print</span>(i)</div><div class="line"><span class="comment">#example 2</span></div><div class="line"><span class="attribute">i</span>=5;</div><div class="line"><span class="builtin-name">print</span>(i);</div><div class="line"><span class="comment">#example 3</span></div><div class="line"><span class="attribute">i</span>=5;print(i);</div><div class="line"><span class="comment">#example 4</span></div><div class="line"><span class="attribute">i</span>=5;print(i)</div></pre></td></tr></table></figure></p>
<p>事实上，一般来说不会使用分号。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Python programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-note5]]></title>
      <url>/2018/02/24/C++-note5/</url>
      <content type="html"><![CDATA[<p>-类继承<br>-string类</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>静态类成员</strong><br>在类声明中，可以声明static成员。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span></div><div class="line">	...</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="keyword">static</span> <span class="keyword">int</span> num;   <span class="comment">//在声明类后，该成员是静态的（假如创建了10个a对象</span></div><div class="line">						  <span class="comment">//它们的num成员值相同）</span></div><div class="line">		...</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，类的所有对象都共享同一个静态成员。</p>
<hr>
<p><strong>类继承</strong><br>类继承能够从已有的类派生出新的类，而派生类继承了原有类（基类）的特征，包括方法。<br>1.可以在已有类的基础上添加功能。<br>2.可以给类添加数据。<br>3.可以修改类方法的行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">rateplayer</span>:</span><span class="keyword">public</span> Table&#123;</div><div class="line">...  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>冒号指出rateplayer的基类是Table。public说明Table是一个公有基类，这成为公有派生。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。</p>
<blockquote>
<p>派生类特征<br>1.派生类对象存储了基类的额数据成员（派生类继承了基类的实现）；<br>2.派生类对象可以使用基类的方法；<br>3.派生类对象需要自己的构造函数；<br>4.派生类可以根据需要添加额外的数据成员和成员函数。</p>
</blockquote>
<hr>
<p><strong>string类</strong><br>使用string需要带头文件string.h<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span>(size_type n,<span class="built_in">char</span> c);   	//创建一个包含n个元素的<span class="built_in">string</span>对象，每个元素都初始化为字符c</div><div class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">string</span> &amp;str);     	//将一个<span class="built_in">string</span>对象初始化为<span class="built_in">string</span>对象str</div><div class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">char</span> *s);   		//将<span class="built_in">string</span>对象初始化为字符串s</div><div class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="built_in">char</span> *s,size_type n);   //将<span class="built_in">string</span>对象初始化为字符串s的前n个字符</div></pre></td></tr></table></figure></p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">string</span> <span class="literal">one</span>(<span class="string">"Jerome"</span>);   <span class="comment"> //将one初始化为jerome</span></div><div class="line"><span class="literal">one</span>+=<span class="string">"James"</span>;             <span class="comment"> //通过重载的+=将James加在对象one后面</span></div><div class="line"><span class="literal">one</span>[<span class="number">2</span>]=<span class="string">'p'</span>;                   <span class="comment"> //通过[]可以使用数组表示法来访问string对象中的各个字符</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>string输入</strong><br>对于string对象，有两种方式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> stuff;</div><div class="line"><span class="built_in">cin</span>&gt;&gt;stuff;            <span class="comment">//read a word;</span></div><div class="line">getline(<span class="built_in">cin</span>,stuff);    <span class="comment">//read a line,without a '\n'</span></div></pre></td></tr></table></figure></p>
<p>string的getline()将自动调整string对象的大小，使之刚好能够存储输入的字符<br>string对象的size()和length()成员函数都返回字符串中的字符数</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-note4]]></title>
      <url>/2018/02/23/C++-note4/</url>
      <content type="html"><![CDATA[<p>-类的使用<br>-运算符重载</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>运算符重载</strong><br>运算符重载是一种形式的C++多态。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重载范例</span></div><div class="line"><span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</div><div class="line">	a[i]=b[i]+<span class="built_in">c</span>[i];</div><div class="line"><span class="comment">//可以定义一个数组的类，重载+运算符</span></div><div class="line">a=b+<span class="built_in">c</span>;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重载运算符+号来计算时间总和</span></div><div class="line">Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time&amp;t) <span class="keyword">const</span>;     <span class="comment">//类定义中进行重载声明</span></div><div class="line">Time Time::<span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span> &#123;</div><div class="line">       ....</div><div class="line">  &#125;</div><div class="line"><span class="comment">//重载后，通过两种方法使用</span></div><div class="line">total=coding.opretaor+(fixing);</div><div class="line">total=coding+fixing;</div></pre></td></tr></table></figure>
<hr>
<p><strong>重载限制</strong><br>多数C++运算符可以用上述方式重载。<br>但C++对运算符重载还有以下的限制：<br>1.重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。<br>2.使用运算符时不能违反运算符原来的句法规则。<br>3.不能创建新的运算符<br>4.不能重载以下操作符：<br>sizeof：sizeof运算符<br>.：成员运算符<br>.*：成员指针运算符<br>::：作用域解析运算符<br>?:：条件运算符<br>typeid：RTTI运算符<br>const_cast：强制类型转换运算符<br>dynamic_cast：强制类型转换运算符<br>reinterpret_cast：强制类型转换运算符<br>static_cast：强制类型转换运算符<br>5.大多数运算符可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。<br>=：赋值运算符<br>()：函数调用运算符<br>[]：下标运算符<br>-&gt;：通过指针访问类成员的运算符</p>
<hr>
<p><strong>友元</strong><br>友元有三种：<br>1.友元函数<br>2.友元类<br>3.友元成员函数</p>
<p>友元函数可以访问类的私有成员（private部分）</p>
<p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend<br>该原型意味着两点：<br>1.虽然该函数是在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；<br>2.虽然该函数不是成员函数，但他与成员函数的访问权限相同。</p>
<p>创建友元函数的第二步是编写函数定义。<br>因为友元函数并不是类的成员函数，因此在编写友元函数定义时，不应使用作用域解析运算符（::）。其他部分与普通函数无异。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-note3]]></title>
      <url>/2018/02/22/C++-note3/</url>
      <content type="html"><![CDATA[<p>-类与对象</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>类与对象</strong></p>
<blockquote>
<p>一般来说，类规范由两个部分组成<br>1.类声明：以数据成员的方式描述数据部分。以成员函数（被称为方法）的方式描述公有接口<br>2.类方法定义：描述如何实现类成员函数<br>简单来说，类声明提供了类的蓝图，而方法定义则提供了细节</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCKOO_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCKOO_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span>&#123;</span></div><div class="line">	<span class="keyword">private</span>:</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">string</span> company;</div><div class="line">		<span class="keyword">long</span> shares;</div><div class="line">		<span class="keyword">double</span> share_val;</div><div class="line">		<span class="keyword">double</span> total_val;</div><div class="line">		<span class="keyword">void</span> set_tol&#123; total_val=shares*share_val; &#125;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">		<span class="keyword">void</span> acquire&#123;<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; co,<span class="keyword">long</span> n,<span class="keyword">double</span> pr&#125;;</div><div class="line">		<span class="keyword">void</span> buy&#123;<span class="keyword">long</span> num,<span class="keyword">double</span> price&#125;;</div><div class="line">		<span class="keyword">void</span> sell&#123;<span class="keyword">long</span> num,<span class="keyword">double</span> price&#125;;</div><div class="line">		<span class="keyword">void</span> update&#123;<span class="keyword">double</span> price&#125;;</div><div class="line">		<span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>·关键字class指出了这些代码定义了一个类设计</p>
<hr>
<p><strong>访问控制</strong><br>关键字private和public描述了对类成员的访问控制。<br>使用类对象的程序都可以直接访问public部分。而对于private部分，只能通过公有成员函数（或友元函数）来访问。</p>
<blockquote>
<p>将实现细节放在一起并将它们与抽象分开被称为封装</p>
</blockquote>
<p>不必在类声明中使用关键字private，这是类对象的默认访问控制。也就是说，只需要声明哪些部分是public的即可。</p>
<hr>
<p><strong>类成员函数的实现</strong><br>除了类声明之外，还需要创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，<br>但是，他们有两个特殊的地方：<br>1.定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类<br>2.类方法可以访问类的private组件</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用对象的成员函数</span></div><div class="line">Stock kate ,joe ;</div><div class="line">kate.<span class="keyword">show</span>();</div><div class="line">joe.<span class="keyword">show</span>();</div></pre></td></tr></table></figure>
<hr>
<p><strong>小结</strong><br>指定类设计的第一步是提供类声明。类声明类似结构声明，可以包括数据成员和函数成员。声明私有部分，其中声明的成员只能通过成员函数进行访问；声明公有部分，在其中声明的成员可被使用类对象的程序直接访问。<strong>通常来说，数据成员被放在私有部分，成员函数放在公有部分</strong>。<br>指定类设计的第二部是实现类成员函数。可以在类声明中提供完整的函数定义，而不是函数原型，但通常是单独提供函数定义（除非函数很简单）。</p>
<hr>
<p><strong>构造函数</strong><br>C++提供了两种使用构造函数来初始化对象的方式<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//first</span></div><div class="line">Stock food=Stock(<span class="string">"World cabbage"</span>,<span class="number">250</span>,<span class="number">1.25</span>);</div><div class="line"><span class="comment">//second</span></div><div class="line">Stock food(<span class="string">"World cabbage"</span>,<span class="number">250</span>,<span class="number">1.25</span>);</div></pre></td></tr></table></figure></p>
<p>默认构造函数是在未提供显示初始值时，用来创建对象的构造函数。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例</span></div><div class="line">Stock fluffy_the_cat;</div></pre></td></tr></table></figure></p>
<p>当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。</p>
<blockquote>
<p>定义默认构造函数的方式有两种<br>其一是给已有构造函数的所有参数提供默认值<br>其二是通过函数重载来定义另一个构造函数</p>
</blockquote>
<p>使用上述任何一种方法，创建了默认构造函数后，便可以声明对象变量而不对他们进行显式初始化。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock <span class="keyword">first</span>；</div><div class="line">Stock <span class="keyword">first</span>=Stock();</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>析构函数</strong></p>
<p>析构函数完成的是清理操作。如果构造函数使用new来分配内存，则西沟函数将使用delete来释放这些内存。<strong>析构函数名称：在类名前加上~，如Stock类的析构函数为~Stock()</strong>。和构造函数一样，析构函数也可以没有返回值和声明类型。</p>
<blockquote>
<p>与构造函数不同的是，析构函数没有参数。</p>
</blockquote>
<hr>
<p><strong>列表初始化</strong><br>可以将列表初始化语法用于类,只要保证参数一一对应即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stock::Stock（<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; co,<span class="keyword">long</span> n=<span class="number">0</span>,<span class="keyword">double</span> pr=<span class="number">0.0</span>);</div><div class="line">Stock jock&#123;<span class="string">"Hello world"</span>,<span class="number">10000</span>,<span class="number">520.1314</span>);</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>const成员函数</strong><br>const成员函数保证函数不会修改调用对象。C++定义const成员函数是将const放在函数的括号后面。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="comment">//如此以来，保证显示类中数据时不会修改调用</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong><font color="#0000FF">构造函数与析构函数小结</font></strong><br>1.构造函数时一种特殊的类成员函数，在创建类对象时被调用。构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数。另外，构造函数没有声明类型。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化范例1（2参数）</span></div><div class="line">Bozo(<span class="keyword">const</span> <span class="keyword">char</span> *fname,<span class="keyword">const</span> <span class="keyword">char</span> *lname);    <span class="comment">//构造函数原型</span></div><div class="line">Bozo Fufu=&#123;<span class="string">"Fufu"</span>,<span class="string">"James"</span>);         <span class="comment">//初始化方法1</span></div><div class="line">Bozo Jerome&#123;<span class="string">"Jerome"</span>,<span class="string">"James"</span>);      <span class="comment">//初始化方法2</span></div><div class="line">Bozo *pc=<span class="keyword">new</span> Bozo(<span class="string">"popo"</span>,<span class="string">"Le Peu"</span>); <span class="comment">//初始化方法3</span></div></pre></td></tr></table></figure></p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化范例2（1参数）</span></div><div class="line">Bozo<span class="comment">(int n)</span>;    <span class="comment">//构造函数原型</span></div><div class="line">Bozo a=Bozo<span class="comment">(40)</span>;<span class="comment">//初始化方法1</span></div><div class="line">Bozo room<span class="comment">(60)</span>;  <span class="comment">//初始化方法2</span></div><div class="line">Bozo tubby=<span class="number">32</span>;  <span class="comment">//初始化方法3（可关闭，可能会带来意外）</span></div></pre></td></tr></table></figure>
<p>2.默认构造函数没有参数，因此如果创建对象时没有进行显式地初始化，则调用默认构造函数。如果程序中没有提供任何构造函数，则编译器回味程序定义一个默认构造函数；否则必须自己提供默认构造函数。默认构造函数可以没有任何参数。但是一旦有参数，必须给参数附上默认值。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Bozo();</span></div><div class="line"><span class="keyword">Bistro(const </span>char *s=<span class="string">"Chez Zero"</span>)<span class="comment">;</span></div><div class="line">//对于未被初始化的对象，程序将使用默认构造函数来创建：</div><div class="line"><span class="keyword">Bozo </span><span class="keyword">bubi;</span></div><div class="line"><span class="keyword">Bozo </span>*pb<span class="symbol">=new</span> <span class="keyword">Bozo;</span></div></pre></td></tr></table></figure></p>
<p>3.当对象被删除时，程序将调用析构函数。每个类都只能有一个析构函数。析构函数没有返回类型，也没有参数。其名称为类名称前加上~。</p>
<hr>
<p><strong>类作用域</strong><br>在类中定义的名称的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。因此，可以在不同的类中使用相同的类成员名而不会引起冲突。此外，类作用域意味着不能从外部直接访问类的成员。要访问类的成员，必须通过对象。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Stock <span class="built_in">sleep</span>(<span class="string">"Jerome"</span>,<span class="number">100</span>,<span class="number">0.25</span>);</div><div class="line"><span class="built_in">sleep</span>.<span class="keyword">show</span>();</div><div class="line"><span class="keyword">show</span>();     <span class="comment">//invalid</span></div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-note2]]></title>
      <url>/2018/02/21/C++-note2/</url>
      <content type="html"><![CDATA[<p>-动态存储分配<br>-名称空间</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>单独编译</strong></p>
<blockquote>
<p>一般来说，会把程序分为三部分：<br>头文件：包含结构声明和使用这些结构的函数的原型<br>源代码文件：包含于结构有关的函数的代码<br>源代码文件：包含调用与结构相关的函数的代码</p>
</blockquote>
<p>使用自己编写的编写的头文件使用“ ”而不再使用&lt;&gt;.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件的编写</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HEAD_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_H_</span></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>自动存储持续性</strong><br>在默认的情况下，函数声明的函数参数和变量的存储持续性为自动，作用于为局部，没有链接性。当程序开始执行这些变量所属的代码块时，将为其分配内存。当函数结束时，这些变量都将消失。</p>
<blockquote>
<p>如果在代码块中定义了变量，则该变量的存在时间和作用于将被限制在该代码块内</p>
</blockquote>
<p>如果存在两个同名的变量，其中一个位于外部代码块中，而另一个位于内部代码块中。在这种情况下，程序执行内部代码块中的语句时，解释为内部代码块变量。</p>
<p>一般程序使用栈来管理自动变量。</p>
<hr>
<p><strong>静态持续变量</strong><br>编译器分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//要创建链接性为外部的静态持续变量，必须在代码块外面声明它</span></div><div class="line"><span class="comment">//要创建链接性为内部的静态持续变量，必须在代码块外面声明并且加上static修饰</span></div><div class="line"><span class="comment">//要创建没有链接性的静态持续变量，必须在代码块内部声明它并且加上static修饰</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">global</span>=<span class="number">1000</span>;             <span class="comment">//链接性为外部的静态持续变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> one_file=<span class="number">50</span>;      <span class="comment">//链接性为内部的静态持续变量</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funct1</span>(<span class="params"><span class="keyword">int</span> n</span>)</span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;       <span class="comment">//没有链接性的静态持续变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果要在多个文件中使用外部变量，只需在一个文件包含该变量的定义，但在使用该变量的其他所有文件中都必须使用关键字extern声明它<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//file1.cpp</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> cats=<span class="number">20</span>;</div><div class="line"><span class="keyword">int</span> dogs=<span class="number">22</span>;</div><div class="line">...</div><div class="line"><span class="comment">//file2.cpp</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> cats;</div><div class="line">...</div><div class="line"><span class="comment">//file3.cpp</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> cats;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> dogs;</div></pre></td></tr></table></figure></p>
<p>如果在extern外部变量后，又声明了同名的变量，则本地使用的为本地声明的变量，加上：：作用域解析运算符后则是变量的全局版本。</p>
<hr>
<p>mutable可以用于指出，结构变量为const的情况下，其成员也可以被修改<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></div><div class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</div><div class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> data p;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>动态存储分配</strong><br>1.new的初始化<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化用于单值变量</span></div><div class="line"><span class="keyword">int</span> *pin=<span class="keyword">new</span> <span class="keyword">int</span> &#123;<span class="number">6</span>&#125;;</div><div class="line"><span class="keyword">double</span> *pdo=<span class="keyword">new</span> <span class="keyword">double</span> &#123;<span class="number">99.99</span>&#125;;</div><div class="line"><span class="comment">//初始化常规结构或数组需要用大括号的列表初始化</span></div><div class="line"><span class="keyword">struct</span> <span class="keyword">where</span> &#123;<span class="keyword">double</span> x,<span class="keyword">double</span> y,<span class="keyword">double</span> z&#125;;</div><div class="line"><span class="keyword">where</span> *one = <span class="keyword">new</span> <span class="keyword">where</span>&#123;<span class="number">2.5</span>,<span class="number">5.3</span>,<span class="number">7.2</span>&#125;;</div><div class="line"><span class="keyword">int</span> *ar=<span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">4</span>] &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>new运算符还有一种变体，被称为定位new运算符<br>要使用这种特性，需要包含new头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;new&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chaff</span>&#123;</span></div><div class="line">	<span class="keyword">char</span> dross[<span class="number">20</span>];</div><div class="line">	<span class="keyword">int</span> slag;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">char</span> buffer1[<span class="number">50</span>];</div><div class="line"><span class="keyword">char</span> buffer2[<span class="number">500</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	chaff *p1,*p2;</div><div class="line">	<span class="keyword">int</span> *p3,*p4;</div><div class="line">	p1=<span class="keyword">new</span> chaff;       <span class="comment">//在堆中分配</span></div><div class="line">	p3=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];     <span class="comment">//在堆中分配</span></div><div class="line">	p2=<span class="keyword">new</span> (buffer1)chaff;    <span class="comment">//在buffer1中分配</span></div><div class="line">	p4=<span class="keyword">new</span> (buffer2)<span class="keyword">int</span> [<span class="number">20</span>]； <span class="comment">//在buffer2中分配</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//这段程序就实现了定位分配内存的功能...</span></div><div class="line"><span class="comment">//定位new分配的内存不能直接使用delete来释放</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>名称空间</strong><br>C++新增了一种功能，即通过定义一种发明的区域来创建命名的名称空间。这样做的目的之一是提供一个声明名称的区域。一个名称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">namespace <span class="type">Jack</span>&#123;</div><div class="line">	double pail;</div><div class="line">	<span class="built_in">void</span> fetch();</div><div class="line">	<span class="built_in">int</span> pal;</div><div class="line">	struct well<span class="meta">&#123;...&#125;</span>;</div><div class="line">&#125;</div><div class="line">namespace <span class="type">Jill</span>&#123;</div><div class="line">	double bucket(double n)<span class="meta">&#123;...&#125;</span></div><div class="line">	double fetch;</div><div class="line">	<span class="built_in">int</span> pal;</div><div class="line">	struct <span class="type">Hill</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>1.名称空间可以是全局的，也可以位于另一个名称空间中，但不能代码块中<br>2.因此，在默认情况下，名称空间中声明的名称的链接性为外部的<br>3.任何名称空间中的名称都不会与其他名称空间中的名称冲突<br>4.名称空间是开放的，即可以把名称加入到已有的名称空间中</p>
</blockquote>
<p>当然需要一种方法来访问给定名称空间的名称。最简单的方法就是通过作用域解析运算符：：，使用名称空间来限定该名称；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Jack::pail=<span class="number">12.34</span>;</div><div class="line">Jill::Hill mole;</div><div class="line">Jack::fetch();</div></pre></td></tr></table></figure></p>
<p> 而如果我们不希望每次使用名称都对它进行限定。using声明使特定的标识符可用，using编译指令使整个名称空间可用。<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> Jill::fetch;    <span class="comment">//using声明</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jack;       <span class="comment">//using编译指令</span></div></pre></td></tr></table></figure></p>
<p> 如果两个名称空间中有相同的成员pal，不能通过using声明限定它们<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//错误示范</span></div><div class="line"><span class="keyword">using</span> jack::pal;</div><div class="line"><span class="keyword">using</span> jill::pal;</div><div class="line">pal=<span class="number">4</span>;    <span class="comment">//conflict</span></div></pre></td></tr></table></figure></p>
<p> 同样的，如果某个名称已经在函数中生命了，则不能用using声明导入相同的名称。<br> 如果有局部声明，将隐藏全局变量和名称空间的名称。</p>
<blockquote>
<p>局部变量声明后直接用<br>全局变量如果未有重名局部变量，可直接使用，否则要使用作用域解析运算符<br>名称空间例如jill::name来用，如果未有全局变量和局部变量重名的声明，在using声明或者using编译指令后可直接使用。</p>
</blockquote>
<p>客观来说，使用using声明比使用using编译指令更安全，它只导入指定的名称。</p>
<blockquote>
<p>补充，可以将名称空间声明进行嵌套。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> <span class="title">elements</span>&#123;</div><div class="line">	<span class="keyword">float</span> water;</div><div class="line">	<span class="keyword">namespace</span> <span class="title">fire</span>&#123;</div><div class="line">		<span class="keyword">int</span> flame;</div><div class="line">		..</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>因此这里的flame就是element::fire::flame.<br>同样，可以使用下面的usiang编译指令使内部的名称可用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> namspace elements::fire；</div></pre></td></tr></table></figure></p>
<blockquote>
<p>此外也可以在名称空间中使用using声明和using编译指令<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">nampspace myth&#123;</div><div class="line">	<span class="keyword">using</span> Jill::fetch;</div><div class="line">	<span class="keyword">using</span> nampspace elements;</div><div class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line">	<span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>此后，由于Jill::fetch现在位于名称空间myth，因此要访问fetch<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;myth::fetch;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以通过省略名称空间的名称来创建未命名的名称空间<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span>&#123;</div><div class="line">	<span class="keyword">int</span> ice;</div><div class="line">	<span class="keyword">int</span> bandycoot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这就像后面跟着using编译指令一样，也就是说在该名称空间中声明的潜在作用域为：从声明点到该声明区域末尾。由于这种名称空间没有名称，因此不能显式地使用using编译指令或using声明来使它在其他位置都可用。具体而言，就是不能在未命名名称空间所属文件之外的其他文件中使用该名称空间中的名称。</p>
<hr>
<p><strong>名称空间的指导原则</strong></p>
<blockquote>
<p>1.使用在已命名的名称空间中声明的变量，而不是使用外部全局变量<br>2.使用在已命名的名称空间中声明的变量，而不是使用静态全局变量<br>3.如果开发了一个函数库或类库，将其放在一个名称空间中。<br>4.不要在头文件中使用using编译指令。因为这样做掩盖了要让哪些名称可用。<br>5.导入名称时，首选使用作用域解析运算符或using声明的方法。<br>6.对于using声明，首选将其作用域设置为局部而不是全局。</p>
</blockquote>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[POJ-1002题解]]></title>
      <url>/2018/02/20/POJ1002%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>487-3279<br>Time Limit: 2000MS        Memory Limit: 65536K<br>Total Submissions: 294236        Accepted: 52703</p>
<p>Description<br>企业喜欢用容易被记住的电话号码。让电话号码容易被记住的一个办法是将它写成一个容易记住的单词或者短语。例如，你需要给滑铁卢大学打电话时，可以拨打TUT-GLOP。有时，只将电话号码中部分数字拼写成单词。当你晚上回到酒店，可以通过拨打310-GINO来向Gino’s订一份pizza。让电话号码容易被记住的另一个办法是以一种好记的方式对号码的数字进行分组。通过拨打必胜客的“三个十”号码3-10-10-10，你可以从他们那里订pizza。</p>
<p>电话号码的标准格式是七位十进制数，并在第三、第四位数字之间有一个连接符。电话拨号盘提供了从字母到数字的映射，映射关系如下：<br>A, B, 和C 映射到 2<br>D, E, 和F 映射到 3<br>G, H, 和I 映射到 4<br>J, K, 和L 映射到 5<br>M, N, 和O 映射到 6<br>P, R, 和S 映射到 7<br>T, U, 和V 映射到 8<br>W, X, 和Y 映射到 9</p>
<p>Q和Z没有映射到任何数字，连字符不需要拨号，可以任意添加和删除。 TUT-GLOP的标准格式是888-4567，310-GINO的标准格式是310-4466，3-10-10-10的标准格式是310-1010。</p>
<p>如果两个号码有相同的标准格式，那么他们就是等同的（相同的拨号）</p>
<p>你的公司正在为本地的公司编写一个电话号码薄。作为质量控制的一部分，你想要检查是否有两个和多个公司拥有相同的电话号码。</p>
<p>Input<br>输入的格式是，第一行是一个正整数，指定电话号码薄中号码的数量（最多100000）。余下的每行是一个电话号码。每个电话号码由数字，大写字母（除了Q和Z）以及连接符组成。每个电话号码中只会刚好有7个数字或者字母。</p>
<p>Output<br>对于每个出现重复的号码产生一行输出，输出是号码的标准格式紧跟一个空格然后是它的重复次数。如果存在多个重复的号码，则按照号码的字典升序输出。如果输入数据中没有重复的号码，输出一行：<br>No duplicates.</p>
<p>Sample Input</p>
<p>12<br>4873279<br>ITS-EASY<br>888-4567<br>3-10-10-10<br>888-GLOP<br>TUT-GLOP<br>967-11-11<br>310-GINO<br>F101010<br>888-1200<br>-4-8-7-3-2-7-9-<br>487-3279</p>
<p>Sample Output</p>
<p>310-1010 2<br>487-3279 4<br>888-4567 3</p>
<p>注意点：数组不能开小了。</p>
<p>AC代码（C语言）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNCODE(a) (a&gt;=<span class="meta-string">'A'</span>?((a&gt;<span class="meta-string">'Q'</span>?(a-<span class="meta-string">'A'</span>-1):(a-<span class="meta-string">'A'</span>))/3+2):a-<span class="meta-string">'0'</span>)  </span></div><div class="line"><span class="comment">//#define DEBUG  </span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">uncode</span><span class="params">(<span class="keyword">char</span>* s)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);i++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'-'</span>) <span class="keyword">continue</span>;  </div><div class="line">        result=result*<span class="number">10</span>+UNCODE(s[i]);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> result;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a-*(<span class="keyword">int</span>*)b;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG  </span></div><div class="line">        freopen(<span class="string">"data.dat"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);  </div><div class="line">        <span class="comment">//freopen("out.dat","w",stdout);  </span></div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line">    <span class="keyword">int</span>* store;  </div><div class="line">    <span class="keyword">char</span> s[<span class="number">50</span>];  </div><div class="line">    <span class="keyword">int</span> time;  </div><div class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    <span class="keyword">int</span> start,value;  </div><div class="line">    <span class="keyword">int</span> dup=<span class="number">0</span>;  </div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;time);  </div><div class="line">    store=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(time));  </div><div class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;time;n++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);  </div><div class="line">        store[n]=uncode(s);  </div><div class="line">    &#125;  </div><div class="line">    qsort(store,time,<span class="keyword">sizeof</span>(store[<span class="number">0</span>]),cmp);  </div><div class="line">    value=store[<span class="number">0</span>];  </div><div class="line">    start=<span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;time;n++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">if</span>(store[n]!=value)&#123;   </div><div class="line">            <span class="keyword">if</span>((n-start)&gt;<span class="number">1</span>)&#123;   </div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,store[start]/<span class="number">10000</span>,store[start]%<span class="number">10000</span>,n-start);  </div><div class="line">                dup=<span class="number">1</span>;  </div><div class="line">            &#125;  </div><div class="line">            start=n;  </div><div class="line">            value=store[n];  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span>((n-start)&gt;<span class="number">1</span>)&#123;   </div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,store[start]/<span class="number">10000</span>,store[start]%<span class="number">10000</span>,n-start);  </div><div class="line">                dup=<span class="number">1</span>;  </div><div class="line">            &#125;  </div><div class="line">    <span class="keyword">if</span>(!dup)  </div><div class="line">    &#123;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"No duplicates.\n"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="built_in">free</span>(store);  </div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> POJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++-note1]]></title>
      <url>/2018/02/20/C++-note1/</url>
      <content type="html"><![CDATA[<p>-C++函数部分</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>字符函数库cctype</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">isalnum</span>（）   判断是否是字母或数字</div><div class="line"><span class="built_in">isalpha</span>（）   判断是否是字母</div><div class="line"><span class="built_in">isdigit</span>（）   判断是否是数字</div><div class="line"><span class="built_in">ispunct</span>（）	判断是否是标点符号</div><div class="line"><span class="built_in">isspace</span>（）	判断是否是空格</div><div class="line"><span class="built_in">isupper</span>（） 	判断是否是大写字母</div><div class="line"><span class="built_in">islower</span>（）	判断是否是小写字母</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>写入文本</strong></p>
<blockquote>
<p>1.包含头文件fstream<br>2.创建一个ofstream对象<br>3.将该ofstream对象同一个文件关联起来<br>4.如使用cout一般使用该对象<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例程序</span></div><div class="line"><span class="comment">//在目录下创建名为Hello world.txt的文件</span></div><div class="line"><span class="comment">//写入内容</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	ofstream outFile;</div><div class="line">	outFile.open(<span class="string">"Hello world.txt"</span>);</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello world"</span>;</div><div class="line">	outFile&lt;&lt;<span class="string">"Hello world"</span>;</div><div class="line">	outFile.close();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这只是简单的输出文本。如果原本的输出文本已有内容，这种输出方式会将文本内容清空后重新写入。</p>
<hr>
<p><strong>读取文本</strong></p>
<blockquote>
<p>1.包含fstream头文件<br>2.创建一个ifstream对象<br>3.将该对象和文件关联起来<br>4.结合ifstream对象和运算符&gt;&gt;读取各种数据<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例程序</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	ifstream inFile;</div><div class="line">	inFile.open(<span class="string">"Hello world.txt"</span>);</div><div class="line">	<span class="keyword">while</span>(inFile.good())&#123;</div><div class="line">		<span class="keyword">char</span> ch;</div><div class="line">		inFile&gt;&gt;ch;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;ch;</div><div class="line">	&#125;</div><div class="line">	inFile.close();</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<hr>
<p><strong>默认参数</strong><br>默认参数指的是当函数调用中省略了实参时自动使用的一个值。它提供了一种便捷的方式。在设计类时，通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果希望使用默认参数，即给函数参数一个默认值</span></div><div class="line"><span class="comment">//将参数n的默认值设为1</span></div><div class="line"><span class="function"><span class="keyword">const</span> *<span class="title">left</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str,<span class="keyword">int</span> n=<span class="number">1</span>)</span></span>;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>函数重载</strong></p>
<blockquote>
<p>默认参数可以使用不同数目的参数调用同一个函数。<br>而相对的，函数重载（函数多态）可以使用多个同名的函数。</p>
</blockquote>
<p>函数重载的关键是函数的参数列表—也称为函数特征标。C++允许定义名称相同的函数，条件是它们的特征标不同。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//范例print函数</span></div><div class="line"><span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span>,<span class="built_in">int</span> <span class="built_in">width</span>);</div><div class="line"><span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">double</span> d,<span class="built_in">int</span> <span class="built_in">width</span>);</div><div class="line"><span class="keyword">void</span> <span class="built_in">print</span>(longl,<span class="built_in">int</span> <span class="built_in">width</span>);</div><div class="line"><span class="keyword">void</span> <span class="built_in">print</span>(<span class="built_in">int</span> i,<span class="built_in">int</span> <span class="built_in">width</span>);</div><div class="line"><span class="keyword">void</span> <span class="built_in">print</span>(<span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span>);</div></pre></td></tr></table></figure></p>
<p>如果调用的函数没有原型匹配。C++将尝试使用标准类型转换强制进行匹配。但如果有多个原型，则会拒绝这种调用，并将其视为错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只允许对函数参数区别进行函数重载</span></div><div class="line"><span class="comment">//不允许对函数类型区别进行函数重载</span></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> m)</span></span>;</div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">float</span> m)</span></span>;</div></pre></td></tr></table></figure>
<hr>
<p><strong>函数模板</strong><br>函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可以用具体的类型（int 和double）替换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//交换函数模板范例分析</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(AnyType &amp;a,AnyType &amp;b)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	AnyType temp;</div><div class="line">	temp=a;</div><div class="line">	a=b;</div><div class="line">	b=temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一行指出，要建立一个模板，并将类型命名为AnyType。关键字template和typename是必须的，但是class可以用来替换typename。</p>
<p>函数模板的意义在于，当你调用该函数，如该交换函数而言，如果你给的参数是int或者double，AnyType就会替换成所给的参数的类型。</p>
<blockquote>
<p>还有一点要注意的是，与C中相同，函数模板中也不需要所有的参数类型都需要用泛型.</p>
</blockquote>
<hr>
<p><strong>显式具体化</strong><br>显式具体化是对于模板而言的，即对于函数模板而言，有些类型的操作无法实现，需要specialize。简单的理解就是，写定一个函数模板后，通过显式具体化来拓宽模板的应用范围。</p>
<blockquote>
<p>具体化优先于常规模板<br>而非模板函数优先于具体化和常规模板</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//非模板函数、模板函数和显式具体化模板函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(job &amp;,job &amp;)</span></span>;    <span class="comment">//非模板函数</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;		<span class="comment">//模板函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;,T &amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;job&gt;(job &amp;,job&amp;);	<span class="comment">//显式具体化</span></div></pre></td></tr></table></figure>
<p>swap<job>中的<job>不是必须的，可写可不写</job></job></p>
<hr>
<p><em>显式实例化*</em><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;,<span class="keyword">int</span> &amp;);	<span class="comment">//显式具体化</span></div><div class="line"><span class="keyword">template</span> &lt;&gt;<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;,<span class="keyword">int</span> &amp;)</span></span>;	<span class="comment">//显式具体化</span></div><div class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> ,<span class="keyword">int</span> );	<span class="comment">//显式实例化</span></div></pre></td></tr></table></figure></p>
<p>显式实例化将使用swap（）模板生成一个使用int类型的实例。<br>Explicit instantiation lets you create an instantiation of a templated class or function without actually using it in your code. Because this is useful when you are creating library (.lib) files that use templates for distribution, uninstantiated template definitions are not put into object (.obj) files.<br>(For instance, libstdc++ contains the explicit instantiation of std::basic_string<char,char_traits<char>,allocator<char> &gt; (which is std::string) so every time you use functions of std::string, the same function code doesn’t need to be copied to objects. The compiler only need to refer (link) those to libstdc++.)</char></char,char_traits<char></p>
<hr>
<p><strong>关键字decltype</strong><br>在C++98中，编写模板函数时，并不是总能呢个知道应在声明中使用哪种类型<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">template&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</div><div class="line">void ft(T1 x,T2 y)</div><div class="line">&#123;</div><div class="line">	...</div><div class="line">	xpy=x+y;    <span class="comment">//xpy的类型无从知晓</span></div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++中新增关键字decltype提供了解决方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//利用decltype关键字来声明类型</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></div><div class="line"><span class="class"><span class="title">void</span> <span class="title">ft</span>(<span class="title">T1</span> <span class="title">x</span>,<span class="title">T2</span> <span class="title">y</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">	...</div><div class="line">	<span class="keyword">decltype</span>(x+y) xpy=x+y;    </div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[年度review-2017]]></title>
      <url>/2018/02/16/%E5%B9%B4%E5%BA%A6review-2017/</url>
      <content type="html"><![CDATA[<p>-今年也要加油呀！</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p>年度单曲：你离开了南京，从此没有人和我说话<br>年度专辑：÷ (Deluxe)<br>年度歌手：Pakho<br>年度电影：缝纫机乐队<br>年度动漫：马男波杰克-S4<br>年度美剧：Friends-S1~S9<br>年度主播：“四小天盒”<br>年度饮料：营养快线<br>年度外卖：烤肉拌饭/贝咖<br>年度语言：C++<br>年度OJ：codeup<br>年度书籍：人类简史<br>年度教材：SICP<br>年度网站：coursera<br>年度人物：柳神<br>年度词汇：Immerse<br>年度句子：你是狗吧<br>年度激励：对不起，游戏结束</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://img.blog.csdn.net/20180216014853857?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></h2>]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1065题解]]></title>
      <url>/2018/02/09/PAT-A1065%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-A1065. A+B and C (64bit) (20)<br>【时间限制】<br>100 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>16000 B<br>【题目描述<br>Given three integers A, B and C in [-263, 263], you are supposed to tell whether A+B &gt; C.</p>
<p>【Input Specification】<br>The first line of the input gives the positive number of test cases, T (&lt;=10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.</p>
<p>【Output Specification】<br>For each test case, output in one line “Case #X: true” if A+B&gt;C, or “Case #X: false” otherwise, where X is the case number (starting from 1).</p>
<p>【Sample Input】<br>3<br>1 2 3<br>2 3 4<br>9223372036854775807 -9223372036854775808 0<br>【Sample Output】<br>Case #1: false<br>Case #2: true<br>Case #3: false</p>
<hr>
<p>题目解析：这题和乙级其中的一题类似，区别在于这道题给定的范围过大。相加可能会导致溢出。因此需要在题意的基础上加上对于数据溢出的考量</p>
<hr>
<p>AC代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">		long long a,b,c;</div><div class="line">		scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);</div><div class="line">		long res=a+b;</div><div class="line">		bool flag;</div><div class="line">		if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;res&lt;0)			//正溢出 </div><div class="line">			flag=true;</div><div class="line">		else if(a&lt;0&amp;&amp;b&lt;0&amp;&amp;res&gt;=0)	//负溢出 </div><div class="line">			flag=false;</div><div class="line">		else if(res&gt;c)				//无溢出 </div><div class="line">			flag=true;</div><div class="line">		else </div><div class="line">			flag=false;</div><div class="line">		if(flag==true)&#123;</div><div class="line">			printf(&quot;Case #%d: true\n&quot;,tcase++);</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			printf(&quot;Case #%d: false\n&quot;,tcase++);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1046题解]]></title>
      <url>/2018/02/08/PAT-A1046%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p>PAT-A1046. Shortest Distance (20)<br>【时间限制】<br>100 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>16000 B<br>【Abstract】<br>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.<br>【Input Specification】<br>Each input file contains one test case. For each case, the first line contains an integer N (in [3, 105]), followed by N integer distances D1 D2 … DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (&lt;=104), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107.<br>【Output Specification】<br>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.<br>【Sample Input】<br>5 1 2 4 14 9<br>3<br>1 3<br>2 5<br>4 1<br>【Sample Output】<br>3<br>10<br>7</p>
<hr>
<p>题目的意思大致是：<br>给你n个结点两两之间的距离。<br>然后进行m次查询，每次查询给你2个结点。求最短距离。</p>
<hr>
<p>错误代码示范：<br>错误的原因主要在于太过暴力。完全没有考虑到时间复杂度。在这么大的时间复杂度下是不可能在Limit 100ms下跑完的。因此此代码还需要进行一些处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> m;					<span class="comment">//查询次数 </span></div><div class="line">	<span class="keyword">int</span> a,b;				<span class="comment">//查询的结点</span></div><div class="line">	<span class="keyword">int</span> D1=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> D2=<span class="number">0</span>;				<span class="comment">//不同方向计算的距离	 </span></div><div class="line">	<span class="keyword">int</span> Distance[MAXN];</div><div class="line">	<span class="keyword">int</span> temp;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;	<span class="comment">//读入结点之间距离 </span></div><div class="line">		<span class="built_in">cin</span>&gt;&gt;Distance[i];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;m;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</div><div class="line">		D1=<span class="number">0</span>;				<span class="comment">//清零操作 </span></div><div class="line">		D2=<span class="number">0</span>;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</div><div class="line">		<span class="keyword">if</span>(a&gt;b)&#123;</div><div class="line">			temp=a;</div><div class="line">			a=b;</div><div class="line">			b=temp;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=a<span class="number">-1</span>;j&lt;=b<span class="number">-2</span>;j++)&#123;</div><div class="line">			D1+=Distance[j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=b<span class="number">-1</span>;j&lt;n;j++)&#123;</div><div class="line">			D2+=Distance[j];</div><div class="line">		&#125; </div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a<span class="number">-1</span>;j++)&#123;</div><div class="line">			D2+=Distance[j];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(D1&gt;D2)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;D2;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;D1;</div><div class="line">		<span class="keyword">if</span>(i!=m<span class="number">-1</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</div><div class="line"><span class="keyword">int</span> dis[MAXN],A[MAXN];	<span class="comment">//dis数组表示1结点顺时针到达i结点的距离</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>,m,n,left,right;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;A[i];</div><div class="line">		sum+=A[i];		<span class="comment">//累加数组 </span></div><div class="line">		dis[i]=sum;		<span class="comment">//预处理dis数组 </span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;m;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;left&gt;&gt;right;</div><div class="line">		<span class="keyword">if</span>(left&gt;right)</div><div class="line">			swap(left,right);</div><div class="line">		<span class="keyword">int</span> temp=dis[right<span class="number">-1</span>]-dis[left<span class="number">-1</span>];</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;min(temp,sum-temp)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-A1042题解]]></title>
      <url>/2018/02/08/PAT-A1042%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-A1042. Shuffling Machine (20)<br>【时间限制】<br>400 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>16000 B<br>【Abstract】<br>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.<br>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:<br>S1, S2, …, S13, H1, H2, …, H13, C1, C2, …, C13, D1, D2, …, D13, J1, J2<br>where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.<br>【Input Specification】<br>Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.<br>【Output Specification】<br>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.<br>【Sample Input】<br>2<br>36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47<br>【Sample Output】<br>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</p>
<hr>
<p>题意大致是：<br>给54张牌，给你顺序进行操作。每次操作把第i个位置的牌换到所给的顺序序列的第i个位置。输出用13张S，13张H，13张C，13张D，2张J进行输出。</p>
<hr>
<p>AC代码：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="keyword">int</span> main()&#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">54</span>;</div><div class="line">	<span class="keyword">char</span> mp[<span class="number">5</span>]=&#123;<span class="string">'S'</span>,<span class="string">'H'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'J'</span>&#125;;		<span class="comment">//牌的编号与花色对应关系 </span></div><div class="line">	<span class="keyword">int</span> start[N+<span class="number">1</span>],<span class="built_in">end</span>[N+<span class="number">1</span>],next[N+<span class="number">1</span>];		<span class="comment">//next数组储存每次操作后的牌放置情况</span></div><div class="line">	<span class="keyword">int</span> k;</div><div class="line">	scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">	<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">		scanf(<span class="string">"%d"</span>,&amp;next[i]);		<span class="comment">//输入每个位置牌在操作后的位置 </span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">		start[i]=i;					<span class="comment">//初始化牌的编号 </span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">0</span>;<span class="built_in">step</span>&lt;k;<span class="built_in">step</span>++)&#123;		<span class="comment">//执行k次操作</span></div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">			<span class="built_in">end</span>[next[i]]=start[i];	<span class="comment">//把第i个位置的牌的编号存于位置next[i] </span></div><div class="line">		&#125;</div><div class="line">		<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">			start[i]=<span class="built_in">end</span>[i];		<span class="comment">//将调整完的位置序列复制给start供下次使用 </span></div><div class="line">		&#125;	 </div><div class="line">	&#125; </div><div class="line">	<span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</div><div class="line">		<span class="built_in">if</span>(i!=<span class="number">1</span>)					<span class="comment">//控制输出格式 </span></div><div class="line">			printf(<span class="string">" "</span>);	</div><div class="line">		start[i]--;</div><div class="line">		printf(<span class="string">"%c%d"</span>,mp[start[i]/<span class="number">13</span>],start[i]%<span class="number">13</span>+<span class="number">1</span>);	<span class="comment">//输出结果 </span></div><div class="line">	&#125; </div><div class="line">	<span class="built_in">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1008题解]]></title>
      <url>/2018/02/07/PAT-B1008%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p>PAT-B1008. 数组元素循环右移问题 (20)<br>【时间限制】<br>400 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【题目描述】<br>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？<br>【输入格式】<br>每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。<br>【输出格式】<br>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。<br>【输入样例】<br>6 2<br>1 2 3 4 5 6<br>【输出样例】<br>5 6 1 2 3 4</p>
<hr>
<p>AC代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> a[<span class="number">110</span>];</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> m;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;m;</div><div class="line">	m=m%n;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&lt;=n<span class="number">-1</span>;i++)</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;a[i];</div><div class="line">		<span class="keyword">if</span>(i!=n<span class="number">-1</span>)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1046题解]]></title>
      <url>/2018/02/07/PAT-B1046%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-B1046. 划拳(15)<br>【时间限制】<br>400 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【题目描述】<br>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。<br>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。<br>【输入格式】<br>输入第一行先给出一个正整数N（&lt;=100），随后N行，每行给出一轮划拳的记录，格式为：<br>甲喊 甲划 乙喊 乙划<br>其中“喊”是喊出的数字，“划”是划出的数字，均为不超过100的正整数（两只手一起划）。<br>【输出格式】<br>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。<br>【输入样例】<br>5<br>8 10 9 12<br>5 10 5 10<br>3 8 5 12<br>12 18 1 13<br>4 16 12 15<br>【输出样例】<br>1 2</p>
<hr>
<p>AC代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="keyword">int</span> a1,a2,b1,b2;</div><div class="line">	<span class="keyword">int</span> faila=<span class="number">0</span>;</div><div class="line">	<span class="keyword">int</span> failb=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a1&gt;&gt;a2&gt;&gt;b1&gt;&gt;b2;</div><div class="line">		<span class="keyword">if</span>(a2==a1+b1&amp;&amp;b2!=a1+b1)	<span class="comment">//甲猜对乙没猜对 </span></div><div class="line">			failb++;</div><div class="line">		<span class="keyword">if</span>(b2==a1+b1&amp;&amp;a2!=a1+b1)	<span class="comment">//乙猜对甲没猜对</span></div><div class="line">			faila++; </div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;faila&lt;&lt;<span class="string">" "</span>&lt;&lt;failb;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1026题解]]></title>
      <url>/2018/02/06/PAT-B1026/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PTA-B1026. 程序运行时间(15)<br>【时间限制】<br>200 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【题目描述】<br>要获得一个C语言程序的运行时间，常用的方法是调用头文件time.h，其中提供了clock()函数，可以捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。同时还有一个常数CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数f的运行时间，我们只要在调用f之前先调用clock()，获得一个时钟打点数C1；在f执行完成后再调用clock()，获得另一个时钟打点数C2；两次获得的时钟打点数之差(C2-C1)就是f运行所消耗的时钟打点数，再除以常数CLK_TCK，就得到了以秒为单位的运行时间。<br>这里不妨简单假设常数CLK_TCK为100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p>
<p>【输入格式】<br>输入在一行中顺序给出2个整数C1和C2。注意两次获得的时钟打点数肯定不相同，即C1 &lt; C2，并且取值在[0, 107]。<br>【输出格式】<br>在一行中输出被测函数运行的时间。运行时间必须按照“hh:mm:ss”（即2位的“时:分:秒”）格式输出；不足1秒的时间四舍五入到秒。<br>【输入样例】<br>123 4577973<br>【输出样例】<br>12:42:59</p>
<p>AC代码：<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">#include&lt;cstdio&gt;</div><div class="line">using namespace std<span class="comment">;</span></div><div class="line"><span class="comment">int main()&#123;</span></div><div class="line"><span class="comment">	int c1,c2;</span></div><div class="line"><span class="comment">	int s,min,h;</span></div><div class="line"><span class="comment">	cin&gt;&gt;c1&gt;&gt;c2;</span></div><div class="line"><span class="comment">	int c3=c2-c1;</span></div><div class="line"><span class="comment">	if(c3%100&gt;=50)	//四舍五入操作 </span></div><div class="line"><span class="comment">		c3=c3/100+1;</span></div><div class="line"><span class="comment">	else</span></div><div class="line"><span class="comment">		c3=c3/100;</span></div><div class="line"><span class="comment">	s=c3%60;</span></div><div class="line"><span class="comment">	c3=c3/60;</span></div><div class="line"><span class="comment">	min=c3%60;</span></div><div class="line"><span class="comment">	h=c3/60;</span></div><div class="line"><span class="comment">	printf("%02d:%02d:%02d",h,min,s);</span></div><div class="line"><span class="comment">	return 0;</span></div><div class="line"><span class="comment">&#125;</span></div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1016题解]]></title>
      <url>/2018/02/06/PAT-B1016%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-B1016. 部分A+B (15)<br>【时间限制】<br>100 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【题目描述】<br>正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。<br>现给定A、DA、B、DB，请编写程序计算PA + PB。<br>【输入格式】<br>输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。<br>【输出格式】<br>在一行中输出PA + PB的值。<br>输入样例1：<br>3862767 6 13530293 3<br>输出样例1：<br>399<br>输入样例2：<br>3862767 1 13530293 8<br>输出样例2：<br>0</p>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> a,b;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> da,db;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> pa=<span class="number">0</span>,pb=<span class="number">0</span>;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> pc;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;da&gt;&gt;b&gt;&gt;db;</div><div class="line">	<span class="keyword">while</span>(a!=<span class="number">0</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(a%<span class="number">10</span>==da)</div><div class="line">			pa=pa*<span class="number">10</span>+da;</div><div class="line">		a=a/<span class="number">10</span>;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</div><div class="line">		<span class="keyword">if</span>(b%<span class="number">10</span>==db)</div><div class="line">			pb=pb*<span class="number">10</span>+db;</div><div class="line">		b=b/<span class="number">10</span>;</div><div class="line">	&#125;</div><div class="line">	pc=pa+pb;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;pc;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1011题解]]></title>
      <url>/2018/02/06/PAT-B1011%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>PAT-1011. A+B和C (15)<br>【时间限制】<br>150 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【判题程序】<br>Standard<br>【题目描述】<br>给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。<br>【输入格式】<br>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。<br>【输出格式】<br>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。<br>【输入样例】<br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br>【输出样例】<br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false</p>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> T;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;T;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(T--)&#123;</div><div class="line">		<span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</div><div class="line">		<span class="keyword">if</span>(a+b&gt;c)</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i&lt;&lt;<span class="string">": true\n"</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i&lt;&lt;<span class="string">": false\n"</span>;</div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1009题解]]></title>
      <url>/2018/01/20/PAT-B1009%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-数组处理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>【题目描述】<br>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。<br>【输入格式】<br>测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。<br>【输出格式】：每个测试用例的输出占一行，输出倒序后的句子。<br>【输入样例】：<br>Hello World Here I Come<br>【输出样例】：<br>Come I Here World Hello</p>
<p>AC代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 81</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"> <span class="keyword">char</span> ch[SIZE];</div><div class="line"> <span class="keyword">char</span> str[SIZE][SIZE];</div><div class="line">    gets(ch);</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i,j,m = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; SIZE;i++)&#123;</div><div class="line">     <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; SIZE;j++)&#123;</div><div class="line">      <span class="keyword">if</span>(k &lt; <span class="built_in">strlen</span>(ch))&#123;</div><div class="line">       <span class="keyword">if</span>(ch[k] !=<span class="string">' '</span>)&#123;</div><div class="line">           str[i][j] = ch[k];</div><div class="line">           k++;</div><div class="line">      &#125;<span class="keyword">else</span>&#123;</div><div class="line">        k++;</div><div class="line">        m++;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">  &#125;</div><div class="line"> &#125;</div><div class="line"> <span class="keyword">for</span>(i = m;i &gt; <span class="number">0</span>;i--)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str[i]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</div><div class="line"> &#125;</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s"</span>,str[<span class="number">0</span>]);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[codeup-5901题解]]></title>
      <url>/2018/01/20/codeup-5901%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-字符串处理<br><a id="more"></a><br>【题目描述】<br>读入一串字符，判断是否是回文串。“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。</p>
<p>【输入】<br>一行字符串，长度不超过255。</p>
<p>【输出】<br>如果是回文串，输出“YES”，否则输出“NO”。</p>
<p>【样例输入】<br>12321<br>【样例输出】<br>YES</p>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;  </span></span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">256</span>;  </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">char</span> character[])</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> lenth=<span class="built_in">strlen</span>(character);  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lenth/<span class="number">2</span>;i++)  </div><div class="line">    &#123;  </div><div class="line">        <span class="comment">//数组折中，i对应max-i-1   </span></div><div class="line">        <span class="keyword">if</span>(character[i]!=character[lenth<span class="number">-1</span>-i])  </div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;     </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;     </div><div class="line">    <span class="keyword">char</span> character[maxn];  </div><div class="line">    <span class="keyword">while</span>(gets(character))  </div><div class="line">    &#123;  </div><div class="line">        <span class="keyword">bool</span> flag=Judge(character);  </div><div class="line">        <span class="keyword">if</span>(flag==<span class="literal">true</span>)  </div><div class="line">        &#123;  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"YES\n"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">        &#125;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">        &#123;  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"NO\n"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;     </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> codeup题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1022题解]]></title>
      <url>/2018/01/20/PAT-B1022%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-进制转换<br><a id="more"></a><br>【题目描述】<br>输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。</p>
<p>【输入格式】：<br>输入在一行中依次给出3个整数A、B和D。</p>
<p>【输出格式】：<br>输出A+B的D进制数。</p>
<p>【输入样例】：</p>
<blockquote>
<p>123 456 8</p>
</blockquote>
<p>【输出样例】：</p>
<blockquote>
<p>1103</p>
</blockquote>
<p>思路：先计算A+B（此时为十进制），然后把结果转换成D进制,而十进制转换为D进制进行“除基取余法”</p>
<p>AC代码：<br>```</p>
<p>#include<cstdio><br>int main(){<br>    int a,b,d;<br>    scanf(“%d%d%d”,&amp;a,&amp;b,&amp;d);<br>    int sum=a+b;<br>    int ans[31],num=0;   //ans存放D进制的每一位<br>    do{                           //进制转换<br>        ans[num++]=sum%d;<br>        sum=sum/d;<br>    }while(sum!=0);<br>    for(int i=num-1;i&gt;=0;i–){           //从高位到低位进行输出<br>        printf(“%d”,ans[i]);<br>    }<br>    return 0;<br>}</cstdio></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1036题解]]></title>
      <url>/2018/01/20/PAT-B1036%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟<br><a id="more"></a><br>【题目描述】<br>美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！</p>
<p>【输入格式】：<br>输入在一行中给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格。</p>
<p>【输出格式】：<br>输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。</p>
<p>【输入样例】：<br>10 a<br>【输出样例】：<br>aaaaaaaaaa<br>a        a<br>a        a<br>a        a<br>aaaaaaaaaa</p>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> column, row, temp;  </div><div class="line">    <span class="keyword">char</span> c;  </div><div class="line">    <span class="built_in">cin</span> &gt;&gt; column &gt;&gt; c;  </div><div class="line">    temp = column % <span class="number">2</span>;  </div><div class="line">    row = !temp ? column / <span class="number">2</span> : column / <span class="number">2</span> + <span class="number">1</span>;  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; column; i++)  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; c;  </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;row<span class="number">-2</span> ; i++) &#123;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)  </div><div class="line">            <span class="keyword">if</span> (!j || j == column - <span class="number">1</span>)  </div><div class="line">                <span class="built_in">cout</span> &lt;&lt; c;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; column; i++)  </div><div class="line">        <span class="built_in">cout</span> &lt;&lt; c;  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[codeup-1934题解]]></title>
      <url>/2018/01/20/codeup-1934%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-查找<br><a id="more"></a><br>【题目描述】：<br>输入一个数n，然后输入n个数值各不相同，再输入一个值x，输出这个值在这个数组中的下标（从0开始，若不在数组中则输出-1）。</p>
<p>【输入】：<br>测试数据有多组，输入n(1&lt;=n&lt;=200)，接着输入n个数，然后输入x。</p>
<p>【输出】：<br>对于每组输入,请输出结果。</p>
<p>【样例输入】：<br>4<br>1 2 3 4<br>3</p>
<p>【样例输出】：<br>2</p>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> a[<span class="number">201</span>]=&#123;<span class="number">0</span>&#125;;</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> k; </div><div class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);		<span class="comment">//输入n个数 </span></div><div class="line">		&#125;</div><div class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);				<span class="comment">//输入要查找的树 </span></div><div class="line">		<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)&#123;			<span class="comment">//遍历数组 </span></div><div class="line">			<span class="keyword">if</span>(a[k]==x)&#123;			<span class="comment">//找到了x </span></div><div class="line">				<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,k);	<span class="comment">//输出对应的下标 </span></div><div class="line">				<span class="keyword">break</span>;				<span class="comment">//退出查找 </span></div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(k==n)&#123;					<span class="comment">//在数组没有找到x </span></div><div class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);			<span class="comment">//输出-1 </span></div><div class="line">		&#125; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> codeup题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1032题解]]></title>
      <url>/2018/01/20/PAT-B1032%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>【1032】 挖掘机技术哪家强(20)<br>【时间限制】<br>200 ms<br>【内存限制】<br>65536 kB<br>【代码长度限制】<br>8000 B<br>【判题程序】<br>Standard<br>【作者】<br>CHEN, Yue<br>【题目描述】<br>为了用事实说明挖掘机技术到底哪家强，PAT组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。<br>【输入格式】：<br>输入在第1行给出不超过105的正整数N，即参赛人数。随后N行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从1开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。<br>【输出格式】：<br>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<p>【输入样例】：<br>6<br>3 65<br>2 80<br>1 100<br>2 70<br>3 40<br>3 0<br>【输出样例】：<br>2 150</p>
<p>题目解析：开大数组记录每个学校的总分，对每个读入的数据进行数组的同步。再寻找数组中最大的值及对应的编号。<br>思路：<br>①令数组school[maxn]记录每个学校的总分，初值为0,。对每一个读入的学校schID与其对应的分数score，令school[schID]+score.<br>②令变量k记录最高总分的学校编号，变量MAX记录最高总分，初值-1.由于学校是连续编号的，因此枚举编号1~N,不断跟新k和MAX即可</p>
<p>AC代码（C++）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> sum[<span class="number">100001</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//存储学校总成绩数组</span></div><div class="line">	<span class="keyword">int</span> i;				<span class="comment">//学校编号</span></div><div class="line">	<span class="keyword">int</span> j;</div><div class="line">	<span class="keyword">int</span> a;			 	<span class="comment">//参赛成绩 </span></div><div class="line">	<span class="keyword">int</span> Max=<span class="number">1</span>;			<span class="comment">//学校的最大编号 </span></div><div class="line">	<span class="keyword">int</span> MaxSum=<span class="number">0</span>;		<span class="comment">//最大学校总成绩 </span></div><div class="line">	<span class="keyword">int</span> N;				<span class="comment">//参赛人数 </span></div><div class="line">	<span class="built_in">cin</span>&gt;&gt;N;</div><div class="line">	<span class="keyword">while</span>(N--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;i;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a;</div><div class="line">		sum[i]+=a;</div><div class="line">		<span class="keyword">if</span>(i&gt;Max)</div><div class="line">			Max=i; </div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=Max;j++)&#123;</div><div class="line">		<span class="keyword">if</span>(sum[j]&gt;MaxSum)&#123;</div><div class="line">			MaxSum=sum[j];	<span class="comment">//记录最大总成绩 </span></div><div class="line">			i=j;			<span class="comment">//记录总成绩最大的学校编号 </span></div><div class="line">		&#125;</div><div class="line">	&#125; </div><div class="line">	<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;MaxSum;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：开数组时一定要置零，一开始沒置零只能过17个，置零才能完全过20.</p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PAT-B1001题解]]></title>
      <url>/2018/01/19/PATB1001%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>-简单模拟</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>【PAT B1001】害死人不偿命的(3n+1)猜想<br>【题目描述】<br>卡拉兹(Callatz)猜想：<br>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……<br>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p>
<p>【输入格式】：<br>    每个测试输入包含1个测试用例，即给出自然数n的值。</p>
<p>【输出格式】：<br>输出从n计算到1需要的步数。</p>
<p>【输入样例】：<br>3<br>【输出样例】：<br>5</p>
<p>题目分析：简单的模拟题，完成输入，按照奇数偶数的规律重复赋值，注意输入输出格式即可</p>
<p>思路：<br>读入题目给出的n，之后用while循环语句反复判断n是否为1；<br>①如果n为1，则退出循环<br>②如果n不为一，则判断n是否为奇数。如果n为奇数，令$n=(3*n+1)/2$;否则$n=n/2$。之后令计数器+1<br>这样下去，当退出循环时，输出的计数器的值就是步数。</p>
<p>AC代码：（C++）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">using namespace std;</div><div class="line">int main()&#123;</div><div class="line">	int i=0;			//计数器 </div><div class="line">	int n;				//测试数据 </div><div class="line">	cin&gt;&gt;n;</div><div class="line">	while(n!=1)&#123;</div><div class="line">		if(n%2==1)		//n为奇数 </div><div class="line">			n=(3*n+1)/2;</div><div class="line">		else			//n为偶数 </div><div class="line">			n=n/2;</div><div class="line">		i++;			//计数 </div><div class="line">	&#125;</div><div class="line">	cout&lt;&lt;i; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> PAT题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络-note1]]></title>
      <url>/2018/01/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-note1/</url>
      <content type="html"><![CDATA[<p>-简单介绍OJ的做题技巧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>互联网之所以能够向用户提供许多服务，就是因为互联网具有两个重要基本特点，即<font color="#0000FF">连通性</font>和<font color="#0000FF">共享性</font>。</p>
<p>网络是由若干接点和连接这些<font color="#0000FF">结点</font>的<font color="#0000FF">链路</font>组成的。网络中的结点可以使计算机、集线器、交换机或路由器等。网络之间还可以通过路由器俩捏起来，这就构成了一个覆盖范围更大的计算机网络。这样的网络称为<font color="#0000FF">互连网</font>。</p>
<p>网络把许多计算机连接在一起，而互连网则把许多网络通过路由器连接在一起。与网络相连的计算机常称为<font color="#0000FF">主机</font>。</p>
<hr>
<p>internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议（即通信规则）可以任意选择，不一定非要使用TCP/IP协议。</p>
<p>Internet（互联网，或因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用TCP/IP协议族作为通信的规则，且其前身是美国的APRANET。</p>
<hr>
<blockquote>
<p><strong>互联网基础结构发展的三个阶段</strong><br>1.第一阶段是从单个网络APRANET向互连网发展的过程<br>2.第二阶段是建成了三级结构的互联网。NSFNET是一个三级计算机网络，分为<font color="#0000FF">主干网</font>、<font color="#0000FF">地区网</font>和<font color="#0000FF">校园网（或企业网）</font>。<br>3.第三阶段的特点是逐渐形成了<font color="#0000FF">多层次ISP结构的互联网</font>。ISP译为互联网服务提供商。例如，中国电信，中国联通和中国移动等公司都是我国最有名的ISP。</p>
</blockquote>
<hr>
<p><strong>互联网交换点IXP</strong>的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p>
<blockquote>
<p>制定互联网的正式标准要经过以下三个阶段：<br>1.互联网草案—–互联网草案的有效期只有6个月，这个阶段还不算是RFC文档<br>2.建议标准—–这个阶段开始成为RFC文档<br>3.互联网标准—–达到正式标准后，每个标准就分配到一个编号 STD XX。一个标准可以和多个RFC标准关联。</p>
</blockquote>
<hr>
<p><strong><font size="5">互联网的组成<font></font></font></strong></p>
<blockquote>
<p>互联网的拓扑结构虽然十分复杂，并且在地理上覆盖了全球，但从其工作方式上看，可以划分为以下两大块：<br>1.<font color="#0000FF">边缘部分</font>    由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信和资源共享。<br>2.<font color="#0000FF">核心部分</font>    由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）</p>
</blockquote>
<hr>
<p><strong><font size="5">互联网的边缘部分<font></font></font></strong><br>处在互联网变元的部分就是连接在互联网上的所有的主机。这些主机又称为<font color="#0000FF">端系统</font>。边缘部分利用核心部分所提供的服务，使众多的主机之间能够相互通信并交换或共享信息。<br>“主机A和主机B进行通信”实际就是指“主机A的某个进程和主机B上的另一个进程进行通信”，比较严密的说法是“<strong>计算机之间通信</strong>”</p>
<p>在网络边缘的端系统之间的通信方式通常可划分为两大类：<strong>客户-服务器方式（C/S方式）</strong>和<strong>对等方式（P2P方式）</strong>。</p>
<font size="5" color="#0000FF">一.客户-服务器方式</font><br><strong>客户</strong>和<strong>服务器</strong>都是指通信中所涉及的两个应用进程。客户-服务器方式所描述的是进程之间服务和被服务的关系。<strong>客户是服务请求方，服务器是服务提供方</strong>。<strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务</strong>。<br><br>&gt;在实际应用中，客户程序和服务器程序通常还具有以下一些主要特点。<br><strong><font color="#0000FF">客户程序</font></strong>：<br>1.在用户调用后运行，在通信时主动向原地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。<br>2.不需要特殊的硬件和很复杂的操作系统<br><br><br>&gt;<strong><font color="#0000FF">服务器程序</font></strong>：<br>1.是一种专门用来提供某种服务的程序，<strong>可同时处理</strong>多个远地或本地客户的请求。<br>2.系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。<br>3.一般需要强大的硬件和高级的操作系统支持。<br><br>客户和服务器的通信关系建立后，通信可以使双向的，客户和服务器都可发送和接收数据。<br><br><strong>客户和服务器本来都值得是计算机进程。使用计算机的人是计算机的用户而不是客户。</strong><br><br><font size="5" color="#0000FF">二.对等连接方式</font><br>对等连接是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），它们就可以进行平等的、对等连接通信。这时，双方都可以下载对方已经存储在硬盘中的共享文档。因此这种方式也称为P2P方式。<br><br>—<br><strong><font size="5">互联网的核心部分</font></strong><br>网络核心部分是互联网中最复杂的部分，因为网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一台主机都能够向其他主机通信。<br>在网络核心部分起特殊作用的是<font color="#0000FF">路由器</font>，它是一种专用计算机（但不叫做主机）。路由器是实现<font color="#0000FF">分组交换</font>的关键构件，其任务是<font color="#0000FF">转发收到的分组</font>，这是网络核心的最重要的功能。<br><br><font size="5" color="#0000FF">1.电路交换的主要特点</font><br>电路交换取消了两台电话之间的直接连线，而使用<font color="#0000FF">交换机</font>来连接多台电话。<br>从通信资源的分配角度来看，<font color="#0000FF">交换</font>就是按照某种方式动态地分配传输线路的资源。在使用电话交换通话之前，必须先拨号请求建立连接。当被叫用户听到交换机送来的振铃音并摘机后，从主叫端到被叫端建立了一条连接，也就是一条专用的物理通路。这条通路保证双方通话时的通信资源，这些资源在双方通信时不会被其他用户占用。此后，主叫和被叫双方才能进行通话。通话完毕挂机后，交换机释放刚才使用的这条物理通路。<br><br>这种必须经过“<font color="#0000FF">建立连接</font>（分配占用通信资源）”-&gt;<font color="#0000FF">通话</font>（一直占用通信资源）-&gt;<font color="#0000FF">释放连接</font>（归还通信资源）“三个步骤的交换方式称为<font color="#0000FF">电路交换</font>

<p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p>
<p><font size="5" color="#0000FF">2.分组交换的主要特点</font><br>分组交换则采用<font color="#0000FF">存储转发技术</font>。<br>通常把要发送的整块数据称为一个<font color="#0000FF">报文</font>。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，例如，每个数据段为1024bit。在每一个数据段前面，加上一些由必要的控制信息组成的<font color="#0000FF">首部</font>后，就构成了一个<font color="#0000FF">分组</font>。分组又称为<font color="#0000FF">包</font>，分组的头部也可称为<font color="#0000FF">包头</font>。</p>
<p>分组是在互联网中传送的数据单元。分组中的”首部“是非常重要，正式分组的首部包含了诸如目的地址和原地址等重要控制信息，每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。</p>
<p>位于网络边缘的主机和位于网络核心部分的路由器都是计算机，但它们的作用却很不一样。<strong>主机是为用户进行信息处理的</strong>，并且可以和其他主机通过网络交换信息。<strong>路由器则是用来转发分组的，即进行分组交换的。</strong></p>
<p>当我们讨论互联网的核心部分中的路由器转发分组的过程时，往往把单个的网络简化成一条<font color="#0000FF">链路</font>，而路由器成为核心部分的<font color="#0000FF">结点</font>。</p>
<p>路由器暂时存储的是一个个段分组，而不是整个的长报文。短分组是暂时存储在路由器的存储器（内存）中而不是存储在磁盘中的。这样保证了较高的交换速率。</p>
<p>分组交换也带来一些问题。例如，分组在各路由器存储转发时需要排队，这就会造成一定的<font color="#0000FF">时延</font>。还有另一个问题是各分组必须携带的控制信息也造成了一定的<font color="#0000FF">开销</font>。整个分组交换网还需要专门的管理和控制机制。</p>
<blockquote>
<p><strong>三种交换方式在数据传送阶段的主要特点归纳</strong>：</p>
<p><font color="#0000FF">电路交换</font>—–整个报文的比特流连续地从源点直达终点，好像在一个管道中传送</p>
<p><font color="#0000FF">报文交换</font>—–整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点</p>
<p><font color="#0000FF">分组交换</font>—–单个分组传送到相邻结点，存储下来后找转发表，转发到下一个结点</p>
</blockquote>
<hr>
<p><strong><font size="5">计算机网络的定义<font></font></font></strong><br>计算机网络的精确定义并未统一<br>关于计算机网络的较好定义是：计算机网络主要是由一些通用的、可编程的硬件互连组成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p>
<p>根据这个定义：</p>
<blockquote>
<p>（1）计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机<br>（2）计算机网络并非专门用来传送数据，而是能够支持很多种的应用</p>
</blockquote>
<hr>
<p><strong><font size="5">计算机网络的分类<font></font></font></strong><br><strong>1.按照网络的作用范围来分类</strong></p>
<blockquote>
<p>（1）<font color="#0000FF">广域网WAN</font>    广域网的作用范围通常为几十到几千公里，因而有时也称为远程网。广域网是互联网的核心部分，其任务是通过长距离运送主机所发送的数据。连接广域网各结点交换机的链路一般都是高速链路，具有较大的通信容量。<br>（2）<font color="#0000FF">城域网MAN</font>    城域网的作用范围一般是一个城市。城域网可以位一个或几个单位所拥有，但也可以是一种公用设施，用来将多个局域网进行互连。目前很多城域网采用的是以太网技术。<br>（3）<font color="#0000FF">局域网LAN</font>    局域网一般用微型计算机或工作站通过高速通信线路相连，但地理上则局限在较小的范围。<br>（4）<font color="#0000FF">个人区域网PAN</font>    个人区域网就是在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络，因此也常称为无线个人区域网。</p>
</blockquote>
<p>如果中央处理器之间的举例非常近（1m或更小），则一般称为<font color="#0000FF">多处理机系统</font>，而不称为计算机网络。</p>
<p><strong>2.按照网络的使用者来分类</strong></p>
<blockquote>
<p>1.<font color="#0000FF">公用网</font>    这里指电信公司出资建造的大型网络。公用的意思就是愿意按电信公司的规定交纳费用的人都可以使用这种网络。<br>2.<font color="#0000FF">专用网</font>    这是某个部门为满足本单位的特殊业务工作的需要而建造的网络。不向本单位以外的人提供服务。</p>
</blockquote>
<p><strong>3.用来把用户接入到互联网的网络</strong><br>这种网络就是<font color="#0000FF">接入网AN</font>，它又称为<font color="#0000FF">本地接入网</font>或<font color="#0000FF">居民接入网</font>。<br>接入网不属于互联网的核心部分，也不属于互联网的边缘部分。</p>
<hr>
<p><strong><font size="5">计算机网络性能</font></strong><br>计算机网络的性能一般是指它的几个重要的性能指标。但除此之外，还有一些非性能特征也对计算机网络的性能有很大的影响。</p>
<p><font size="5" color="#0000FF">计算机网络的性能指标</font><br><strong><font size="5">1.速率</font></strong><br>计算机发送的信号都是数字形式的。<font color="#0000FF">比特（bit）</font>意思是一个”二进制数字“，因此一个比特就是二进制数字中的一个1或0。比特也是信息论中使用的<font color="#0000FF">信息量的单位</font>。网络技术中的<font color="#0000FF">速率</font>指的是<font color="#0000FF">数据的传送速率</font>，它也称为<font color="#0000FF">数据率</font>或<font color="#0000FF">比特率</font>。<strong>速率是计算机网络中最重要的一个性能指标。</strong>速率的单位是bit/s。当数据率较高时，常在bit/s前面加上一个字母。k=$10^3$，M=$10^6$，G=$10^9$，T=$10^{12}$，P=$10^{15}$，E=$10^{18}$，Z=$10^{21}$，Y=$10^{24}$。另外，当提到网络的速率时，往往指的是<font color="#0000FF">额定速率</font>或<font color="#0000FF">标称速率</font>，而并非网络实际上运行的速率。</p>
<p><strong><font size="5">2.带宽</font></strong><br>带宽具有两种不同的含义：<br>（1）带宽本来指的是某个<font color="#0000FF">信号具有的频带宽度</font>。信号的带宽指的是该信号包含的各种不同的频率成分所占据的频率范围。这种意义的带宽的单位是<font color="#0000FF">赫</font>（或千赫，兆赫等）。在过去很长的一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号）。因此，表示某信道允许通过的信号频带范围称为该信道的<font color="#0000FF">带宽</font>（或<font color="#0000FF">通频带</font>）</p>
<p>（2）在计算机网络中，带宽用来表示网络中某<font color="#0000FF">通道</font>传送数据的能力，因此网络带宽表示在单位时间内网络中某信道能通过的”<font color="#0000FF">最高数据率</font>“。这种意义的贷款的单位就是数据率的单位<font color="#0000FF">bit/s</font>.</p>
<p><strong><font size="5">3.吞吐量</font></strong></p>
<p><font color="#0000FF">吞吐量</font>表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。</p>
<p><strong><font size="5">4.时延</font></strong></p>
<p><font color="#0000FF">时延</font>是指数据从网络（或链路）的一段传送到另一端所需的时间。时延是一个很重要的性能指标。有时也被称作<font color="#0000FF">延迟</font>或<font color="#0000FF">迟延</font>。</p>
<blockquote>
<p><strong><font color="#0000FF">（1）发送时延</font></strong><br><strong>发送时延是主机或路由器发送数据帧所需要的时间</strong>。<br>$发送时延={数据帧长度(bit)}/{发送速率(bit/s)}$</p>
<p><strong><font color="#0000FF">（2）传播时延</font></strong><br><strong>传播时延是电磁波在信道中传播一定距离需要花费的时间</strong><br>$传播时延=信道长度(m)/电磁波在行道上的传播速率(m/s)$</p>
<p><strong><font color="#0000FF">（3）处理时延</font></strong><br>主机或路由器在收到分组时需要花费一定的时间进行处理。</p>
<p><strong><font color="#0000FF">（4）排队时延</font></strong><br>分组在经过网络传输时，需要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p>
<p><strong>发送时延发生在机器内部的发送器中，一般在网络适配器中，与传输信道的长度（或信号传送的距离）没有关系。但传播时延则发生在机器外部的传输信道媒体上，而与信号的发送速率无关。信号传送的距离越远，传播延时就越大。</strong><br><strong>对于高速网络链路，提高的仅仅是数据的发送速率而不是比特在链路上的传输速率。<font color="#0000FF">荷载信息的电磁波在通信线路上的传播速率取决于通信线路的介质材料，而与数据的发送速率并无关系</font>。提高数据的发送速率只是减小了数据的发送时延。</strong><br><strong><font color="#0000FF">$总时延=发送时延+传播时延+处理时延+排队时延$</font></strong></p>
<p><strong><font size="5">5.时延带宽积</font></strong><br>$时延带宽积=传播时延*贷款$<br>时延带宽积可以用来计算链路可容纳多少个比特。因此链路的时延带宽积又称为<font color="#0000FF">以比特为单位的链路长度</font>。</p>
<p><strong><font size="5">6.往返时间RTT</font></strong><br>在计算机网络中，往返时间RTT也是一个重要的性能指标、在许多情况下，互联网上的信息不仅仅是但方向传输而是双向交互的。</p>
<p><strong><font size="5">7.利用率</font></strong><br>利用率有信道利用率和网络利用率两种。信道利用率指出某信道有百分之几的时间是被利用的。完全空闲的信道的利用率为0.网络利用率则是全网络的信道利用率的加权平均值。</p>
</blockquote>
<p><strong>信道或网络利用率过高会产生非常大的时延</strong></p>
<blockquote>
<p><font size="5" color="#0000FF">计算机网络的非性能特征</font><br><strong>1.费用</strong><br>网络的性能与其价格密切相关</p>
<p><strong>2.质量</strong><br>网络的质量取决于网络中所有构件的质量，以及这些构件是怎样组成网络的。网络的质量影响到很多方面，如网络的可靠性、网络管理的简易性，以及网络的一些性能。</p>
<p><strong>3.标准化</strong><br>网络的硬件和软件的设计既可以按照通用的国际标准，也可以遵循特定的专用网络标准。</p>
<p><strong>4.可靠性</strong><br>可靠性与网络的质量和性能都有密切关系</p>
<p><strong>5.可扩展性和可升级性</strong><br>在构造网络时就要考虑到今后可能会需要扩展和升级。网络的性能越高，其扩展和升级费用往往也越高，难度也会相应增加。</p>
<p><strong>6.易于管理和维护</strong><br>网络如果没有良好的管理和维护，就很难达到和保持所涉及的性能。</p>
</blockquote>
<hr>
<p><strong><font size="5">计算机网络体系结构<font></font></font></strong></p>
<blockquote>
<p>连接在网络上的两台计算机要互相传送文件，在这两台计算机之间必须有一条传送数据的通路。但还远远不够，至少还有以下几项工作要完成：<br>1.发起通信的计算机必须将数据通信的通路进行<font color="#0000FF">激活</font>。所谓激活就是要发出一些信令，保证要传送的计算机数据能在这条通路上正确发送和接受。<br>2.要告诉网络如何识别接受数据的计算机<br>3.发起通信的计算机必须查明对方计算机是否已开机，并且与网络连接正常。<br>4.发起通信的计算机中的应用程序必须弄清楚，在对方计算机中的文件管理程序是否已做好接收文件和存储文件的准备文件。<br>5.对出现的各种差错和意外事故，如数据传送错误，重复或丢失，网络中某个结点交换机出现故障等，应当有可靠的措施来保证对方计算机最终能够接收到正确的文件。</p>
</blockquote>
<p><font size="5" color="#0000FF">协议与划分层次</font><br>在计算机网络中要做到有条不紊地交换数据，就必须遵守一些实现约定好的规则。这些规则<strong>明确规定了所交换的数据的格式以及有关的同步问题</strong>。这些为进行网络中的数据交换建立的规则、标准或约定称为<font color="#0000FF">网络协议</font>。网络协议也可简称为协议。</p>
<blockquote>
<p>网络协议主要由以下三个要素组成：<br>(1)<font color="#0000FF">语法</font>，即数据与控制信息的结构或格式；<br>(2)<font color="#0000FF">语义</font>，即需要发出何种控制信息，完成何种动作以及做出何种响应；<br>(3)<font color="#0000FF">同步</font>，即事件实现顺序的详细说明。</p>
<p>网络模块中分层带来的好处：<br>1.各层之间是相互独立的<br>2.灵活性好<br>3.结构上可分割开<br>4.易于实现和维护<br>5.能促进标准化工作</p>
</blockquote>
<p>分层时应注意使每一层的功能非常明确。若层数太少，就会使每一层的协议太复杂。若层数太多，又会在描述和综合各层功能的系统工程任务时遇到更多的困难。</p>
<blockquote>
<p>通常各层所要完成的功能主要有以下一些（可以只包括一种，也可以包括多种）：<br>1.差错控制<br>2.流量控制<br>3.分段和重装<br>4.复用和分用<br>5.连接建立和释放</p>
</blockquote>
<p><strong>计算机网络的各层及其协议的集合就是网络的体系结构</strong></p>
<hr>
<p><strong><font size="5">具有五层协议的体系结构<font></font></font></strong><br>OSI的七层协议体系结构的概念清楚，理论也较完全，但它既复杂又不实用。</p>
<blockquote>
<p><strong>OSI的七层协议：</strong><br>1.物理层<br>2.数据链路层<br>3.网络层<br>4.运输层<br>5.会话层<br>6.表示层<br>7.应用层</p>
</blockquote>
<p>TCP/IP体系结构则不同，TCP/IP是一个四层的体系结构，它包括应用层、运输层、网际层和网络接口层。</p>
<blockquote>
<p>TCP/IP的体系结构:<br>网络接口(相当于OSI中的物理层和数据链路层）<br>网际层IP（相当于OSI中的网络层）<br>运输层（TCP或UDP）（相当于OSI中的运输层）<br>应用层（相当于OSI中的应用层、会话层、表示层）</p>
</blockquote>
<p>综合OSI和TCP/IP的优点，采用五层协议的体系结构</p>
<blockquote>
<p>五层协议的体系结构:<br>1.物理层（对应OSI物理层）<br>2.数据链路层（对应OSI数据链路层）<br>3.网络层（对应OSI网络层）<br>4.运输层（对应OSI运输层）<br>5.应用层（对应TCP/IP应用层）</p>
</blockquote>
<p><font size="5">（1）应用层</font><br>应用层是体系结构中的最高层。应用层的任务是<font color="#0000FF">通过应用进程间的交互来完成特定网络应用</font>。应用层协议定义的是<font color="#0000FF">应用进程间通信和交互的规则</font>。这里的进程指的就是主机中正在进行的程序。一般把应用层交互的数据单元称为<font color="#0000FF">报文</font></p>
<p><font size="5">（2）运输层</font><br>运输层的任务就是<font color="#0000FF">负责向两台主机中进程之间的通信提供通用的数据传输服务</font>。</p>
<blockquote>
<p>运输层主要使用以下两种协议：</p>
<p><font color="#0000FF">传输控制协议TCP</font>——-提供面向连接的、可靠的数据传输服务，其数据传输的单位是<font color="#0000FF">报文段</font></p>
<p><font color="#0000FF">用户数据协议UDP</font>——-提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性），其数据输出的单位是<font color="#0000FF">用户数据报</font></p>
</blockquote>
<p><font size="5">（3）网络层</font><br>网络层负责<font color="#0000FF">为分组交换网上的不同主机提供通信服务</font>。在发送数据时，网络层吧运输层产生的报文段或用户数据报封装成<font color="#0000FF">分组</font>或<font color="#0000FF">包</font>进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做<font color="#0000FF">IP数据报</font>，或简称为<font color="#0000FF">数据包</font>。<br>互联网是由大量的<font color="#0000FF">异构</font>网络通过<font color="#0000FF">路由器</font>相互连接起来的。互联网使用的网络层协议是无连接的<font color="#0000FF">网际协议IP</font>和许多种路由选择协议，因此互联网的网络层也叫做<font color="#0000FF">网际层</font>或<font color="#0000FF">IP层</font>。</p>
<p><font size="5">（4）数据链路层</font><br>数据链路层常简称为<font color="#0000FF">链路层</font>。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报<font color="#0000FF">组装成帧</font>，在两个相邻结点间的链路上传送帧。每一帧包括数据和必要的<font color="#0000FF">控制信息</font>。</p>
<p><font size="5">（5）物理层</font><br>在物理层上所传数据的单位是<font color="#0000FF">比特</font>。<br>在互联网所使用的各种协议中，最重要的和最著名的就是TCP和IP两个协议。现在经常提到的TCP/IP并不一定单指TCP和IP两个具体的协议，而是互联网所使用的整个<font color="#0000FF">TCP/IP协议簇</font>。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NetWork </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-7]]></title>
      <url>/2018/01/18/Anyview%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-7<br>-树</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>/<strong><strong>**</strong></strong><br>【题目】若两棵二叉树T1和T2皆为空，或者皆不空<br>且T1的左、右子树和T2的左、右子树分别相似，则<br>称二叉树T1和T2相似。试编写算法，判别给定两棵<br>二叉树是否相似。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Status Similar(BiTree T1, BiTree T2)</div><div class="line"><span class="comment">/* 判断两棵二叉树是否相似的递归算法 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(T1==<span class="keyword">NULL</span>&amp;&amp;T2==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T1&amp;&amp;T2)&#123;</div><div class="line">        <span class="keyword">if</span>(Similar(T1-&gt;lchild,T2-&gt;lchild)==ERROR)</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">        <span class="keyword">if</span>(Similar(T1-&gt;rchild,T2-&gt;rchild)==ERROR)</div><div class="line">            <span class="keyword">return</span> ERROR;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">TRUE</span>;    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，求对二叉树T先序遍历时<br>第k个访问的结点的值。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">TElemType PreOrderK(BiTree T, <span class="keyword">int</span> k)</div><div class="line"><span class="comment">/* 求对二叉树T先序遍历时第k个访问的结点的值。*/</span></div><div class="line"><span class="comment">/* 若失败，则返回'#'                         */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,count=<span class="number">0</span>;</div><div class="line">    TElemType d;</div><div class="line">    BiTree a[<span class="number">20</span>],b;</div><div class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>||T==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</div><div class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> T-&gt;data;</div><div class="line">    d=PreOrderK(T-&gt;lchild,k<span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span>(d!=<span class="string">'#'</span>)</div><div class="line">        <span class="keyword">return</span> d;</div><div class="line">    b=T-&gt;lchild;</div><div class="line">    <span class="keyword">while</span>(b||i)&#123;</div><div class="line">        <span class="keyword">if</span>(b)&#123;</div><div class="line">            a[i]=b;</div><div class="line">            i++;</div><div class="line">            b=b-&gt;lchild;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            i--;</div><div class="line">            b=a[i];</div><div class="line">            b=b-&gt;rchild;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">    d=PreOrderK(T-&gt;rchild,k-count<span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span>(d!=<span class="string">'#'</span>)</div><div class="line">        <span class="keyword">return</span> d;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;                    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】编写递归算法，计算二叉树T中叶子结点的数目。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  <em>lchild, </em>rchild;<br>} BiTNode, <em>BiTree;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int Leaves(BiTree <span class="literal">T</span>)</div><div class="line">/* 计算二叉树<span class="literal">T</span>中叶子结点的数目 */</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">T</span>-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;<span class="literal">T</span>-&gt;rchild==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> </div><div class="line">        <span class="keyword">return</span> Leaves(<span class="literal">T</span>-&gt;lchild)+Leaves(<span class="literal">T</span>-&gt;rchild);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试利用栈及其基本操作写出二叉树T的非递归<br>的先序遍历算法。<br>二叉链表类型定义：<br>typedef struct BiTNode {<br>  TElemType  data;<br>  struct BiTNode  <em>lchild,</em>rchild;<br>} BiTNode, <em>BiTree;<br>可用栈类型Stack的相关定义：<br>typedef BiTree SElemType;   // 栈的元素类型<br>Status InitStack(Stack &amp;S);<br>Status StackEmpty(Stack S);<br>Status Push(Stack &amp;S, SElemType e);<br>Status Pop(Stack &amp;S, SElemType &amp;e);<br>Status GetTop(Stack S, SElemType &amp;e);<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void PreOrder(BiTree T, void (*visit)(TElemType))</div><div class="line"><span class="comment">/* 使用栈，非递归先序遍历二叉树T，     */</span></div><div class="line"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span></div><div class="line">&#123;</div><div class="line">    Stack S;</div><div class="line">    InitStack(S);</div><div class="line">    BiTree p=T;</div><div class="line">    <span class="keyword">while</span>(p)&#123;</div><div class="line">        <span class="function"><span class="title">visit</span>(p-&gt;</span><span class="keyword">data</span>);</div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>rchild)</div><div class="line">            P<span class="function"><span class="title">ush</span>(S,p-&gt;</span>rchild);</div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>lchild)</div><div class="line">            <span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">if</span>(StackEmpty(S)!=TRUE)</div><div class="line">                Pop(S,p);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p=NULL; </div><div class="line">    &#125;           </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div><div class="line">810</div><div class="line">811</div><div class="line">812</div><div class="line">813</div><div class="line">814</div><div class="line">815</div><div class="line">816</div><div class="line">817</div><div class="line">818</div><div class="line">819</div><div class="line">820</div><div class="line">821</div><div class="line">822</div><div class="line">823</div><div class="line">824</div><div class="line">825</div><div class="line">826</div><div class="line">827</div><div class="line">828</div><div class="line">829</div><div class="line">830</div><div class="line">831</div><div class="line">832</div><div class="line">833</div><div class="line">834</div><div class="line">835</div><div class="line">836</div><div class="line">837</div><div class="line">838</div><div class="line">839</div><div class="line">840</div><div class="line">841</div><div class="line">842</div><div class="line">843</div><div class="line">844</div><div class="line">845</div><div class="line">846</div><div class="line">847</div><div class="line">848</div><div class="line">849</div><div class="line">850</div><div class="line">851</div><div class="line">852</div><div class="line">853</div><div class="line">854</div><div class="line">855</div><div class="line">856</div><div class="line">857</div><div class="line">858</div><div class="line">859</div><div class="line">860</div><div class="line">861</div><div class="line">862</div><div class="line">863</div><div class="line">864</div><div class="line">865</div><div class="line">866</div><div class="line">867</div><div class="line">868</div><div class="line">869</div><div class="line">870</div><div class="line">871</div><div class="line">872</div><div class="line">873</div><div class="line">874</div><div class="line">875</div><div class="line">876</div><div class="line">877</div><div class="line">878</div><div class="line">879</div><div class="line">880</div><div class="line">881</div><div class="line">882</div><div class="line">883</div><div class="line">884</div><div class="line">885</div><div class="line">886</div><div class="line">887</div><div class="line">888</div><div class="line">889</div><div class="line">890</div><div class="line">891</div><div class="line">892</div><div class="line">893</div><div class="line">894</div><div class="line">895</div><div class="line">896</div><div class="line">897</div><div class="line">898</div><div class="line">899</div><div class="line">900</div><div class="line">901</div><div class="line">902</div><div class="line">903</div><div class="line">904</div><div class="line">905</div><div class="line">906</div><div class="line">907</div><div class="line">908</div><div class="line">909</div><div class="line">910</div><div class="line">911</div><div class="line">912</div><div class="line">913</div><div class="line">914</div><div class="line">915</div><div class="line">916</div><div class="line">917</div><div class="line">918</div><div class="line">919</div><div class="line">920</div><div class="line">921</div><div class="line">922</div><div class="line">923</div><div class="line">924</div><div class="line">925</div><div class="line">926</div><div class="line">927</div><div class="line">928</div><div class="line">929</div><div class="line">930</div><div class="line">931</div><div class="line">932</div><div class="line">933</div><div class="line">934</div><div class="line">935</div><div class="line">936</div><div class="line">937</div><div class="line">938</div><div class="line">939</div><div class="line">940</div><div class="line">941</div><div class="line">942</div><div class="line">943</div><div class="line">944</div><div class="line">945</div><div class="line">946</div><div class="line">947</div><div class="line">948</div><div class="line">949</div><div class="line">950</div><div class="line">951</div><div class="line">952</div><div class="line">953</div><div class="line">954</div><div class="line">955</div><div class="line">956</div><div class="line">957</div><div class="line">958</div><div class="line">959</div><div class="line">960</div><div class="line">961</div><div class="line">962</div><div class="line">963</div><div class="line">964</div><div class="line">965</div><div class="line">966</div><div class="line">967</div><div class="line">968</div><div class="line">969</div><div class="line">970</div><div class="line">971</div><div class="line">972</div><div class="line">973</div><div class="line">974</div><div class="line">975</div><div class="line">976</div><div class="line">977</div><div class="line">978</div><div class="line">979</div><div class="line">980</div><div class="line">981</div><div class="line">982</div><div class="line">983</div><div class="line">984</div><div class="line">985</div><div class="line">986</div><div class="line">987</div><div class="line">988</div><div class="line">989</div><div class="line">990</div><div class="line">991</div><div class="line">992</div><div class="line">993</div><div class="line">994</div><div class="line">995</div><div class="line">996</div><div class="line">997</div><div class="line">998</div><div class="line">999</div><div class="line">1000</div><div class="line">1001</div><div class="line">1002</div><div class="line">1003</div><div class="line">1004</div><div class="line">1005</div><div class="line">1006</div><div class="line">1007</div><div class="line">1008</div><div class="line">1009</div><div class="line">1010</div><div class="line">1011</div><div class="line">1012</div><div class="line">1013</div><div class="line">1014</div><div class="line">1015</div><div class="line">1016</div><div class="line">1017</div><div class="line">1018</div><div class="line">1019</div><div class="line">1020</div><div class="line">1021</div><div class="line">1022</div><div class="line">1023</div><div class="line">1024</div><div class="line">1025</div><div class="line">1026</div><div class="line">1027</div><div class="line">1028</div><div class="line">1029</div><div class="line">1030</div><div class="line">1031</div><div class="line">1032</div><div class="line">1033</div><div class="line">1034</div><div class="line">1035</div><div class="line">1036</div><div class="line">1037</div><div class="line">1038</div><div class="line">1039</div><div class="line">1040</div><div class="line">1041</div><div class="line">1042</div><div class="line">1043</div><div class="line">1044</div><div class="line">1045</div><div class="line">1046</div><div class="line">1047</div><div class="line">1048</div><div class="line">1049</div><div class="line">1050</div><div class="line">1051</div><div class="line">1052</div><div class="line">1053</div><div class="line">1054</div><div class="line">1055</div><div class="line">1056</div><div class="line">1057</div><div class="line">1058</div><div class="line">1059</div><div class="line">1060</div><div class="line">1061</div><div class="line">1062</div><div class="line">1063</div><div class="line">1064</div><div class="line">1065</div><div class="line">1066</div><div class="line">1067</div><div class="line">1068</div><div class="line">1069</div><div class="line">1070</div><div class="line">1071</div><div class="line">1072</div><div class="line">1073</div><div class="line">1074</div><div class="line">1075</div><div class="line">1076</div><div class="line">1077</div><div class="line">1078</div><div class="line">1079</div><div class="line">1080</div><div class="line">1081</div><div class="line">1082</div><div class="line">1083</div><div class="line">1084</div><div class="line">1085</div><div class="line">1086</div><div class="line">1087</div><div class="line">1088</div><div class="line">1089</div><div class="line">1090</div><div class="line">1091</div><div class="line">1092</div><div class="line">1093</div><div class="line">1094</div><div class="line">1095</div><div class="line">1096</div><div class="line">1097</div><div class="line">1098</div><div class="line">1099</div><div class="line">1100</div><div class="line">1101</div><div class="line">1102</div><div class="line">1103</div><div class="line">1104</div><div class="line">1105</div><div class="line">1106</div><div class="line">1107</div><div class="line">1108</div><div class="line">1109</div><div class="line">1110</div><div class="line">1111</div><div class="line">1112</div><div class="line">1113</div><div class="line">1114</div><div class="line">1115</div><div class="line">1116</div><div class="line">1117</div><div class="line">1118</div><div class="line">1119</div><div class="line">1120</div><div class="line">1121</div><div class="line">1122</div><div class="line">1123</div><div class="line">1124</div><div class="line">1125</div><div class="line">1126</div><div class="line">1127</div><div class="line">1128</div><div class="line">1129</div><div class="line">1130</div><div class="line">1131</div><div class="line">1132</div><div class="line">1133</div><div class="line">1134</div><div class="line">1135</div><div class="line">1136</div><div class="line">1137</div><div class="line">1138</div><div class="line">1139</div><div class="line">1140</div><div class="line">1141</div><div class="line">1142</div><div class="line">1143</div><div class="line">1144</div><div class="line">1145</div><div class="line">1146</div><div class="line">1147</div><div class="line">1148</div><div class="line">1149</div><div class="line">1150</div><div class="line">1151</div><div class="line">1152</div><div class="line">1153</div><div class="line">1154</div><div class="line">1155</div><div class="line">1156</div><div class="line">1157</div><div class="line">1158</div><div class="line">1159</div><div class="line">1160</div><div class="line">1161</div><div class="line">1162</div><div class="line">1163</div><div class="line">1164</div><div class="line">1165</div><div class="line">1166</div><div class="line">1167</div><div class="line">1168</div><div class="line">1169</div><div class="line">1170</div><div class="line">1171</div><div class="line">1172</div><div class="line">1173</div><div class="line">1174</div><div class="line">1175</div><div class="line">1176</div><div class="line">1177</div><div class="line">1178</div><div class="line">1179</div><div class="line">1180</div><div class="line">1181</div><div class="line">1182</div><div class="line">1183</div><div class="line">1184</div><div class="line">1185</div><div class="line">1186</div><div class="line">1187</div><div class="line">1188</div><div class="line">1189</div><div class="line">1190</div><div class="line">1191</div><div class="line">1192</div><div class="line">1193</div><div class="line">1194</div><div class="line">1195</div><div class="line">1196</div><div class="line">1197</div><div class="line">1198</div><div class="line">1199</div><div class="line">1200</div><div class="line">1201</div><div class="line">1202</div><div class="line">1203</div><div class="line">1204</div><div class="line">1205</div><div class="line">1206</div><div class="line">1207</div><div class="line">1208</div><div class="line">1209</div><div class="line">1210</div><div class="line">1211</div><div class="line">1212</div><div class="line">1213</div><div class="line">1214</div><div class="line">1215</div><div class="line">1216</div><div class="line">1217</div><div class="line">1218</div><div class="line">1219</div><div class="line">1220</div><div class="line">1221</div><div class="line">1222</div><div class="line">1223</div><div class="line">1224</div><div class="line">1225</div><div class="line">1226</div><div class="line">1227</div><div class="line">1228</div><div class="line">1229</div><div class="line">1230</div><div class="line">1231</div><div class="line">1232</div><div class="line">1233</div><div class="line">1234</div><div class="line">1235</div><div class="line">1236</div><div class="line">1237</div><div class="line">1238</div><div class="line">1239</div><div class="line">1240</div><div class="line">1241</div><div class="line">1242</div><div class="line">1243</div><div class="line">1244</div><div class="line">1245</div><div class="line">1246</div><div class="line">1247</div><div class="line">1248</div><div class="line">1249</div><div class="line">1250</div><div class="line">1251</div><div class="line">1252</div><div class="line">1253</div><div class="line">1254</div><div class="line">1255</div><div class="line">1256</div><div class="line">1257</div><div class="line">1258</div><div class="line">1259</div><div class="line">1260</div><div class="line">1261</div><div class="line">1262</div><div class="line">1263</div><div class="line">1264</div><div class="line">1265</div><div class="line">1266</div><div class="line">1267</div><div class="line">1268</div><div class="line">1269</div><div class="line">1270</div><div class="line">1271</div><div class="line">1272</div><div class="line">1273</div><div class="line">1274</div><div class="line">1275</div><div class="line">1276</div><div class="line">1277</div><div class="line">1278</div><div class="line">1279</div><div class="line">1280</div><div class="line">1281</div><div class="line">1282</div><div class="line">1283</div><div class="line">1284</div><div class="line">1285</div><div class="line">1286</div><div class="line">1287</div><div class="line">1288</div><div class="line">1289</div><div class="line">1290</div><div class="line">1291</div><div class="line">1292</div><div class="line">1293</div><div class="line">1294</div><div class="line">1295</div><div class="line">1296</div><div class="line">1297</div><div class="line">1298</div><div class="line">1299</div><div class="line">1300</div><div class="line">1301</div><div class="line">1302</div><div class="line">1303</div><div class="line">1304</div><div class="line">1305</div><div class="line">1306</div><div class="line">1307</div><div class="line">1308</div><div class="line">1309</div><div class="line">1310</div><div class="line">1311</div><div class="line">1312</div><div class="line">1313</div><div class="line">1314</div><div class="line">1315</div><div class="line">1316</div><div class="line">1317</div><div class="line">1318</div><div class="line">1319</div><div class="line">1320</div><div class="line">1321</div><div class="line">1322</div><div class="line">1323</div><div class="line">1324</div><div class="line">1325</div><div class="line">1326</div><div class="line">1327</div><div class="line">1328</div><div class="line">1329</div><div class="line">1330</div><div class="line">1331</div><div class="line">1332</div><div class="line">1333</div><div class="line">1334</div><div class="line">1335</div><div class="line">1336</div><div class="line">1337</div><div class="line">1338</div><div class="line">1339</div><div class="line">1340</div><div class="line">1341</div><div class="line">1342</div><div class="line">1343</div><div class="line">1344</div><div class="line">1345</div><div class="line">1346</div><div class="line">1347</div><div class="line">1348</div><div class="line">1349</div><div class="line">1350</div><div class="line">1351</div><div class="line">1352</div><div class="line">1353</div><div class="line">1354</div><div class="line">1355</div><div class="line">1356</div><div class="line">1357</div><div class="line">1358</div><div class="line">1359</div><div class="line">1360</div><div class="line">1361</div><div class="line">1362</div><div class="line">1363</div><div class="line">1364</div><div class="line">1365</div><div class="line">1366</div><div class="line">1367</div><div class="line">1368</div><div class="line">1369</div><div class="line">1370</div><div class="line">1371</div><div class="line">1372</div><div class="line">1373</div><div class="line">1374</div><div class="line">1375</div><div class="line">1376</div><div class="line">1377</div><div class="line">1378</div><div class="line">1379</div><div class="line">1380</div><div class="line">1381</div><div class="line">1382</div><div class="line">1383</div><div class="line">1384</div><div class="line">1385</div><div class="line">1386</div><div class="line">1387</div><div class="line">1388</div><div class="line">1389</div><div class="line">1390</div><div class="line">1391</div><div class="line">1392</div><div class="line">1393</div><div class="line">1394</div><div class="line">1395</div><div class="line">1396</div><div class="line">1397</div><div class="line">1398</div><div class="line">1399</div><div class="line">1400</div><div class="line">1401</div><div class="line">1402</div><div class="line">1403</div><div class="line">1404</div><div class="line">1405</div><div class="line">1406</div><div class="line">1407</div><div class="line">1408</div><div class="line">1409</div><div class="line">1410</div><div class="line">1411</div><div class="line">1412</div><div class="line">1413</div><div class="line">1414</div><div class="line">1415</div><div class="line">1416</div><div class="line">1417</div><div class="line">1418</div><div class="line">1419</div><div class="line">1420</div><div class="line">1421</div><div class="line">1422</div><div class="line">1423</div><div class="line">1424</div><div class="line">1425</div><div class="line">1426</div><div class="line">1427</div><div class="line">1428</div><div class="line">1429</div><div class="line">1430</div><div class="line">1431</div><div class="line">1432</div><div class="line">1433</div><div class="line">1434</div><div class="line">1435</div><div class="line">1436</div><div class="line">1437</div><div class="line">1438</div><div class="line">1439</div><div class="line">1440</div><div class="line">1441</div><div class="line">1442</div><div class="line">1443</div><div class="line">1444</div><div class="line">1445</div><div class="line">1446</div><div class="line">1447</div><div class="line">1448</div><div class="line">1449</div><div class="line">1450</div><div class="line">1451</div><div class="line">1452</div><div class="line">1453</div><div class="line">1454</div><div class="line">1455</div><div class="line">1456</div><div class="line">1457</div><div class="line">1458</div><div class="line">1459</div><div class="line">1460</div><div class="line">1461</div><div class="line">1462</div><div class="line">1463</div><div class="line">1464</div><div class="line">1465</div><div class="line">1466</div><div class="line">1467</div><div class="line">1468</div><div class="line">1469</div><div class="line">1470</div><div class="line">1471</div><div class="line">1472</div><div class="line">1473</div><div class="line">1474</div><div class="line">1475</div><div class="line">1476</div><div class="line">1477</div><div class="line">1478</div><div class="line">1479</div><div class="line">1480</div><div class="line">1481</div><div class="line">1482</div><div class="line">1483</div><div class="line">1484</div><div class="line">1485</div><div class="line">1486</div><div class="line">1487</div><div class="line">1488</div><div class="line">1489</div><div class="line">1490</div><div class="line">1491</div><div class="line">1492</div><div class="line">1493</div><div class="line">1494</div><div class="line">1495</div><div class="line">1496</div><div class="line">1497</div><div class="line">1498</div><div class="line">1499</div><div class="line">1500</div><div class="line">1501</div><div class="line">1502</div><div class="line">1503</div><div class="line">1504</div><div class="line">1505</div><div class="line">1506</div><div class="line">1507</div><div class="line">1508</div><div class="line">1509</div><div class="line">1510</div><div class="line">1511</div><div class="line">1512</div><div class="line">1513</div><div class="line">1514</div><div class="line">1515</div><div class="line">1516</div><div class="line">1517</div><div class="line">1518</div><div class="line">1519</div><div class="line">1520</div><div class="line">1521</div><div class="line">1522</div><div class="line">1523</div><div class="line">1524</div><div class="line">1525</div><div class="line">1526</div><div class="line">1527</div><div class="line">1528</div><div class="line">1529</div><div class="line">1530</div><div class="line">1531</div><div class="line">1532</div><div class="line">1533</div><div class="line">1534</div><div class="line">1535</div><div class="line">1536</div><div class="line">1537</div><div class="line">1538</div><div class="line">1539</div><div class="line">1540</div><div class="line">1541</div><div class="line">1542</div><div class="line">1543</div><div class="line">1544</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试利用栈及其基本操作写出二叉树T的非递归</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">的后序遍历算法(提示：为分辨后序遍历时两次进栈的</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">不同返回点，需在指针进栈时同时将一个标志进栈）。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">可用栈类型Stack的相关定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode *ptr; // 二叉树结点的指针类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int      tag; // 0..1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; SElemType;    // 栈的元素类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status InitStack(Stack &amp;S);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status StackEmpty(Stack S);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status Push(Stack &amp;S, SElemType e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status Pop(Stack &amp;S, SElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status GetTop(Stack S, SElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void PostOrder(BiTree bt, void (*visit)(TElemType))</div><div class="line"></div><div class="line"><span class="comment">/* 使用栈，非递归后序遍历二叉树T，     */</span></div><div class="line"></div><div class="line"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    Stack S;</div><div class="line"></div><div class="line">    InitStack(S);</div><div class="line"></div><div class="line">    SElemType e;</div><div class="line"></div><div class="line">    BiTree p=bt;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> tag=<span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(bt)&#123;</div><div class="line"></div><div class="line">        e.tag=<span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!StackEmpty(S)||p==bt)&#123;</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(p&amp;&amp;!tag)&#123;</div><div class="line"></div><div class="line">                e.ptr=p;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(p-&gt;lchild)&#123;<span class="comment">//如果存在左子树</span></div><div class="line"></div><div class="line">                p=p-&gt;lchild;</div><div class="line"></div><div class="line">                e.tag=<span class="number">0</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//否则为右子树</span></div><div class="line"></div><div class="line">                p=p-&gt;rchild;</div><div class="line"></div><div class="line">                e.tag=<span class="number">1</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            Push(S,e);</div><div class="line"></div><div class="line">        &#125;<span class="comment">//while</span></div><div class="line"></div><div class="line">        GetTop(S,e);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!StackEmpty(S)&amp;&amp;e.tag)&#123;</div><div class="line"></div><div class="line">            Pop(S,e); <span class="comment">//叶子结点出栈</span></div><div class="line"></div><div class="line">            p=e.ptr;</div><div class="line"></div><div class="line">            visit(p-&gt;data);<span class="comment">//输出该结点</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(!StackEmpty(S))&#123;</div><div class="line"></div><div class="line">            Pop(S,e); <span class="comment">//得到上一层结点</span></div><div class="line"></div><div class="line">            p=e.ptr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(e.tag)&#123;<span class="comment">//右子树已经入栈</span></div><div class="line"></div><div class="line">                visit(p-&gt;data);</div><div class="line"></div><div class="line">                p=<span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">else</span>&#123;<span class="comment">//右子树没入过栈</span></div><div class="line"></div><div class="line">                <span class="keyword">if</span>(p-&gt;rchild)&#123;</div><div class="line"></div><div class="line">                    p=p-&gt;rchild;</div><div class="line"></div><div class="line">                    tag=<span class="number">0</span>;</div><div class="line"></div><div class="line">                    e.tag=<span class="number">1</span>;</div><div class="line"></div><div class="line">                    Push(S,e);</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">else</span>&#123;<span class="comment">//没有右子树</span></div><div class="line"></div><div class="line">                    visit(p-&gt;data);</div><div class="line"></div><div class="line">                    p=<span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span>&#123;<span class="comment">//栈空则，p为NULL</span></div><div class="line"></div><div class="line">            p=<span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;<span class="comment">//while</span></div><div class="line"></div><div class="line">  &#125;<span class="comment">//if</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】二叉树采用三叉链表的存储结构，试编写</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">不借助栈的非递归中序遍历算法。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">三叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct TriTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct TriTNode  *parent, *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; TriTNode, *TriTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void InOrder(TriTree PT, void (*visit)(TElemType))</div><div class="line"></div><div class="line"><span class="comment">/* 不使用栈，非递归中序遍历二叉树PT，  */</span></div><div class="line"></div><div class="line"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    TriTree p,pr;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(PT!=<span class="keyword">NULL</span>)</div><div class="line"></div><div class="line"> &#123;</div><div class="line"></div><div class="line">    p = PT;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p!=<span class="keyword">NULL</span>)</div><div class="line"></div><div class="line">    &#123; <span class="keyword">if</span>(p-&gt;lchild==<span class="keyword">NULL</span>) visit(p-&gt;data);</div><div class="line"></div><div class="line">         <span class="comment">//输出有右子树的结点</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span>(p-&gt;lchild)  p = p-&gt;lchild;</div><div class="line"></div><div class="line">      <span class="keyword">else</span></div><div class="line"></div><div class="line">          <span class="keyword">if</span>(p-&gt;rchild)  p = p-&gt;rchild;</div><div class="line"></div><div class="line">          <span class="keyword">else</span></div><div class="line"></div><div class="line">          &#123;</div><div class="line"></div><div class="line">            </div><div class="line"></div><div class="line">           <span class="keyword">do</span>&#123;</div><div class="line"></div><div class="line">                pr = p;                 </div><div class="line"></div><div class="line">                p = p-&gt;parent;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(p-&gt;rchild!=pr)  <span class="comment">//如果pr是p的右子树则不输出</span></div><div class="line"></div><div class="line">                     visit(p-&gt;data);</div><div class="line"></div><div class="line">              &#125;<span class="keyword">while</span>(p!=<span class="keyword">NULL</span>&amp;&amp;(p-&gt;rchild==pr||<span class="keyword">NULL</span>==p-&gt;rchild));</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(p!=<span class="keyword">NULL</span>)   p = p-&gt;rchild;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】假设在三叉链表的结点中增设一个标志域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">(mark取值0,1或2)以区分在遍历过程中到达该结点</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">时应继续向左或向右或访问该结点。试以此存储结</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">构编写不用栈辅助的二叉树非递归后序遍历算法。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">带标志域的三叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct TriTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct TriTNode  *lchild, *rchild, *parent;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int       mark;  // 标志域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; TriTNode, *TriTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void PostOrder(TriTree T, void (*visit)(TElemType))</div><div class="line"></div><div class="line"><span class="comment">/* 不使用栈，非递归后序遍历二叉树T，   */</span></div><div class="line"></div><div class="line"><span class="comment">/* 对每个结点的元素域data调用函数visit */</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">     TriTree p,pr;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(T!=<span class="keyword">NULL</span>)</div><div class="line"></div><div class="line"> &#123;</div><div class="line"></div><div class="line">    p = T;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(p!=<span class="keyword">NULL</span>)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(p-&gt;lchild)  p = p-&gt;lchild;</div><div class="line"></div><div class="line">      <span class="keyword">else</span></div><div class="line"></div><div class="line">          <span class="keyword">if</span>(p-&gt;rchild)  p = p-&gt;rchild;</div><div class="line"></div><div class="line">          <span class="keyword">else</span></div><div class="line"></div><div class="line">          &#123;</div><div class="line"></div><div class="line">           <span class="keyword">do</span>&#123;</div><div class="line"></div><div class="line">             pr = p;</div><div class="line"></div><div class="line">             visit(pr-&gt;data);</div><div class="line"></div><div class="line">             p = p-&gt;parent;             </div><div class="line"></div><div class="line">           &#125;<span class="keyword">while</span>(p!=<span class="keyword">NULL</span>&amp;&amp;(p-&gt;rchild==pr||<span class="keyword">NULL</span>==p-&gt;rchild));</div><div class="line"></div><div class="line">           <span class="keyword">if</span>(p!=<span class="keyword">NULL</span>)   p = p-&gt;rchild;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写递归算法，将二叉树中所有结点的</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">左、右子树相互交换。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void ExchangeSubTree(BiTree &amp;T)</div><div class="line"></div><div class="line"><span class="comment">/* 将二叉树中所有结点的左、右子树相互交换 */</span></div><div class="line"></div><div class="line">&#123;    BiTree p;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(T-&gt;lchild) ExchangeSubTree(T-&gt;lchild);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(T-&gt;rchild) ExchangeSubTree(T-&gt;rchild);</div><div class="line"></div><div class="line">    p = T-&gt;lchild;</div><div class="line"></div><div class="line">    T-&gt;lchild = T-&gt;rchild;</div><div class="line"></div><div class="line">    T-&gt;rchild = p;</div><div class="line"></div><div class="line">     </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写递归算法：求二叉树中以元素值</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">为x的结点为根的子树的深度。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> BirTreeDepth(BiTree T)&#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> depthLeft,depthRight;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">null</span>==T) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">    depthLeft = BirTreeDepth(T-&gt;lchild);</div><div class="line"></div><div class="line">    depthRight = BirTreeDepth(T-&gt;rchild);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>+(depthLeft &gt; depthRight?depthLeft:depthRight);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Findx(BiTree T,BiTree &amp;p,TElemType x)&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(T)&#123;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(T-&gt;data==x)&#123;</div><div class="line"></div><div class="line">p=T;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">Findx(T-&gt;lchild,p,x);</div><div class="line"></div><div class="line">Findx(T-&gt;rchild,p,x);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">int</span> Depthx(BiTree T, TElemType x)</div><div class="line"></div><div class="line"><span class="comment">/* 求二叉树中以值为x的结点为根的子树深度*/</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    BiTree p=<span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">Findx(T,p,x);</div><div class="line"></div><div class="line"><span class="keyword">return</span> BirTreeDepth(p);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写递归算法：对于二叉树中每一个元素值为x</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">的结点，删去以它为根的子树，并释放相应的空间。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void Destroy(BiTree &amp;T)&#123;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(T)&#123;</div><div class="line"></div><div class="line">    Destroy(T-&gt;lchild);</div><div class="line"></div><div class="line">    Destroy(T-&gt;rchild);</div><div class="line"></div><div class="line">    free(T);</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*BiTree find(BiTree &amp;T, char x)&#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   if(!T) return null;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   if(T-&gt;data == x) return T;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   find(T-&gt;lchild,x); find(T-&gt;rchild,x);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125;       */</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">void ReleaseX(BiTree &amp;T, <span class="keyword">char</span> x)</div><div class="line"></div><div class="line"><span class="comment">/* 对于二叉树T中每一个元素值为x的结点，*/</span></div><div class="line"></div><div class="line"><span class="comment">/* 删去以它为根的子树，并释放相应的空间 */</span></div><div class="line"></div><div class="line">&#123;   </div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(T-&gt;data==x)</div><div class="line"></div><div class="line">    Destroy(T);</div><div class="line"></div><div class="line">    ReleaseX(T-&gt;lchild, x);</div><div class="line"></div><div class="line">      ReleaseX(T-&gt;rchild, x);</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写复制一棵二叉树的递归算法。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef char TElemType; // 设二叉树的元素为char类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void CopyBiTree(BiTree T, BiTree &amp;TT)</div><div class="line"></div><div class="line"><span class="comment">/* 递归复制二叉树T得到TT */</span></div><div class="line"></div><div class="line">&#123;   </div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">     TT = (BiTree)malloc(sizeof(BiTNode));</div><div class="line"></div><div class="line">     <span class="keyword">if</span>(!TT) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">     TT-&gt;data = T-&gt;data;</div><div class="line"></div><div class="line">     <span class="keyword">if</span>(T-&gt;lchild) CopyBiTree(T-&gt;lchild,TT-&gt;lchild);</div><div class="line"></div><div class="line">     <span class="keyword">if</span>(T-&gt;rchild) CopyBiTree(T-&gt;rchild,TT-&gt;rchild);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写算法判别给定二叉树是否为完全二叉树。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">可用队列类型Queue的相关定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef BiTree QElemType; // 设队列元素为二叉树的指针类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status InitQueue(Queue &amp;Q);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status EnQueue(Queue &amp;Q, QElemType e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status DeQueue(Queue &amp;Q, QElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status GetHead(Queue Q, QElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status QueueEmpty(Queue Q);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">Status CompleteBiTree(BiTree bt)</div><div class="line"></div><div class="line"><span class="comment">/* 判别二叉树T是否为完全二叉树*/</span></div><div class="line"></div><div class="line">&#123;  Queue Q;</div><div class="line"></div><div class="line">     QElemType p;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> tag=<span class="number">0</span>;</div><div class="line"></div><div class="line">     EnQueue(Q,bt);</div><div class="line"></div><div class="line">     <span class="keyword">while</span>(!QueueEmpty(Q))</div><div class="line"></div><div class="line">     &#123;</div><div class="line"></div><div class="line">       DeQueue(Q,p);</div><div class="line"></div><div class="line">       <span class="keyword">if</span>(!p) tag=<span class="number">1</span>;       <span class="comment">//如果到最后输出都为空，表示已经遍历完成，确认是完全树</span></div><div class="line"></div><div class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(tag) <span class="keyword">return</span> ERROR;</div><div class="line"></div><div class="line">       <span class="keyword">else</span></div><div class="line"></div><div class="line">       &#123;</div><div class="line"></div><div class="line">       EnQueue(Q,p-&gt;lchild);</div><div class="line"></div><div class="line">       EnQueue(Q,p-&gt;rchild);</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> OK;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写一个二叉排序树的判定算法。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉排序树的类型BSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  KeyType key;  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  ... ...   // 其他数据域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; TElemType;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BSTNode  *lchild, *rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125;BSTNode, *BSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">Status IsBSTree(BSTree t)</div><div class="line"></div><div class="line"><span class="comment">/* 判别二叉树T是否为二叉排序树。*/</span></div><div class="line"></div><div class="line"><span class="comment">/* 若是，则返回TRUE，否则FALSE  */</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    BSTree p,q;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(t)</div><div class="line"></div><div class="line">  &#123;    p=t-&gt;lchild;</div><div class="line"></div><div class="line">       q=t-&gt;rchild;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(p&amp;&amp;p-&gt;data.key&gt;=t-&gt;data.key)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(q&amp;&amp;q-&gt;data.key&lt;=t-&gt;data.key)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (IsBSTree(p))</div><div class="line"></div><div class="line">     <span class="keyword">return</span> IsBSTree(q);</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line"></div><div class="line">  </div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写递归算法，从大到小输出给定二叉排序树</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">中所有关键字不小于x的数据元素。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉排序树的类型BSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    KeyType key;  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    ... ...   // 其他数据域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; TElemType;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BSTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125;BSTNode, *BSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void OrderOut(BSTree t, KeyType x, void(*visit)(TElemType))</div><div class="line"></div><div class="line"><span class="comment">/* 调用visit(T-&gt;data)输出  */</span></div><div class="line"></div><div class="line">&#123;  KeyType key = t-&gt;data.key;</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!t)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(key&gt;=x)</div><div class="line"></div><div class="line">    &#123;          </div><div class="line"></div><div class="line">        OrderOut(t-&gt;rchild,x,visit);</div><div class="line"></div><div class="line">        visit(t-&gt;data);</div><div class="line"></div><div class="line">        OrderOut(t-&gt;lchild,x,visit);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">else</span></div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        OrderOut(t-&gt;rchild,x,visit);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试写一非递归算法，在二叉查找树T中插入元素e。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉查找树的类型BSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  KeyType key;  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    ... ...   // 其他数据域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; TElemType;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BSTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BSTNode, *BSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">Status InsertBST_I(BSTree &amp;T, TElemType k)</div><div class="line"></div><div class="line"><span class="comment">/* 在二叉查找树T中插入元素e的非递归算法*/</span></div><div class="line"></div><div class="line">&#123;  BSTree p,L,q = T ;</div><div class="line"></div><div class="line">  p = (BSTree)malloc(sizeof(BSTNode));</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(p == <span class="keyword">NULL</span>)   <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line"></div><div class="line">  p-&gt;data = k;  p-&gt;lchild = <span class="keyword">NULL</span>; p-&gt;rchild = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(q!=<span class="keyword">NULL</span>)</div><div class="line"></div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(q-&gt;data.key == k.key)   <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(q-&gt;data.key &gt; k.key)</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">         <span class="keyword">if</span>(q-&gt;lchild!=<span class="keyword">NULL</span>)    q = q-&gt;lchild;        </div><div class="line"></div><div class="line">          <span class="keyword">else</span>                  q-&gt;lchild = p;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(q-&gt;data.key &lt; k.key)</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">         <span class="keyword">if</span>(q-&gt;rchild!=<span class="keyword">NULL</span>)    q = q-&gt;rchild;</div><div class="line"></div><div class="line">          <span class="keyword">else</span>                  q-&gt;rchild = p;</div><div class="line"></div><div class="line">         &#125;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，求二叉树T中结点a和b的最近共同祖先。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BiTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BiTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BiTNode, *BiTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">可用栈类型Stack的相关定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  BiTNode *ptr; // 二叉树结点的指针类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int      tag; // 0..1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; SElemType;      // 栈的元素类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status InitStack(Stack &amp;S);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status StackEmpty(Stack S);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">int StackLength(SqStack S);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status Push(Stack &amp;S, SElemType e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status Pop(Stack &amp;S, SElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Status GetTop(Stack S, SElemType &amp;e);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> void findElem(BiTree T,TElemType e,Stack &amp;s)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    BiTree t=T;</div><div class="line"></div><div class="line">    BiTNode *bip;</div><div class="line"></div><div class="line">    SElemType se;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(t)</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(t-&gt;lchild)</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(t-&gt;data==e) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">            se.ptr=t;se.tag=<span class="number">1</span>;</div><div class="line"></div><div class="line">            Push(s,se);            </div><div class="line"></div><div class="line">            t=t-&gt;lchild;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(t-&gt;data==e) <span class="keyword">return</span> ;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(t-&gt;rchild) &#123;se.ptr=t;se.tag=<span class="number">1</span>;Push(s,se);t=t-&gt;rchild;&#125;</div><div class="line"></div><div class="line">        <span class="keyword">else</span></div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            bip=t;Pop(s,se);t=se.ptr;</div><div class="line"></div><div class="line">            <span class="keyword">while</span>(t-&gt;rchild==bip||!t-&gt;rchild)</div><div class="line"></div><div class="line">            &#123;</div><div class="line"></div><div class="line">                bip=t;</div><div class="line"></div><div class="line">                <span class="keyword">if</span>(t!=T) &#123;Pop(s,se);t=se.ptr;&#125;</div><div class="line"></div><div class="line">                <span class="keyword">else</span> <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            se.ptr=t;se.tag=<span class="number">1</span>;</div><div class="line"></div><div class="line">            Push(s,se);</div><div class="line"></div><div class="line">            t=t-&gt;rchild;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">BiTree CommAncestor(BiTree T, TElemType a, TElemType b)</div><div class="line"></div><div class="line"><span class="comment">/* 求二叉树T中结点a和b的最近共同祖先*/</span></div><div class="line"></div><div class="line">&#123;   Stack sa,sb,st;</div><div class="line"></div><div class="line">    SElemType sea,seb;</div><div class="line"></div><div class="line">    BiTree bi,bii;</div><div class="line"></div><div class="line">      </div><div class="line"></div><div class="line">    InitStack(sa);InitStack(sb);InitStack(st);</div><div class="line"></div><div class="line">    findElem(T,a,sa);</div><div class="line"></div><div class="line">    findElem(T,b,sb);</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!StackEmpty(sa))</div><div class="line"></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        Pop(sa,sea);</div><div class="line"></div><div class="line">        bi=sea.ptr;</div><div class="line"></div><div class="line">        st=sb;</div><div class="line"></div><div class="line">        <span class="keyword">while</span>(!StackEmpty(st))</div><div class="line"></div><div class="line">        &#123;</div><div class="line"></div><div class="line">            Pop(st,seb);</div><div class="line"></div><div class="line">            bii=seb.ptr;</div><div class="line"></div><div class="line">            <span class="keyword">if</span>(bi-&gt;data==bii-&gt;data)<span class="keyword">return</span> bi;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】在二叉排序树的每个结点中增设一个lsize域，</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">其值为该结点的左子树中的结点数加1。试编写时间复杂</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">度为O(logn)的算法，求树中第k小的结点的位置。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">二叉排序树的类型BSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef char KeyType;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  KeyType key;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BSTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int lsize; // 新增域，值为左子树的结点数+1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BSTNode, *BSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">BSTNode *Ranking(BSTree T, <span class="keyword">int</span> k)</div><div class="line"></div><div class="line"><span class="comment">/* 在含lsize域的二叉排序树T中，*/</span></div><div class="line"></div><div class="line"><span class="comment">/* 求指向T中第k小的结点的指针  */</span></div><div class="line"></div><div class="line">&#123;  <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(T-&gt;lsize==k) <span class="keyword">return</span> T;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;lsize&gt;k) <span class="keyword">return</span> Ranking(T-&gt;lchild, k) ;</div><div class="line"></div><div class="line">         <span class="keyword">else</span> <span class="keyword">return</span> Ranking(T-&gt;rchild, k-T-&gt;lsize);</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】假设二叉排序树T的每个结点的平衡因子域bf当前</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">均为0。试编写算法，求二叉排序树T的深度，并为每个结点</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">的bf域赋予正确的平衡因子值。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">平衡二叉排序树的类型BBSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef char KeyType;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BBSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  KeyType key;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int bf;    // 平衡因子</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BBSTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BBSTNode, *BBSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"><span class="comment">/*int depth(BBSTree t)&#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     int l;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     int r;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     if(!t) return 0;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     else &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">       l = depth(t-&gt;lchild);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">       r = depth(t-&gt;rchild);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">       return 1+(l&gt;r?l:r);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">     &#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125;  */</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">int</span> Depth_BF(BBSTree T)</div><div class="line"></div><div class="line"><span class="comment">/* 求二叉排序树T的深度，并为每个结点*/</span></div><div class="line"></div><div class="line"><span class="comment">/* 的bf域赋予正确的平衡因子值。      */</span></div><div class="line"></div><div class="line">&#123;   <span class="keyword">int</span> l,r;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">     l = Depth_BF(T-&gt;lchild);</div><div class="line"></div><div class="line">     r = Depth_BF(T-&gt;rchild);</div><div class="line"></div><div class="line">     T-&gt;bf = l-r;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>+(l&gt;r?l:r);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】编写平衡二叉排序树的右平衡处理算法。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">平衡二叉排序树的类型BBSTree定义如下：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef char KeyType;  </span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct BBSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  KeyType key;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int  bf;    // 平衡因子</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct BBSTNode  *lchild,*rchild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; BBSTNode, *BBSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">可调用下列旋转调整操作：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">void L_Rotate(BBSTree &amp;p); // 对最小失衡子树p做左旋调整</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">void R_Rotate(BBSTree &amp;p); // 对最小失衡子树p做右旋调整</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">void RightBalance(BBSTree &amp;T)</div><div class="line"></div><div class="line"><span class="comment">/* 实现对二叉树T的右平衡处理*/</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    BBSTree lc,rd;</div><div class="line"></div><div class="line">   rd = T-&gt;rchild;</div><div class="line"></div><div class="line">   <span class="keyword">switch</span>(rd-&gt;bf)&#123;</div><div class="line"></div><div class="line">       <span class="keyword">case</span> RH:</div><div class="line"></div><div class="line">            T-&gt;bf = rd-&gt;bf = EH; L_Rotate(T); <span class="keyword">break</span>;</div><div class="line"></div><div class="line">       <span class="keyword">case</span> LH:</div><div class="line"></div><div class="line">            lc = rd-&gt;lchild;</div><div class="line"></div><div class="line">            <span class="keyword">switch</span>(lc-&gt;bf)&#123;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> LH: T-&gt;bf = EH;  lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> EH: T-&gt;bf = rd-&gt;bf = EH;<span class="keyword">break</span>;</div><div class="line"></div><div class="line">              <span class="keyword">case</span> RH: T-&gt;bf=LH; lc-&gt;bf = EH; <span class="keyword">break</span>;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">           lc-&gt;bf=EH;</div><div class="line"></div><div class="line">           R_Rotate(T-&gt;rchild);</div><div class="line"></div><div class="line">           L_Rotate(T);</div><div class="line"></div><div class="line">           <span class="keyword">break</span>;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，对一棵以孩子兄弟链表表示</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">的树统计叶子的个数。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子兄弟链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct CSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct CSTNode  *firstChild, *nextSibling;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; CSTNode, *CSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">void Count(CSTree T, <span class="keyword">int</span> &amp;n)&#123;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(T)&#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span>(!T-&gt;firstChild) n++;</div><div class="line"></div><div class="line">     Count(T-&gt;firstChild, n);</div><div class="line"></div><div class="line">     Count(T-&gt;nextSibling, n);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">int</span> Leave(CSTree T) <span class="comment">/* 统计树T的叶子数*/</span></div><div class="line"></div><div class="line">&#123;   </div><div class="line"></div><div class="line">    <span class="keyword">int</span> n =<span class="number">0</span>;</div><div class="line"></div><div class="line">    Count(T , n);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> n;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，求一棵以孩子兄弟链表表示的树的度。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子兄弟链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct CSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct CSTNode  *firstChild, *nextSibling;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; CSTNode, *CSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">int</span> Degree(CSTree T) <span class="comment">/* 求树T的度*/</span></div><div class="line"></div><div class="line">&#123;  </div><div class="line"></div><div class="line">   <span class="keyword">int</span> ds,dt,d;</div><div class="line"></div><div class="line">   CSTree p;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(!T) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">   <span class="keyword">else</span> &#123; ds=<span class="number">0</span>;dt=<span class="number">0</span>;</div><div class="line"></div><div class="line">       <span class="keyword">for</span>( p = T-&gt;firstChild; p ; p= p-&gt;nextSibling)&#123;</div><div class="line"></div><div class="line">          dt++;</div><div class="line"></div><div class="line">          d= Degree(p);</div><div class="line"></div><div class="line">          <span class="keyword">if</span>(d&gt;ds) ds =d;</div><div class="line"></div><div class="line">       &#125;</div><div class="line"></div><div class="line">           </div><div class="line"></div><div class="line">       <span class="keyword">return</span> ds&gt;dt?ds:dt;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，对以双亲表示法存储的树计算深度。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int     parent;  // 双亲位置</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; PTNode; // 结点类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  PTNode nodes[MAX_TREE_SIZE]; // 结点存储空间</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int  n, r; // 结点数和根的位置</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; PTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> PTreeDepth(PTree T) <span class="comment">/* 求树T的深度*/</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line"> <span class="keyword">int</span> maxdep = <span class="number">0</span>,i,dep,j;</div><div class="line"></div><div class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;T.n;i++)&#123;</div><div class="line"></div><div class="line">      dep=<span class="number">0</span>;</div><div class="line"></div><div class="line">      <span class="keyword">for</span>(j =i; j&gt;<span class="number">0</span>; j=T.nodes[j].<span class="keyword">parent</span>) dep++;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>(dep&gt;maxdep) maxdep = dep;</div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> maxdep+<span class="number">1</span>;</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，对以双亲孩子表示法存储的树计算深度。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct ChildNode &#123;  // 孩子结点</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int childIndex;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct ChildNode *nextChild;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; ChildNode; // 孩子结点类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct  &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int     parent;  // 双亲位置</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct ChildNode *firstChild; // 孩子链表头指针</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; PCTreeNode; // 结点类型</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  PCTreeNode *nodes; // 结点存储空间</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  int  n, r; // 结点数和根的位置</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; PCTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">int</span> fun(PCTree T, <span class="keyword">int</span> pos)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(T.nodes[pos].firstChild == <span class="keyword">NULL</span>)  <span class="keyword">return</span> <span class="number">1</span>;   </div><div class="line"></div><div class="line">   ChildNode *temp = T.nodes[pos].firstChild;</div><div class="line"></div><div class="line">   <span class="keyword">int</span> depth = <span class="number">1</span>, max = <span class="number">1</span>;</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">   <span class="keyword">while</span>(temp != <span class="keyword">NULL</span>)</div><div class="line"></div><div class="line">   &#123;</div><div class="line"></div><div class="line">      <span class="keyword">if</span>( T.nodes[temp-&gt;childIndex].firstChild != <span class="keyword">NULL</span>)</div><div class="line"></div><div class="line">      &#123;</div><div class="line"></div><div class="line">        depth = fun(T, temp-&gt;childIndex);</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(depth &gt; max)</div><div class="line"></div><div class="line">        max = depth;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      temp = temp-&gt;nextChild;</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   </div><div class="line"></div><div class="line">   <span class="keyword">return</span> max + <span class="number">1</span>;       </div><div class="line"></div><div class="line">                  </div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> PCTreeDepth(PCTree T) <span class="comment">/* 求树T的深度*/</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> depth;</div><div class="line"></div><div class="line">   depth = fun(T, T.r);</div><div class="line"></div><div class="line">   <span class="keyword">return</span> depth;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】试编写算法，对以孩子-兄弟链表表示的树计算深度。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子兄弟链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct CSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct CSTNode  *firstChild, *nextSibling;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; CSTNode, *CSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> TreeDepth(CSTree T)</div><div class="line"></div><div class="line"><span class="comment">/* 求树T的深度*/</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">     <span class="keyword">int</span> dep1,dep2,dep;</div><div class="line"></div><div class="line">     <span class="keyword">if</span>(!T) dep=<span class="number">0</span>;</div><div class="line"></div><div class="line">     <span class="keyword">else</span>&#123;</div><div class="line"></div><div class="line">        dep1 =   TreeDepth(T-&gt;firstChild);</div><div class="line"></div><div class="line">        dep2 = TreeDepth(T-&gt;nextSibling);</div><div class="line"></div><div class="line">        dep = dep1+<span class="number">1</span>&gt;dep2?dep1+<span class="number">1</span>:dep2;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> dep;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="comment">/**********</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">【题目】已知一棵树的由根至叶子结点按层次输出的</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">结点序列及每个结点的度。试编写算法，构造此树的</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子兄弟链表。</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">孩子兄弟链表类型定义：</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">typedef struct CSTNode &#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  TElemType  data;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  struct CSTNode  *firstChild, *nextSibling;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">&#125; CSTNode, *CSTree;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">**********/</span></div><div class="line"></div><div class="line">CSTree CreateCSTNode(<span class="keyword">char</span> e) &#123;</div><div class="line"></div><div class="line">    CSTNode *p = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    p = (CSTNode*)malloc(sizeof(CSTNode));</div><div class="line"></div><div class="line">    p-&gt;data = e;</div><div class="line"></div><div class="line">    p-&gt;firstChild = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    p-&gt;nextSibling = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> p;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">void BuildCSTree(CSTree &amp;T, <span class="keyword">char</span> *node, <span class="keyword">int</span> *degree)</div><div class="line"></div><div class="line"><span class="comment">/* 由结点的层序序列node和各结点的度degree构造树的孩子兄弟链表T */</span></div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> i, j, present=<span class="number">1</span>;</div><div class="line"></div><div class="line">    CSTree Tree[<span class="number">50</span>];</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">NULL</span> == node) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    Tree[<span class="number">0</span>] = CreateCSTNode(node[<span class="number">0</span>]);</div><div class="line"></div><div class="line">    T = Tree[<span class="number">0</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; node[i]!=<span class="string">'\0'</span>; i++) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(degree[i]!=<span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">            Tree[present] = CreateCSTNode(node[present]);</div><div class="line"></div><div class="line">            Tree[i]-&gt;firstChild = Tree[present];</div><div class="line"></div><div class="line">            present ++;</div><div class="line"></div><div class="line">            <span class="keyword">for</span>(j=<span class="number">2</span>; j&lt;=degree[i]; j++) &#123;</div><div class="line"></div><div class="line">                Tree[present] = CreateCSTNode(node[present]);</div><div class="line"></div><div class="line">                Tree[present<span class="number">-1</span>]-&gt;nextSibling = Tree[present];</div><div class="line"></div><div class="line">                present ++;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法笔记-note1]]></title>
      <url>/2018/01/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-note1/</url>
      <content type="html"><![CDATA[<p>-简单介绍OJ的做题技巧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>小写字母的ASCII码值比大写字母的大32</p>
<p>字符常量必须用单引号来标注</p>
<p>使用scanf，数组不需要加&amp;运算符，因为数组名称本身就代表这个数组第一个元素的地址。</p>
<p>scanf的%c格式是可以读取空格和换行的</p>
<p>典型输出格式：<br>1.%md可以使不足m位以m位进行右对齐输出，其中高位用空格补齐；<br>如果变量本身超过m位，则保持原样。</p>
<ol>
<li>%.mf可以使让浮点数保留m位小数输出，保留使用的是“四舍六入五成双”规则.</li>
</ol>
<p>typedef用来给复杂的数据类型起别名.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给long long类型起别名L</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> L;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>常用math函数</strong>：<br>1.fabs（double x）函数<br>此函数用于对double型变量取绝对值<br>2.floor（double x）函数<br>此函数用于double型变量的向下取整<br>3.ceil（double x）函数<br>此函数用于double型变量的向上取整<br>4.pow（double r，double p）函数<br>此函数用于返回$r^p$<br>5.sqrt（double x）<br>此函数用于返回double型变量的算数平方根<br>6.log（double x）<br>此函数用于返回double型变量的以自然对数为底的对数<br>7.sin（double x）、cos（double x）、tan（double x）<br>返回double型变量的sin，cos，tan值<br>8.round（double x）<br>该函数用于将double型变量x四舍五入，返回类型也是double型</p>
<hr>
<p><strong>memset函数</strong><br>使用memset函数需要加头文件string.h头文件<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">memset<span class="comment">( a , 0 ,sizeof(a)</span>);<span class="comment">//将数组a的元素全部赋值为0</span></div><div class="line">memset<span class="comment">( a , 1 ,sizeof(a)</span>);<span class="comment">//将数组a的元素全部赋值为1</span></div></pre></td></tr></table></figure></p>
<hr>
<p>gets函数用于输入一行字符串（gets识别换行符\n作为输入结束）<br>puts函数用于输出一行字符串并换行</p>
<hr>
<p><strong>string.h头文件</strong><br>1.strlen函数<br>strlen函数可以得到字符数组中第一个\0前的字符的个数<br>2.strcmp函数<br>strcmp函数返回两个字符串大小的比较结果，按照字典序进行比较，如果字符数组1&lt;字符数组2，返回一个负整数；<font color="#DC143C">如果字符数组1==字符数组2，则返回0</font>;如果字符数组1&gt;字符数组2，则返回一个正整数。<br>3.strcpy函数<br>strcpy函数可以把一个字符串复制给另一个字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcpy</span>(str1,str2);</div><div class="line"><span class="comment">//把字符数组2复制字符数组1</span></div></pre></td></tr></table></figure></p>
<p>4.strcat函数<br>strcat函数可以把一个字符串接到另一个字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(str1,str2);</div><div class="line"><span class="comment">//把字符数组2接到字符数组1后面</span></div></pre></td></tr></table></figure></p>
<p>5.sscanf函数<br>sscanf函数的作用是把字符数组str中的内容合并以%d的形式写到n中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sscanf(<span class="name">str</span>,<span class="string">"%d"</span>,<span class="symbol">&amp;n</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>6.sprintf函数<br>sprintf函数的作用是把整数n的每一位拆分写入字符数组中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sprintf(<span class="name">str</span>,<span class="string">"%d"</span>,n)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>典型输入方式</strong><br>1.while…EOF型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">while</span><span class="params">(scanf(<span class="string">"%d"</span>, &amp;n)</span></span>!=EOF)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.while(T–)型<br>在给定测试数据组数的情况下，使用这种类型的输入</p>
<hr>
<p><strong>典型输出类型</strong><br>1.正常输出<br>2.每组数据输出之后都额外加一个空格<br>直接加printf(“\n”);<br>3.两组输出数据之间有一个空格，最后一局数据后面没有空格<br>只需对是否是最后一行进行判断即可</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[电梯模拟]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%94%B5%E6%A2%AF%E6%A8%A1%E6%8B%9F/</url>
      <content type="html"><![CDATA[<p>-严蔚敏数据结构<br>-电梯模拟系统的实现<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"HEAD.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintClientInfo</span><span class="params">(Client p,ClientStatus s)</span></span>&#123;</div><div class="line"><span class="comment">//输出乘客信息</span></div><div class="line">	<span class="keyword">switch</span>(s) &#123;</div><div class="line">		<span class="keyword">case</span> New:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客进入第"</span>&lt;&lt;p.Infloor&lt;&lt;<span class="string">"层"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GiveUp:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t"</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客放弃等待, 等待了"</span>&lt;&lt;Time-p.InTime&lt;&lt;<span class="string">"/0.1s"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Out:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客走出电梯"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> In:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客走进电梯，要去第"</span>&lt;&lt;p.Outfloor&lt;&lt;<span class="string">"层"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">CreatClient</span><span class="params">(Client *&amp;p)</span></span>&#123;</div><div class="line">	<span class="comment">//生成新的乘客</span></div><div class="line">	p=<span class="keyword">new</span> Client;							<span class="comment">//新建乘客类型	 </span></div><div class="line">	<span class="keyword">if</span>(!p) 									<span class="comment">//新建乘客失败 </span></div><div class="line">		<span class="keyword">return</span> OVERFLOW;</div><div class="line">	p-&gt;ClientID=ID++;						<span class="comment">//产生乘客编号 </span></div><div class="line">	p-&gt;GiveUpTime=rand()%<span class="number">120</span>+<span class="number">30</span>;			<span class="comment">//产生乘客所能容忍的等待时间</span></div><div class="line">	p-&gt;InTime=Time;							<span class="comment">//产生乘客进入电梯系统的时间 </span></div><div class="line">	InterTime=rand()%<span class="number">300</span>;					<span class="comment">//产生下一乘客要到达的时间</span></div><div class="line">	p-&gt;Outfloor=rand()%(Maxfloor+<span class="number">1</span>);		<span class="comment">//产生乘客所要到达的楼层</span></div><div class="line">	<span class="comment">//该乘客出现的楼层</span></div><div class="line">	<span class="keyword">while</span>((p-&gt;Infloor=rand()%(Maxfloor+<span class="number">1</span>))==p-&gt;Outfloor);</div><div class="line">	<span class="comment">//cin&gt;&gt;p-&gt;Infloor&gt;&gt;p-&gt;Outfloor&gt;&gt;InterTime;</span></div><div class="line">	PrintClientInfo(*p,New);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">DestoryClient</span><span class="params">(Client *&amp;p)</span> </span>&#123;</div><div class="line">	<span class="comment">//该乘客离开系统</span></div><div class="line">	<span class="keyword">delete</span> p;</div><div class="line">	p=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">GoAbove</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断该乘客是否去往高层</span></div><div class="line">	<span class="keyword">if</span>(e.Outfloor&gt;e.Infloor) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CInfloor</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入的楼层</span></div><div class="line">	<span class="keyword">return</span> e.Infloor;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CInTime</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入时间</span></div><div class="line">	<span class="keyword">return</span> e.InTime;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">COutfloor</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入时间</span></div><div class="line">	<span class="keyword">return</span> e.Outfloor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue &amp;Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//构造一个空队列Q</span></div><div class="line">	Q.front=Q.rear=<span class="keyword">new</span> QNode;</div><div class="line">	<span class="keyword">if</span>(!Q.front) <span class="keyword">return</span> OVERFLOW;<span class="comment">//分配存储失败</span></div><div class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	Q.front-&gt;data=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue &amp;Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁队列Q</span></div><div class="line">	<span class="keyword">while</span>(Q.front) &#123;</div><div class="line">		Q.rear=Q.front-&gt;next;</div><div class="line">		<span class="keyword">if</span>(Q.front-&gt;data) DestoryClient(Q.front-&gt;data);</div><div class="line">		<span class="keyword">delete</span> Q.front;</div><div class="line">		Q.front=Q.rear;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue &amp;Q,QElemType e)</span> </span>&#123;</div><div class="line">	<span class="comment">//插入元素e为Q的新的队尾元素</span></div><div class="line">	QueuePtr p;</div><div class="line">	p=<span class="keyword">new</span> QNode;</div><div class="line">	<span class="keyword">if</span>(!p) <span class="keyword">return</span> OVERFLOW;</div><div class="line">	p-&gt;data=e;p-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	Q.rear-&gt;next=p;</div><div class="line">	Q.rear=p;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue &amp;Q,QElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//若队列不空,则删除Q的队头元素,用e返回其值,并返回OK;</span></div><div class="line">	<span class="comment">//否则返回ERROR</span></div><div class="line">	QueuePtr p;</div><div class="line">	<span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">	p=Q.front-&gt;next;</div><div class="line">	e=p-&gt;data;</div><div class="line">	Q.front-&gt;next=p-&gt;next;</div><div class="line">	<span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;</div><div class="line">	<span class="keyword">delete</span> p;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断队列是否为空</span></div><div class="line">	<span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">QDelNode</span><span class="params">(Queue &amp;Q,QueuePtr p)</span> </span>&#123;</div><div class="line">	<span class="comment">//删除队列中p指向的结点的下一个结点</span></div><div class="line">	QueuePtr q;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</div><div class="line">	q=p-&gt;next;</div><div class="line">	p-&gt;next=q-&gt;next;</div><div class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>) Q.rear=p;</div><div class="line">	DestoryClient(q-&gt;data);</div><div class="line">	<span class="keyword">delete</span> q;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">CGiveUp</span><span class="params">(Queue &amp;Q,<span class="keyword">int</span> <span class="built_in">floor</span>)</span> </span>&#123;</div><div class="line">	<span class="comment">//删除放弃等待的乘客</span></div><div class="line">	QueuePtr p;</div><div class="line">	p=Q.front;</div><div class="line">	<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>) </div><div class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;data-&gt;GiveUpTime==<span class="number">0</span>&amp;&amp;<span class="built_in">floor</span>!=p-&gt;next-&gt;data-&gt;Infloor) &#123;</div><div class="line">			PrintClientInfo(*(p-&gt;next-&gt;data),GiveUp);</div><div class="line">			TotalTime+=Time-CInTime(*(p-&gt;next-&gt;data));</div><div class="line">			QDelNode(Q,p);<span class="comment">//将放弃等待的人删除</span></div><div class="line">			GiveUpNumber++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>	p-&gt;next-&gt;data-&gt;GiveUpTime--;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueue</span><span class="params">(Queue Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出队列</span></div><div class="line">	QueuePtr q;</div><div class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>) <span class="keyword">goto</span> end;</div><div class="line">	q=Q.front-&gt;next;</div><div class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;setw(<span class="number">3</span>)&lt;&lt;q-&gt;data-&gt;ClientID&lt;&lt;<span class="string">' '</span>;</div><div class="line">		q=q-&gt;next;</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">end:</div><div class="line">	<span class="keyword">while</span>(count++&lt;=<span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"    "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//构造一个空栈</span></div><div class="line">	S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> OVERFLOW;</div><div class="line">	S.top=S.base;</div><div class="line">	S.stacksize=STACK_INIT_SIZE;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//InitStack</span></div><div class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁栈S</span></div><div class="line">	SElemType	*p;</div><div class="line">	<span class="keyword">if</span>(S.base) &#123;</div><div class="line">		<span class="keyword">for</span>(p=S.base;p&lt;S.top;p++)</div><div class="line">			DestoryClient(*p);</div><div class="line">		<span class="built_in">free</span>(S.base);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//把S置为空</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR; </div><div class="line">	S.top=S.base;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(ClientStack S)</span> </span>&#123;</div><div class="line">	<span class="comment">//若栈S为空，则返回TRUE，否则返回FALSE</span></div><div class="line">	<span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span>			  <span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(ClientStack S)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回栈S的长度</span></div><div class="line">	<span class="keyword">return</span> S.top-S.base;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(ClientStack S,SElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回栈顶元素</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	e=*(S.top<span class="number">-1</span>);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//GetTop</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(ClientStack &amp;S,SElemType e)</span> </span>&#123;</div><div class="line">	<span class="comment">//入栈</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	<span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize) &#123;</div><div class="line">		S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">		<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> OVERFLOW;</div><div class="line">		S.top=S.base+S.stacksize;</div><div class="line">		S.stacksize+=STACKINCREMENT;</div><div class="line">	&#125;</div><div class="line">	*S.top++=e;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//Push</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(ClientStack &amp;S,SElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//出栈</span></div><div class="line">	<span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	e=*(--S.top);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//Pop</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出栈</span></div><div class="line">	SElemType *i;</div><div class="line">	i=S.base;</div><div class="line">	<span class="keyword">while</span>(i&lt;S.top)</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;(*i++)-&gt;ClientID&lt;&lt;<span class="string">' '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitEle</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化电梯类型</span></div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	E.<span class="built_in">floor</span>=<span class="number">1</span>;<span class="comment">//电梯初始停在第一层</span></div><div class="line">	E.status=Idle;E.Count=OverTime;</div><div class="line">	E.Stage=Down;</div><div class="line">	E.ClientNumber=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		E.CallUp[i]=<span class="number">0</span>;E.CallDown[i]=<span class="number">0</span>;E.CallCar[i]=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) InitStack(E.S[i]);</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">CountOver</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯计时是否完成</span></div><div class="line">	<span class="keyword">if</span>(E.Count) &#123;</div><div class="line">		E.Count--;<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryEle</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁电梯类型</span></div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) DestroyStack(E.S[i]);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">EleFloor</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回电梯所在的层</span></div><div class="line">	<span class="keyword">return</span> E.<span class="built_in">floor</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">ElevatorStatus <span class="title">EleStatus</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回电梯状态</span></div><div class="line">	<span class="keyword">return</span> E.status;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">RequireAbove</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断是否有高层请求</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=E.<span class="built_in">floor</span>+<span class="number">1</span>;i&lt;=Maxfloor;i++)</div><div class="line">		<span class="keyword">if</span>(E.CallCar[i]||E.CallDown[i]||E.CallUp[i]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">RequireBelow</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断是否有低层请求</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=E.<span class="built_in">floor</span><span class="number">-1</span>;i&gt;=Minfloor;i--)</div><div class="line">		<span class="keyword">if</span>(E.CallCar[i]||E.CallDown[i]||E.CallUp[i]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">EleAchieved</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯是否要停于当前层</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Up&amp;&amp;E.CallUp[E.<span class="built_in">floor</span>]||E.Stage==Down&amp;&amp;E.CallDown[E.<span class="built_in">floor</span>])</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Up&amp;&amp;E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;!RequireAbove(E)) &#123;</div><div class="line">		E.Stage=Down;<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Down&amp;&amp;E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;!RequireBelow(E)) &#123;</div><div class="line">		E.Stage=Up;<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">EleOpenDoor</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯是否要开门</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]||E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;E.Stage==Down||E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;E.Stage==Up)</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.status==Idle) &#123;</div><div class="line">		<span class="keyword">if</span>(E.CallDown[E.<span class="built_in">floor</span>]) &#123;E.Stage=Down;<span class="keyword">return</span> TRUE;&#125;</div><div class="line">		<span class="keyword">if</span>(E.CallUp[E.<span class="built_in">floor</span>]) &#123;E.Stage=Up;<span class="keyword">return</span> TRUE;&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//*******************************************************************</span></div><div class="line"><span class="function">ElevatorStage <span class="title">EleDecide</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯动作</span></div><div class="line">	<span class="keyword">int</span> Above,Below;</div><div class="line">	Above=RequireAbove(E);</div><div class="line">	Below=RequireBelow(E);</div><div class="line">	<span class="comment">//无请求则停止</span></div><div class="line">	<span class="keyword">if</span>(Above==<span class="number">0</span>&amp;&amp;Below==<span class="number">0</span>) <span class="keyword">return</span> Stop;</div><div class="line">	<span class="comment">//有请求则按请求移动</span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span>(E.Stage==Up) &#123;</div><div class="line">			<span class="keyword">if</span>(Above!=<span class="number">0</span>) <span class="keyword">return</span> Up;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				E.Stage=Down;<span class="keyword">return</span> Down;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span>(Below!=<span class="number">0</span>) <span class="keyword">return</span> Down;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				E.Stage=Up;<span class="keyword">return</span> Up;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function">Action <span class="title">ElevatorRun</span><span class="params">(Elevator &amp;E)</span></span>&#123;</div><div class="line">	<span class="comment">//电梯状态转换</span></div><div class="line">	<span class="keyword">switch</span>(E.status) &#123;</div><div class="line">		<span class="keyword">case</span> Opening:</div><div class="line">			<span class="comment">//完成开门则转入Opened状态</span></div><div class="line">			E.status=Opened;E.Count=CloseTestTime;</div><div class="line">			<span class="keyword">return</span> DoorOpened;</div><div class="line">		<span class="keyword">case</span> Opened:</div><div class="line">			<span class="comment">//进行关门测试</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Down&amp;&amp;!E.CallCar[E.<span class="built_in">floor</span>]&amp;&amp;!E.CallDown[E.<span class="built_in">floor</span>]||</div><div class="line">				E.Stage==Up&amp;&amp;!E.CallCar[E.<span class="built_in">floor</span>]&amp;&amp;!E.CallUp[E.<span class="built_in">floor</span>]) &#123;<span class="comment">//无人进出，关门</span></div><div class="line">				E.status=Closing;E.Count=DoorTime;</div><div class="line">			&#125;<span class="comment">//if</span></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Closing:</div><div class="line">			<span class="comment">//完成关门则转入Closed状态</span></div><div class="line">			E.status=Closed;</div><div class="line">			<span class="keyword">return</span> DoorClosed;</div><div class="line">		<span class="keyword">case</span> Idle:</div><div class="line">			<span class="comment">//不在第一层且超出所规定的停候时间,电梯向第一层移动</span></div><div class="line">			<span class="keyword">if</span>(E.Count==<span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">if</span>(E.<span class="built_in">floor</span>!=<span class="number">1</span>) E.CallCar[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> E.Count--;</div><div class="line">			<span class="comment">//如果有人可以进入，则开门</span></div><div class="line">			<span class="keyword">if</span>(EleOpenDoor(E)) &#123;</div><div class="line">				E.status=Opening;E.Count=DoorTime;<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">case</span> Closed:</div><div class="line">			<span class="comment">//根据EleDecide的返回值设定电梯状态</span></div><div class="line">			<span class="keyword">switch</span>(EleDecide(E)) &#123;</div><div class="line">				<span class="keyword">case</span> Up: E.status=Moving;E.Count=UpTime+Accelerate;<span class="keyword">return</span> GoingUp;</div><div class="line">				<span class="keyword">case</span> Down: E.status=Moving;E.Count=DownTime+Accelerate;<span class="keyword">return</span> GoingDown;</div><div class="line">				<span class="keyword">case</span> Stop:<span class="keyword">if</span>(E.status!=Idle) &#123;E.status=Idle;E.Count=OverTime;&#125;</div><div class="line">			&#125;;<span class="comment">//switch</span></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Moving:</div><div class="line">			<span class="comment">//完成移动</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Up) E.<span class="built_in">floor</span>++;</div><div class="line">			<span class="keyword">else</span>			E.<span class="built_in">floor</span>--;</div><div class="line">			<span class="keyword">if</span>(EleAchieved(E)) &#123;<span class="comment">//到达目标层，转入减速状态</span></div><div class="line">				E.status=Decelerate;</div><div class="line">				E.Count=DownDecelerate;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> E.Count+=DownTime;<span class="comment">//未到达目标层，继续下降</span></div><div class="line">			<span class="keyword">return</span> Achieved;</div><div class="line">		<span class="keyword">case</span> Decelerate:</div><div class="line">			<span class="comment">//完成减速</span></div><div class="line">			<span class="comment">//确定正确的电梯时期</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Up&amp;&amp;!E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;!RequireAbove(E)) E.Stage=Down;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(E.Stage==Down&amp;&amp;!E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;!RequireBelow(E)) E.Stage=Up;</div><div class="line">			<span class="comment">//转到开门状态</span></div><div class="line">			E.status=Opening;E.Count=DoorTime;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;;<span class="comment">//switch</span></div><div class="line">	<span class="keyword">return</span> None;</div><div class="line">&#125;<span class="comment">//ElevatorRun</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOut</span><span class="params">(Elevator &amp;E,Queue w[Maxfloor+<span class="number">1</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//进行乘客的进出电梯活动</span></div><div class="line">	<span class="comment">//注意：电梯时期要正确，否则乘客无法进入。</span></div><div class="line">	Client *p;</div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]) <span class="comment">//人要从电梯中走出</span></div><div class="line">		<span class="keyword">if</span>(StackEmpty(E.S[E.<span class="built_in">floor</span>])) E.CallCar[E.<span class="built_in">floor</span>]=<span class="number">0</span>;</div><div class="line">		<span class="keyword">else</span> &#123;<span class="comment">//当前层的乘客栈非空，出电梯</span></div><div class="line">			Pop(E.S[E.<span class="built_in">floor</span>],p);E.ClientNumber--;</div><div class="line">			InOutCount=InOutTime;</div><div class="line">			PrintClientInfo(*p,Out);</div><div class="line">			TotalTime+=Time-CInTime(*p);</div><div class="line">			DestoryClient(p);</div><div class="line">		&#125;<span class="comment">//else</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]==<span class="number">0</span>) <span class="comment">//有人要走入电梯</span></div><div class="line">		<span class="keyword">if</span>(!QueueEmpty(w[E.<span class="built_in">floor</span>][E.Stage])) &#123;<span class="comment">//若队列不空，继续进电梯</span></div><div class="line">			DeQueue(w[E.<span class="built_in">floor</span>][E.Stage],p);</div><div class="line">			Push(E.S[COutfloor(*p)],p);</div><div class="line">			<span class="keyword">if</span>(E.CallCar[COutfloor(*p)]!=<span class="number">1</span>) &#123;</div><div class="line">				<span class="comment">//按下要去楼层的按钮</span></div><div class="line">				E.CallCar[COutfloor(*p)]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			E.ClientNumber++;</div><div class="line">			InOutCount=InOutTime;</div><div class="line">			PrintClientInfo(*p,In);</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">		<span class="keyword">else</span> &#123;<span class="comment">//乘客的进出活动已完成</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Down) E.CallDown[E.<span class="built_in">floor</span>]=<span class="number">0</span>;<span class="comment">//将相应的下降按钮取消</span></div><div class="line">			<span class="keyword">else</span> E.CallUp[E.<span class="built_in">floor</span>]=<span class="number">0</span>;<span class="comment">//将相应的上升按钮取消</span></div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewClient</span><span class="params">(Elevator &amp;E,Queue w[<span class="number">5</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//进入新乘客</span></div><div class="line">	Client *p;</div><div class="line">	CreatClient(p);<span class="comment">//新的乘客</span></div><div class="line">	<span class="comment">//将该乘客插入相应队列并按下相应按钮(Up/Down)</span></div><div class="line">	<span class="keyword">if</span>(GoAbove(*p)) &#123;</div><div class="line">		EnQueue(w[CInfloor(*p)][Up],p);E.CallUp[CInfloor(*p)]=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		EnQueue(w[CInfloor(*p)][Down],p);E.CallDown[CInfloor(*p)]=<span class="number">1</span>;</div><div class="line">	&#125;<span class="comment">//else</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**********************************************************/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStatus</span><span class="params">(Elevator &amp;E,Queue w[<span class="number">5</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//输出当前状态</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Maxfloor;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;i&lt;&lt;<span class="string">"层"</span>;</div><div class="line">		<span class="keyword">if</span>(i==Maxfloor) <span class="built_in">cout</span>&lt;&lt;<span class="string">"↓"</span>;</div><div class="line">		<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="string">"↑"</span>;</div><div class="line">		<span class="keyword">if</span>(i==Maxfloor) &#123;</div><div class="line">			PrintQueue(w[i][Down]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</div><div class="line">			PrintQueue(w[i][Up]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i!=Maxfloor&amp;&amp;i!=<span class="number">0</span>) &#123;</div><div class="line">			PrintQueue(w[i][Up]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"      ↓"</span>;</div><div class="line">			PrintQueue(w[i][Down]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Elevator &amp;E,Action a)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出电梯动作信息</span></div><div class="line">	<span class="keyword">switch</span>(a) &#123;</div><div class="line">		<span class="keyword">case</span> DoorOpened:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯门已打开"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> DoorClosed:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯门已关闭"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Achieved:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯已到达第"</span>&lt;&lt;E.<span class="built_in">floor</span>&lt;&lt;<span class="string">"层。"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GoingUp:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯上升中..."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GoingDown:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯下降中..."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">	&#125;;<span class="comment">//switch</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	Elevator E;<span class="comment">//电梯</span></div><div class="line">	Queue	w[Maxfloor+<span class="number">1</span>][<span class="number">2</span>];<span class="comment">//每层都有两个等待队列：上楼队列和下楼队列</span></div><div class="line">	<span class="comment">//初始化</span></div><div class="line">	InitEle(E);</div><div class="line">	srand( (<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span> ));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		InitQueue(w[i][Up]);</div><div class="line">		InitQueue(w[i][Down]);</div><div class="line">	&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> test</span></div><div class="line">	MaxTime=<span class="number">10000</span>;<span class="comment">//12099999</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入电梯的运行时间："</span>;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;MaxTime;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="keyword">while</span>(Time++&lt;MaxTime) &#123;</div><div class="line">		<span class="comment">//---------------乘客事件----------------</span></div><div class="line">		<span class="comment">//新乘客进入事件</span></div><div class="line">		<span class="keyword">if</span>(InterTime==<span class="number">0</span>) NewClient(E,w);</div><div class="line">		<span class="keyword">else</span> InterTime--;</div><div class="line">		<span class="comment">//乘客放弃事件放弃</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</div><div class="line">				CGiveUp(w[i][j],EleFloor(E));</div><div class="line">			&#125;</div><div class="line">		<span class="comment">//乘客进出事件</span></div><div class="line">		<span class="keyword">if</span>(InOutCount==<span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(EleStatus(E)==Opened) InOut(E,w);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> InOutCount--;</div><div class="line">		<span class="comment">//---------------电梯事件----------------</span></div><div class="line">		<span class="keyword">if</span>(CountOver(E)||EleStatus(E)==Closed||EleStatus(E)==Idle) &#123;</div><div class="line">			Action a;</div><div class="line">			a=ElevatorRun(E);</div><div class="line"></div><div class="line">			Print(E,a);</div><div class="line">			<span class="keyword">if</span>(EleStatus(E)==Decelerate) PrintStatus(E,w);</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Sleep(<span class="number">100</span>);<span class="comment">//延迟0.1s</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"共"</span>&lt;&lt;ID&lt;&lt;<span class="string">"人进入系统，"</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"共"</span>&lt;&lt;GiveUpNumber&lt;&lt;<span class="string">"人放弃。"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"平均等待时间为："</span>&lt;&lt;TotalTime/(ID)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	DestoryEle(E);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		DestroyQueue(w[i][Up]);</div><div class="line">		DestroyQueue(w[i][Down]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[银行业务模拟系统]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>-严蔚敏数据结构-银行业务模拟系统的实现<br><a id="more"></a><br>1.需求分析<br>1.1输入的形式<br>输入的元素为整型类型；<br>输入的银行初始存款必须大于0；<br>输入的银行营业时间必须大于0且必须小于1440（一天）；<br>输入的最大到达时间间隔必须大于0且必须小于银行营业时间；<br>输入的最小到达时间间隔必须大于0且必须小于最大到达时间间隔；<br>输入的最大处理时间必须大于0且必须小于银行营业时间；<br>输入的最小处理时间必须大于0且必须小于最大处理时间；<br>输入的交易额的最大上线必须大于0且必须小于银行初始存款且必须小于50000；<br>1.2输出的形式<br>输出的形式为以列表的形式输出事件处理序列；<br>并在列表输出完后输出需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。<br>1.3程序功能<br>实现银行业务的事件驱动模拟系统，通过模拟方法求出客户在银行内逗留的平均时间。<br>1.4测试<br>测试数据由程序用户手动输入，此处对于正确输入和错误输入给出样例。<br>(1)错误的输入<br><img src="http://img.blog.csdn.net/20180114155033297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155050944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155058083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155106109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(2)正确的输入<br><img src="http://img.blog.csdn.net/20180114155125026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(3)对应的输出结果<br><img src="http://img.blog.csdn.net/20180114155138754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>2.概要设计<br>2.1数据类型<br>本设计中用到的数据结构ADT定义如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ADT <span class="built_in">Queue</span>&#123;</div><div class="line">    数据对象：D＝&#123; ai | ai∈ElemSet, i=<span class="number">1</span>,<span class="number">2</span>,<span class="params">...</span>,n,  n≥<span class="number">0</span> &#125;</div><div class="line">    数据关系：R1＝&#123; &lt;ai<span class="number">-1</span>, ai&gt;|ai<span class="number">-1</span>, ai∈D, i=<span class="number">2</span>,<span class="params">...</span>,n &#125;</div><div class="line">    基本操作：</div><div class="line"><span class="literal">void</span> InitQueue(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">操作结果：构造空队列Q</div><div class="line">CustNode *Queuefront(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：返回队首元素</div><div class="line">CustNode *Queuerear(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：返回队尾元素</div><div class="line"><span class="literal">void</span> EnQueue(<span class="built_in">Queue</span> &amp;Q,int e);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：插入元素e为Q的新的队尾元素。</div><div class="line"><span class="literal">void</span> DeQueue(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：删除Q的队头元素。</div><div class="line">&#125;ADT <span class="built_in">Queue</span></div></pre></td></tr></table></figure></p>
<p>2.2主程序的流程<br>主程序先是让外部进行测试数据输入，待测试数据输入完后，执行银行业务模拟系统，产生需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</p>
<p>2.3程序模块说明<br><img src="http://img.blog.csdn.net/20180114155223988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>3.详细设计<br>3.1头文件声明<br>为了增强代码可读性，使用头文件来记录各类结构体的声明以及常用变量的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Bank_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _Bank_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*客户结点类型*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustNode</span>&#123;</span>  						</div><div class="line">    <span class="keyword">int</span> num; 							<span class="comment">//客户号  </span></div><div class="line">    <span class="built_in">string</span> Type; 						<span class="comment">//到达或离开  </span></div><div class="line">    <span class="keyword">int</span> BeginTime;						<span class="comment">//到达时间  </span></div><div class="line">    <span class="keyword">int</span> EndTime;						<span class="comment">//离开时间  </span></div><div class="line">    <span class="keyword">int</span> Amount; 						<span class="comment">//正数为存款，负数为取款  </span></div><div class="line">    CustNode *next;					<span class="comment">//指针域  </span></div><div class="line">&#125;;  </div><div class="line"></div><div class="line">Struct Client&#123;</div><div class="line">Int arrivertime;					<span class="comment">//到达时间</span></div><div class="line">Int durtime;						<span class="comment">//逗留时间</span></div><div class="line">Int amount;						<span class="comment">//办理业务金额</span></div><div class="line">Client *next;						<span class="comment">//指针域</span></div><div class="line">&#125;;</div><div class="line">Client pool[MaxNumber];</div><div class="line"></div><div class="line"><span class="comment">/*等待队列类型*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span> 						  </div><div class="line">    CustNode *front;					<span class="comment">//队列头指针  </span></div><div class="line">    CustNode *rear;					<span class="comment">//队列尾指针  </span></div><div class="line">&#125;Queue;  </div><div class="line"></div><div class="line"><span class="comment">/*常用变量定义*/</span></div><div class="line"><span class="keyword">int</span> BankAmount; 						<span class="comment">//初始时银行现存资金总额  </span></div><div class="line"><span class="keyword">int</span> CloseTime; 						<span class="comment">//营业结束时间  </span></div><div class="line"><span class="keyword">int</span> ClientArriveMaxTime; 				<span class="comment">//两个到达事件之间的间隔上限  </span></div><div class="line"><span class="keyword">int</span> ClientArriveMinTime; 				<span class="comment">//两个到达事件之间的间隔下限  </span></div><div class="line"><span class="keyword">int</span> DealMaxTime; 						<span class="comment">//客户之间交易的时间上限  </span></div><div class="line"><span class="keyword">int</span> DealMinTime; 						<span class="comment">//客户之间交易的时间下限  </span></div><div class="line"><span class="keyword">int</span> MaxAmount; 						<span class="comment">//交易额上限  </span></div><div class="line"><span class="keyword">int</span> NeedIn=<span class="number">0</span>;							<span class="comment">//需要存款的人数  </span></div><div class="line"><span class="keyword">int</span> NeedOut=<span class="number">0</span>;						<span class="comment">//需要取款的人数  </span></div><div class="line"><span class="keyword">int</span> SuccessIn=<span class="number">0</span>;						<span class="comment">//成功存款的人数  </span></div><div class="line"><span class="keyword">int</span> SuccessOut=<span class="number">0</span>;						<span class="comment">//成功取款的人数  </span></div><div class="line"><span class="keyword">int</span> CurrentTime=<span class="number">0</span>; 					<span class="comment">//当前时间  </span></div><div class="line"><span class="keyword">int</span> BankAmountTime=<span class="number">0</span>; 				<span class="comment">//客户逗留总时间  </span></div><div class="line"><span class="keyword">int</span> counter=<span class="number">0</span>; 						<span class="comment">//客户总数  </span></div><div class="line"><span class="keyword">int</span> number=<span class="number">1</span>; 						<span class="comment">//初始客户序列号  </span></div><div class="line"><span class="keyword">bool</span> state=<span class="number">1</span>; 							<span class="comment">//用于判断是否有窗口在处理  </span></div><div class="line"><span class="keyword">int</span> DealTime=<span class="number">0</span>;						<span class="comment">//交易时间  </span></div><div class="line"><span class="keyword">int</span> MaxTime=<span class="number">0</span>;						<span class="comment">//最大到达时间  </span></div><div class="line">Queue Event; 							<span class="comment">//事件队列  </span></div><div class="line">Queue Q1; 							<span class="comment">//队列一  </span></div><div class="line">Queue Q2; 							<span class="comment">//队列二 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div></pre></td><td class="code"><pre><div class="line"><span class="number">3.2</span>选做算法</div><div class="line"><span class="number">3.2</span>.<span class="number">1</span>动态分配函数</div><div class="line"><span class="comment">/*出栈，将栈顶元素的下标返回*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Client *p&lt;-栈顶指针</div><div class="line">e的arrivetime&lt;-栈顶元素的arrivertime</div><div class="line">e的durtime&lt;-栈顶元素的durtime</div><div class="line">e的amount&lt;-栈顶元素的amount</div><div class="line">栈顶指针指向下一元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> myMalloc(Stack &amp;S,Client &amp;e)&#123;</div><div class="line">Client *p=S.top;</div><div class="line">e.arrivetime=(*S.top).arrivetime;</div><div class="line">e.durtime=(*S.top).durtime;</div><div class="line">e.amount=(*S.top).amount;</div><div class="line">p-&gt;next=p-&gt;next-&gt;next;</div><div class="line">S.top++;</div><div class="line">p=p-&gt;next；</div><div class="line">&#125;</div><div class="line"><span class="number">3.2</span>.<span class="number">2</span>归还函数</div><div class="line"><span class="comment">/*把该分量入栈*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Client *p&lt;-栈顶指针</div><div class="line">栈底元素的arrivertimee&lt;-e的arrivetime</div><div class="line">栈底元素的durtime&lt;-e的durtime</div><div class="line">栈底元素的amount&lt;-e的amount</div><div class="line">栈底指针指向下一元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> myFree(Stack &amp;S,Client e)&#123;</div><div class="line">Client *p=S.rear;</div><div class="line">(*S.rear).arrivertime=e.arrivetime;</div><div class="line">(*S.rear).durtime=e.durtime;</div><div class="line">(*S.rear).amount=e.amount;</div><div class="line">p-&gt;next=p-&gt;next-&gt;next;</div><div class="line">S.rear++;</div><div class="line">p=p-&gt;next；</div><div class="line">&#125;</div><div class="line"><span class="number">3.3</span>函数算法</div><div class="line"><span class="number">3.3</span>.<span class="number">1</span>创建队列</div><div class="line"><span class="comment">/*初始化操作，建立一个空队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin </div><div class="line">分配存储空间给头结点和尾结点</div><div class="line">IF头结点内存分配失败  </div><div class="line">EXIT</div><div class="line">头结点的指针域&lt;-空 </div><div class="line">End </div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> InitQueue(Queue &amp;Q)&#123;  </div><div class="line">    Q.front=Q.rear=(CustNode*)malloc(sizeof(CustNode));  </div><div class="line">    <span class="keyword">if</span>(!(Q.front))  </div><div class="line">         exit(<span class="number">1</span>);  </div><div class="line">    Q.front-&gt;next=<span class="number">0</span>;  </div><div class="line"> &#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">2</span>入队列</div><div class="line"><span class="comment">/*插入元素e为队列Q的新的队尾元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">分配存储空间给结点p</div><div class="line">结点p的金额置&lt;-e</div><div class="line">结点p的指针域&lt;-空</div><div class="line">IF队列&lt;-空</div><div class="line">Begin</div><div class="line">头指针&lt;-p</div><div class="line">尾指针&lt;-p</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">头指针next域&lt;-p</div><div class="line">尾指针&lt;-尾指针next域</div><div class="line">End</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> EnQueue(Queue &amp;Q,int e)&#123;  </div><div class="line">    CustNode* p=<span class="keyword">new</span> CustNode;  </div><div class="line">    p-&gt;Amount=e;  </div><div class="line">    p-&gt;next=NULL; </div><div class="line">    <span class="keyword">if</span>(Q.front==NULL)&#123;		</div><div class="line">    <span class="regexp">//队列为空，初始化    </span></div><div class="line"><span class="regexp">		Q.front=p;  </span></div><div class="line"><span class="regexp">        Q.rear=p;  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    else&#123; 					  </span></div><div class="line"><span class="regexp">    //</span>队列不为空，插入结点p    </div><div class="line">		Q.rear-&gt;next=p;  </div><div class="line">        Q.rear=Q.rear-&gt;next;  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"><span class="number">3.3</span>.<span class="number">3</span>出队列</div><div class="line"><span class="comment">/*使p中的第一个元素出队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">p&lt;-头指针</div><div class="line">IF p的next域&lt;-空</div><div class="line">Begin</div><div class="line">头指针&lt;-空</div><div class="line">尾指针&lt;-空</div><div class="line">End</div><div class="line">ELSE</div><div class="line">头指针&lt;-头指针的next域</div><div class="line">DELETE p</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> DeQueue(Queue &amp;Q)&#123;  </div><div class="line">    CustNode *p;  </div><div class="line">    p=Q.front;  </div><div class="line">    <span class="keyword">if</span>(Q.front-&gt;next==NULL)		<span class="regexp">//队列只有一个元素  </span></div><div class="line"><span class="regexp">        Q.front=Q.rear=NULL;  </span></div><div class="line"><span class="regexp">    else  						//</span>调整队列头指针 </div><div class="line">        Q.front=Q.front-&gt;next;  </div><div class="line">    <span class="keyword">delete</span> p;  </div><div class="line">&#125;</div><div class="line"><span class="number">3.3</span>.<span class="number">4</span>取队首</div><div class="line"><span class="comment">/*返回队首元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin	</div><div class="line">Return 队首元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *Queuefront(Queue &amp;Q)&#123;  </div><div class="line">    <span class="keyword">return</span> Q.front;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">3.3</span>.<span class="number">5</span>取队尾  </div><div class="line"><span class="comment">/*返回队尾元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Return 队尾元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *Queuerear(Queue &amp;Q)&#123;  </div><div class="line">    <span class="keyword">return</span> Q.rear;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">6</span>处理客户到达事件</div><div class="line"><span class="comment">/*随机产生顾客，进入队列一产生到达事件 进入事件队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">调用EnQueue(Q1,随机数）</div><div class="line">Q1尾结点的BeginTime&lt;-CurrentTime</div><div class="line">Q1尾结点的num&lt;-number</div><div class="line">EnQueue(Event,尾结点的金额)</div><div class="line">Event尾结点的BeginTime&lt;-CurrentTime</div><div class="line">Event尾结点的Type&lt;-到达</div><div class="line">Event尾结点的num&lt;-number</div><div class="line">number&lt;-number+<span class="number">1</span></div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> ClientArrive()&#123;  </div><div class="line">    EnQueue(Q1,(rand()%(<span class="number">2</span>*MaxAmount)-MaxAmount));  	<span class="regexp">//随机产生顾客加入第一队列  </span></div><div class="line"><span class="regexp">    Queuerear(Q1)-&gt;BeginTime=CurrentTime;				//</span>当前时间为客户的到达时间  </div><div class="line">    Queuerear<span class="function"><span class="params">(Q1)</span>-&gt;</span>num=number;						<span class="regexp">//客户号为客户序列号  </span></div><div class="line"><span class="regexp">    EnQueue(Event,(Queuerear(Q1)-&gt;Amount)); 			//</span>将产生事件加入事件队列  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>BeginTime=CurrentTime;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"到达"</span>;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=number;  </div><div class="line">    number++;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">7</span>存款</div><div class="line"><span class="comment">/*对客户存款事件进行处理*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">BankAmount&lt;-BankAmount+Q1头结点的Amount</div><div class="line">调用EnQueue(Event,Q1头结点的Amount)</div><div class="line">Event尾结点的Type&lt;-离开</div><div class="line">Event尾结点的num&lt;-Q1头结点的num</div><div class="line">Event尾结点的EndTime&lt;-Q1头结点的BeginTime+随机处理时间</div><div class="line">counter&lt;-counter+<span class="number">1</span></div><div class="line">BankAmountTime&lt;-BankAmountTime+Event尾结点的EndTime-Q1头结点的BeginTime</div><div class="line">调用DeQueue(Q1)</div><div class="line">DealTime&lt;-Event尾结点的EndTime</div><div class="line">state&lt;-<span class="number">0</span></div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> InAmount()&#123;</div><div class="line">    BankAmount+=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>Amount; 			<span class="regexp">//更新资金总额  </span></div><div class="line"><span class="regexp">    EnQueue(Event,Queuefront(Q1)-&gt;Amount); 		//</span>加入事件队列   </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>num;  </div><div class="line">    <span class="regexp">//离开时间为到达时间加上随机产生的介于最大处理时间和最小处理时间的处理时间 Queuerear(Event)-&gt;EndTime=(Queuefront(Q1)-&gt;BeginTime+rand()%(DealMaxTime-DealMinTime +1)+DealMinTime);  </span></div><div class="line"><span class="regexp">    counter++; 									//</span>更新客户总数  </div><div class="line">BankAmountTime+=<span class="function"><span class="params">(Queuerear(Event)-&gt;EndTime-Queuefront(Q1)-&gt;BeginTime)</span>; 	</span></div><div class="line"><span class="function">//更新逗留时间  </span></div><div class="line"><span class="function">    <span class="title">DeQueue</span><span class="params">(Q1)</span>; 								//删除第一队列第一个业务  </span></div><div class="line"><span class="function">    <span class="title">DealTime</span>=<span class="title">Queuerear</span><span class="params">(Event)</span>-&gt;</span>EndTime;			<span class="regexp">//交易时间为客户的离开时间  </span></div><div class="line"><span class="regexp">    state=0;										//</span>窗口没有交易需要处理  </div><div class="line">&#125; </div><div class="line"><span class="number">3.3</span>.<span class="number">8</span>取款或借款</div><div class="line"><span class="comment">/*对客户取款或借款事件进行处理*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">IF -Q1头结点的Amount&gt;BankAmount</div><div class="line">Begin</div><div class="line">调用EnQueue(Q2,Q1头结点的Amount)</div><div class="line">Q2尾结点的BeginTime&lt;-Q1头结点的BeginTime</div><div class="line">Q2尾结点的num&lt;-Q1头结点的num</div><div class="line">调用DeQueue(Q1)</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">BankAmount&lt;-BankAmount+Q1尾结点的Amount</div><div class="line">调用EnQueue(Event,Q1头结点的Amount)</div><div class="line">Event尾结点的Type&lt;-离开</div><div class="line">Event尾结点的num&lt;-Q1头结点的num</div><div class="line">Event尾结点的EndTime&lt;-Q1头结点的BeginTime+随机处理时间</div><div class="line">DealTime&lt;-Event尾结点的EndTime</div><div class="line">counter&lt;-counter+<span class="number">1</span></div><div class="line">BankAmountTime&lt;-Event尾结点的EndTime-Q1尾结点的BeginTime</div><div class="line">调用DeQueue(Q1)</div><div class="line">State&lt;-<span class="number">0</span></div><div class="line">End</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> OutAmount()&#123;   </div><div class="line">    <span class="keyword">if</span>((-Q1.front-&gt;Amount)&gt;BankAmount)&#123;		   </div><div class="line">    <span class="regexp">//资金短缺 加入第二队列  </span></div><div class="line"><span class="regexp">        EnQueue(Q2,Queuefront(Q1)-&gt;Amount);  </span></div><div class="line"><span class="regexp">        Queuerear(Q2)-&gt;BeginTime=Queuefront(Q1)-&gt;BeginTime;  </span></div><div class="line"><span class="regexp">        Queuerear(Q2)-&gt;num=Queuefront(Q1)-&gt;num;  </span></div><div class="line"><span class="regexp">        DeQueue(Q1);  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    else&#123;  </span></div><div class="line"><span class="regexp">        BankAmount+=Queuerear(Q1)-&gt;Amount;			//</span>更新资金总额  </div><div class="line">        EnQueue<span class="function"><span class="params">(Event,Queuefront(Q1)-&gt;Amount)</span>; 		//加入事件队列   </span></div><div class="line"><span class="function">        <span class="title">Queuerear</span><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>num;  </div><div class="line">        <span class="regexp">//客户的离开时间为客户的到达时间加上随机产生的介于最大处理时间和最小处理时间的处理时间</span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;EndTime=(Queuefront(Q1)-&gt;BeginTime +rand()%(DealMaxTime-DealMinTime +1)+DealMinTime);  </span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;BeginTime=0;  </span></div><div class="line"><span class="regexp">        DealTime=Queuerear(Event)-&gt;EndTime;			//</span>交易时间为客户的离开时间  </div><div class="line">        counter++; 									<span class="regexp">//更新客户总数   </span></div><div class="line"><span class="regexp">        BankAmountTime+=(Queuerear(Event)-&gt;EndTime-Queuerear(Q1)-&gt;BeginTime); 	</span></div><div class="line"><span class="regexp">//</span>更新逗留时间  </div><div class="line">        DeQueue(Q1); 								<span class="regexp">//删除第一队列第一个业务  </span></div><div class="line"><span class="regexp">        state=0;										//</span>窗口没有交易需要处理  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">9</span>检查队列Q2</div><div class="line"><span class="comment">/*顺序检查队列Q2中是否有可以处理的事件元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin </div><div class="line">sign&lt;-Q头结点</div><div class="line">CustNode *temp</div><div class="line">While Q头结点为空</div><div class="line">Begin</div><div class="line">IF -Q头结点的Amount&lt;m</div><div class="line">Begin</div><div class="line">IF Q为空</div><div class="line">Begin</div><div class="line">temp&lt;-Q头结点</div><div class="line">Q头结点&lt;-空</div><div class="line">Q尾结点&lt;-空</div><div class="line">Return temp</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">temp&lt;-Q头结点</div><div class="line">Q头结点&lt;-Q头结点的next域</div><div class="line">Return temp</div><div class="line">End</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">IF Q不为空</div><div class="line">Begin</div><div class="line">Q尾结点的next域&lt;-Q头结点</div><div class="line">Q尾结点&lt;-Q尾结点的next域</div><div class="line">Q头结点&lt;-Q头结点的next域</div><div class="line">Q尾结点的next域&lt;-空</div><div class="line">End</div><div class="line">End</div><div class="line">IF Q头结点等于sign</div><div class="line">Return 空</div><div class="line">End</div><div class="line">Return 空</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *SearchQ2(Queue &amp;Q,int m)&#123;   </div><div class="line">    CustNode *sign=Q.front; 				<span class="regexp">//标记头节点  </span></div><div class="line"><span class="regexp">    CustNode *temp;  </span></div><div class="line"><span class="regexp">    while(Q.front!=NULL)&#123;  </span></div><div class="line"><span class="regexp">        if((-(Q.front-&gt;Amount))&lt;m)&#123;			//</span>队首元素可以处理  </div><div class="line">            <span class="keyword">if</span>(Q.front==Q.rear)&#123;  </div><div class="line">                temp=Q.front;  </div><div class="line">                Q.front=Q.rear=NULL;  </div><div class="line">                <span class="keyword">return</span> temp;  </div><div class="line">            &#125;  </div><div class="line">        	<span class="keyword">else</span>&#123;							<span class="regexp">//队首元素出列  </span></div><div class="line"><span class="regexp">            	temp=Q.front;   </span></div><div class="line"><span class="regexp">            	Q.front=Q.front-&gt;next; 		//</span> 首节点后移一位,返回原首节点  </div><div class="line">            	<span class="keyword">return</span> temp;  </div><div class="line">        	&#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>&#123;								<span class="regexp">//队首元首不能被处理  </span></div><div class="line"><span class="regexp">            if(Q.front==Q.rear)&#123;</span></div><div class="line"><span class="regexp">			&#125;  </span></div><div class="line"><span class="regexp">            else&#123;							//</span>首节点移到队列尾部  </div><div class="line">              </div><div class="line">            	Q.rear-&gt;next=Q.front;   </div><div class="line">                Q.rear=Q.rear-&gt;next;  </div><div class="line">                Q.front=Q.front-&gt;next;  </div><div class="line">                Q.rear-&gt;next=NULL;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(Q.front==sign)					<span class="regexp">//队列循环一周时停止  </span></div><div class="line"><span class="regexp">            return NULL;  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    return NULL;  </span></div><div class="line"><span class="regexp">&#125;  </span></div><div class="line"><span class="regexp">3.3.10处理队列Q2</span></div><div class="line"><span class="regexp">/*对于队列Q2中可以处理的事件元素进行处理*/</span></div><div class="line"><span class="regexp">伪码表示：</span></div><div class="line"><span class="regexp">Begin</span></div><div class="line"><span class="regexp">CustNode* temped  </span></div><div class="line"><span class="regexp">	int RandomTemp</span></div><div class="line"><span class="regexp">While temped&lt;-调用SearchQ2(Q2,BankAmount)并且temped不为空</span></div><div class="line"><span class="regexp">Begin</span></div><div class="line"><span class="regexp">BankAmount&lt;-temped的Amount+BankAmount</span></div><div class="line"><span class="regexp">EnQueue(Event,temped的Amount</span></div><div class="line"><span class="regexp">Event尾结点的Type&lt;-离开</span></div><div class="line"><span class="regexp">Event尾结点的num&lt;-temped的num</span></div><div class="line"><span class="regexp">RandomTemp&lt;-随机处理时间</span></div><div class="line"><span class="regexp">Event尾结点的EndTime&lt;-CurrentTime+RandomTemp</span></div><div class="line"><span class="regexp">DealTime&lt;-DealTime+RandomTemp</span></div><div class="line"><span class="regexp">counter&lt;-counter+1</span></div><div class="line"><span class="regexp">BankAmountTime&lt;-Event尾结点的EndTime-temped的BeginTime+BankAmount</span></div><div class="line"><span class="regexp">删除 temped</span></div><div class="line"><span class="regexp">temped&lt;-空</span></div><div class="line"><span class="regexp">End</span></div><div class="line"><span class="regexp">state&lt;-0</span></div><div class="line"><span class="regexp">End</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">代码表示：</span></div><div class="line"><span class="regexp">void DealQ2()&#123; </span></div><div class="line"><span class="regexp">   	CustNode* temped;  </span></div><div class="line"><span class="regexp">	int randomTemp;</span></div><div class="line"><span class="regexp">    while((temped=SearchQ2(Q2,BankAmount))&amp;&amp;temped!=NULL)&#123; 	//</span>查找可处理取款  </div><div class="line">      </div><div class="line">        BankAmount+=temped-&gt;Amount; 						<span class="regexp">//更新资金总额  </span></div><div class="line"><span class="regexp">        EnQueue(Event,temped-&gt;Amount); 						//</span>加入事件队列   </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=temped-&gt;num;  </div><div class="line">        RandomTemp=rand()%(DealMaxTime-DealMinTime +<span class="number">1</span>)+DealMinTime;		</div><div class="line"><span class="regexp">//处理时间为随机产生的介于最大处理时间和最小处理时间之间的处理时间  </span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;EndTime=CurrentTime+randomTemp ;					</span></div><div class="line"><span class="regexp">//</span>客户离开时间为当前时间加上处理时间  </div><div class="line">        DealTime+=randomTemp;								<span class="regexp">//更新交易时间  </span></div><div class="line"><span class="regexp">        counter++; 											//</span>更新客户总数  </div><div class="line">        BankAmountTime+=<span class="function"><span class="params">(Queuerear(Event)-&gt;EndTime-temped-&gt;BeginTime)</span>; 		</span></div><div class="line"><span class="function">//更新逗留时间   </span></div><div class="line"><span class="function">        <span class="title">delete</span> <span class="title">temped</span>; 										//删除节点  </span></div><div class="line"><span class="function">        <span class="title">temped</span> = <span class="title">NULL</span>;  </span></div><div class="line"><span class="function">    &#125;  </span></div><div class="line"><span class="function">    <span class="title">state</span> = 0;  </span></div><div class="line"><span class="function">&#125;  </span></div><div class="line"><span class="function">3.3.11银行业务模拟系统界面</span></div><div class="line"><span class="function">/*银行业务模拟程序的界面*/</span></div><div class="line"><span class="function">伪码表示：</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出   =========================================================================	  	换行	</span></div><div class="line"><span class="function">输出   =========================================================================		换行	</span></div><div class="line"><span class="function">输出                		<span class="title">Simulation</span> <span class="title">of</span> <span class="title">The</span> <span class="title">Bank</span> <span class="title">business</span>				</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出   				-------------------------------------------------------------------------	    	</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出  						   ---------------------------------                        	</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出                  				<span class="title">Number</span>: 3116004979                               </span></div><div class="line"><span class="function">输出	              			     <span class="title">CLASS</span> ：16网络二班                          	</span></div><div class="line"><span class="function">输出                          		 <span class="title">NAME</span>  ： 詹泽霖                        	</span></div><div class="line"><span class="function">输出   =========================================================================		换行</span></div><div class="line"><span class="function">输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行  </span></div><div class="line"><span class="function">    	输出   *************************************************************************		换行  </span></div><div class="line"><span class="function">    	输出   *******************                               ***********************		换行</span></div><div class="line"><span class="function">	输出   *******************    0.退出   1.进入模拟系统    ***********************		</span></div><div class="line"><span class="function">换行   </span></div><div class="line"><span class="function">    	输出   *******************                               ***********************		换行 </span></div><div class="line"><span class="function"> 	输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行   </span></div><div class="line"><span class="function">    	输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行  </span></div><div class="line"><span class="function">    	输出   ************************      请选择服务      ***************************		换行</span></div><div class="line"><span class="function">输出   =========================================================================		换行</span></div><div class="line"><span class="function">  <span class="title">End</span>  		</span></div><div class="line"><span class="function">代码表示：</span></div><div class="line"><span class="function"><span class="title">void</span> <span class="title">BankOutLook</span><span class="params">()</span>&#123;       </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================		\n"</span>)</span>;</span></div><div class="line"><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================		\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"                       	Simulation of The Bank business							\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   			-------------------------------------------------------------------------	   				    \n\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                              ---------------------------------                        				\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                    	          Number: 3116004979                               			\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                    	         CLASS ：16网络二班                               			\n"</span>)</span>;</span></div><div class="line"><span class="function">   	<span class="title">printf</span><span class="params">(<span class="string">"                    	          NAME  ：  詹泽霖                                      		\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"                              ---------------------------------                         				\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================      	\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************	      					\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *******************                               **************							\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"   *******************    0.退出   1.进入模拟系统    ***************							\n"</span>)</span>;   </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *******************                               **************							\n"</span>)</span>; </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   ************************      请选择服务      *********************							\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">" =========================================================================        	\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   请输入选择的操作对应编号："</span>)</span>; </span></div><div class="line"><span class="function">&#125;  </span></div><div class="line"><span class="function">3.4主程序</span></div><div class="line"><span class="function">通过对以上定义过的函数接口的调用，利用主函数来构建一个银行模拟系统，以列表的形式输出事件处理序列；</span></div><div class="line"><span class="function">并在列表输出完后输出需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</span></div><div class="line"><span class="function">3.4.1伪码表示</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">调整界面为黑字白背景</span></div><div class="line"><span class="function">调用<span class="title">BankOutLook</span><span class="params">()</span></span></div><div class="line"><span class="function">输入操作编号</span></div><div class="line"><span class="function"><span class="title">While</span> 操作编号等于1</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">初始化随机函数</span></div><div class="line"><span class="function">输出 请输入银行的初始存款</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行初始存款&lt;0</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，重新输入</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行初始存款&lt;0</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，重新输入</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span>银行初始存款&lt;0</span></div><div class="line"><span class="function">输出 三次输入错误，退出</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入银行的营业时间</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大到达时间间隔</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小到达时间间隔</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大交易时间</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小交易时间</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小交易时间</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大交易额</span></div><div class="line"><span class="function">输入 最大交易额</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易额</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">MaxTime</span>&lt;-<span class="title">MaxTime</span>+随机到达间隔</span></div><div class="line"><span class="function"><span class="title">While</span> <span class="title">CurrentTime</span>&lt;<span class="title">CloseTime</span></span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function"><span class="title">CurrentTime</span>&lt;-<span class="title">CurrentTime</span>+1 </span></div><div class="line"><span class="function"><span class="title">If</span> <span class="title">DealTime</span>&lt;<span class="title">CurrentTime</span> </span></div><div class="line"><span class="function">	<span class="title">DealTime</span>&lt;-<span class="title">CurrentTime</span>   </span></div><div class="line"><span class="function"><span class="title">If</span> <span class="title">DealTime</span>等于<span class="title">CurrentTime</span> 						</span></div><div class="line"><span class="function">	<span class="title">State</span>&lt;-1</span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">CurrentTime</span>等于<span class="title">MaxTime</span>)							</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">        调用<span class="title">ClientArrive</span><span class="params">()</span> 			</span></div><div class="line"><span class="function"><span class="title">MaxTime</span>&lt;-<span class="title">MaxTime</span>+随机到达间隔+<span class="title">ClientArriveMinTime</span>  </span></div><div class="line"><span class="function"><span class="title">End</span>  </span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">state</span>等于1&amp;&amp;<span class="title">Q1</span>头指针不等于<span class="title">NULL</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">    <span class="title">IF</span> <span class="title">Q1</span>头结点的<span class="title">Amount</span>大于等于 0</span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">        调用<span class="title">InAmount</span><span class="params">()</span>						 </span></div><div class="line"><span class="function">        调用<span class="title">DealQ2</span><span class="params">()</span>							</span></div><div class="line"><span class="function">        <span class="title">NeedIn</span>&lt;-<span class="title">NeedIn</span>+1  </span></div><div class="line"><span class="function">    <span class="title">End</span></span></div><div class="line"><span class="function">    <span class="title">ElSe</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>               </span></div><div class="line"><span class="function">调用<span class="title">InAmount</span><span class="params">()</span>					</span></div><div class="line"><span class="function"> 	<span class="title">NeedIn</span>&lt;-<span class="title">NeedIn</span>+1  </span></div><div class="line"><span class="function">   	<span class="title">End</span>  </span></div><div class="line"><span class="function"><span class="title">End</span>   </span></div><div class="line"><span class="function"><span class="title">End</span> </span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出     客户序列	换列	事件类型	换列	处理金额	换行</span></div><div class="line"><span class="function"><span class="title">While</span> <span class="title">Event</span>头结点不为空</span></div><div class="line"><span class="function"><span class="title">Begin</span> 					            </span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Type</span>等于 "离开"</span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">         输出 换列	<span class="title">Event</span>头结点的<span class="title">num</span>	换列	离开	<span class="title">Event</span>头结点的<span class="title">EndTime</span>		换列	<span class="title">Event</span>头结点的<span class="title">Amount</span> 	换行 </span></div><div class="line"><span class="function">          <span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Amount</span>大于等于0     			</span></div><div class="line"><span class="function">				<span class="title">t1</span>&lt;-<span class="title">t1</span>+1			  </span></div><div class="line"><span class="function">          <span class="title">Else</span>                     	</span></div><div class="line"><span class="function">				<span class="title">t3</span>&lt;-<span class="title">t3</span>+1				  </span></div><div class="line"><span class="function">    <span class="title">End</span>  </span></div><div class="line"><span class="function">    <span class="title">Else</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">    	输出 换列	<span class="title">Event</span>头结点的<span class="title">num</span>	换列	到达	<span class="title">Event</span>头结点的<span class="title">EndTime</span>		换列	<span class="title">Event</span>头结点的<span class="title">Amount</span> 	换行 </span></div><div class="line"><span class="function">        <span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Amount</span>大于等于0     			</span></div><div class="line"><span class="function">			<span class="title">t2</span>&lt;-<span class="title">t2</span>+1			  </span></div><div class="line"><span class="function">        <span class="title">Else</span>                     	</span></div><div class="line"><span class="function">			<span class="title">t4</span>&lt;-<span class="title">t4</span>+1	</span></div><div class="line"><span class="function">            <span class="title">SuccessIn</span>&lt;-<span class="title">NeedIn</span>-<span class="params">(t2-t1)</span> </span></div><div class="line"><span class="function">            <span class="title">SuccessOut</span>&lt;-<span class="title">NeedOut</span>-<span class="params">(t4-t3)</span>  </span></div><div class="line"><span class="function">            调用<span class="title">DeQueue</span><span class="params">(Event)</span></span></div><div class="line"><span class="function">    <span class="title">End</span> </span></div><div class="line"><span class="function">        <span class="title">While</span> <span class="title">Q1</span>的头结点等于<span class="title">NULL</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>								            				<span class="title">BankAmountTime</span>&lt;-<span class="title">BankAmountTime</span>+<span class="params">(CloseTime-Q1头结点的BeginTime)</span>  </span></div><div class="line"><span class="function">            <span class="title">counter</span>&lt;-<span class="title">counter</span>+1;  </span></div><div class="line"><span class="function">            调用<span class="title">DeQueue</span><span class="params">(Q1)</span>;  </span></div><div class="line"><span class="function">        <span class="title">End</span></span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出 需要存款的客户人数</span></div><div class="line"><span class="function">输出 需要取款的客户人数</span></div><div class="line"><span class="function">输出 成功办理存款的客户人数</span></div><div class="line"><span class="function">输出 成功办理取款的客户人数</span></div><div class="line"><span class="function">输出 存款成功办理率</span></div><div class="line"><span class="function">输出 取款成功办理率</span></div><div class="line"><span class="function">输出 客户进入系统平均时间</span></div><div class="line"><span class="function">输出 银行当前余额</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">If</span> 操作数等于0</span></div><div class="line"><span class="function">退出模拟系统</span></div><div class="line"><span class="function"><span class="title">Return</span> 0</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function">3.4.2代码表示</span></div><div class="line"><span class="function"><span class="title">int</span> <span class="title">main</span><span class="params">()</span>&#123; </span></div><div class="line"><span class="function">	<span class="title">system</span><span class="params">(<span class="string">"color 70"</span>)</span>;</span></div><div class="line"><span class="function">    <span class="title">BankOutLook</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">    <span class="title">int</span> <span class="title">n</span>,<span class="title">t1</span>=0,<span class="title">t2</span>=0,<span class="title">t3</span>=0,<span class="title">t4</span>=0,<span class="title">m</span>=0;</span></div><div class="line"><span class="function">    <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;n)</span>;  </span></div><div class="line"><span class="function">    <span class="title">while</span><span class="params">(n==<span class="number">1</span>)</span>&#123;  </span></div><div class="line"><span class="function">        <span class="title">srand</span><span class="params">(time(NULL))</span>; 							//初始化随机函数  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123;                          </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！初始存款不能小于0！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123;       </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！初始存款不能小于0！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123; </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;   </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;                 </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！一天的营业时间不能超过1440分钟（24个小时）！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！一天的营业时间不能超过1440分钟（24个小时）！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;   </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;    </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125; </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;         </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大到达时间间隔必须小于营业时间！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大到达时间间隔必须小于营业时间！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;   </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123;       </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小到达时间间隔必须介于零和最大到达时间之间！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小到达时间间隔必须介于零和最大到达时间之间！请最后一次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123; </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   请按任意键退出!\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;   </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;   </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;           </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大处理时间必须小于营业时间！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">               	<span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大处理时间必须小于营业时间！请最后一次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;     </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span>||DealMinTime&gt;=DealMaxTime)</span>&#123;</span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小处理时间必须介于零和最大处理时间之间！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span>||DealMinTime&gt;=DealMaxTime)</span>&#123;      </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小处理时间必须介于零和最大处理时间之间！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span> || DealMinTime&gt;=DealMaxTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！超出本银行的服务范围！最大交易额应低于银行开始营业时的资金总额且小于50000！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！超出本银行的服务范围！最大交易额应低于银行开始营业时的资金总额且小于50000！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125; </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">MaxTime</span> +=<span class="title">rand</span><span class="params">()</span>%<span class="params">(ClientArriveMaxTime-ClientArriveMinTime+<span class="number">1</span>)</span>+<span class="title">ClientArriveMinTime</span>; </span></div><div class="line"><span class="function">		//随机生成介于最大到达时间间隔和最小到达时间间隔之间的首次到达时间  </span></div><div class="line"><span class="function">          </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(CurrentTime&lt;CloseTime)</span>&#123;					//当前时间小于营业时间  </span></div><div class="line"><span class="function">            <span class="title">CurrentTime</span>++;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealTime&lt;CurrentTime)</span> </span></div><div class="line"><span class="function">				<span class="title">DealTime</span>=<span class="title">CurrentTime</span> ;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealTime==CurrentTime)</span> 					//有窗口在处理交易</span></div><div class="line"><span class="function">				<span class="title">state</span>=1;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(CurrentTime==MaxTime)</span>&#123; 					//到达事件  </span></div><div class="line"><span class="function">                <span class="title">ClientArrive</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                //随机生成介于最大到达时间间隔和最小到达时间间隔之间的到达时间</span></div><div class="line"><span class="function">                <span class="title">MaxTime</span>+=<span class="title">rand</span><span class="params">()</span>%<span class="params">(ClientArriveMaxTime-ClientArriveMinTime+<span class="number">1</span>)</span>+<span class="title">ClientArriveMinTime</span>;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(state==<span class="number">1</span>&amp;&amp;Q1.front!=NULL)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Q1.front-&gt;Amount&gt;= <span class="number">0</span>)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">InAmount</span><span class="params">()</span>;						//调用存款函数  </span></div><div class="line"><span class="function">                    <span class="title">DealQ2</span><span class="params">()</span>;							//调用搜索处理函数  </span></div><div class="line"><span class="function">                    <span class="title">NeedIn</span>++;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">                <span class="title">else</span>&#123;   </span></div><div class="line"><span class="function">                    <span class="title">InAmount</span><span class="params">()</span>;						//调用取款函数  </span></div><div class="line"><span class="function">                    <span class="title">NeedOut</span>++;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"     客户序列\t      事件类型         时间          处理金额\n"</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(Event.front!=NULL)</span>&#123; 						//清除事件队列  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(Event.front-&gt;Type==<span class="string">"离开"</span>)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"\t%d\t\t离开\t\t%d\t\t%d\n"</span>,Event.front-&gt;num, Event.front-&gt;EndTime,Event.front-&gt;Amount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Event.front-&gt;Amount&gt;=<span class="number">0</span>)</span>     			//成功存款人数</span></div><div class="line"><span class="function">					<span class="title">t1</span>++;			  </span></div><div class="line"><span class="function">                <span class="title">else</span>                     			//成功取款人数</span></div><div class="line"><span class="function">					<span class="title">t3</span>++;				  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">else</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"\t%d\t\t到达\t\t%d\t\t%d\n"</span>,Event.front-&gt;num, Event.front-&gt;BeginTime,Event.front-&gt;Amount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Event.front-&gt;Amount&gt;=<span class="number">0</span>)</span>     			//需要存款人数</span></div><div class="line"><span class="function">					<span class="title">t2</span>++;			  </span></div><div class="line"><span class="function">                <span class="title">else</span>                     			//需要取款人数 </span></div><div class="line"><span class="function">					<span class="title">t4</span>++;				 </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">SuccessIn</span>=<span class="title">NeedIn</span>-<span class="params">(t2-t1)</span>;  </span></div><div class="line"><span class="function">            <span class="title">SuccessOut</span>=<span class="title">NeedOut</span>-<span class="params">(t4-t3)</span>;  </span></div><div class="line"><span class="function">            <span class="title">DeQueue</span><span class="params">(Event)</span>;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(Q1.front!=NULL)</span>&#123;					</span></div><div class="line"><span class="function">//更新结束时第一队列中未处理的客户  </span></div><div class="line"><span class="function">            <span class="title">BankAmountTime</span>+=<span class="params">(CloseTime-Q1.front-&gt;BeginTime)</span>;   </span></div><div class="line"><span class="function">            <span class="title">counter</span>++;  </span></div><div class="line"><span class="function">            <span class="title">DeQueue</span><span class="params">(Q1)</span>;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"\n"</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	需要存款的客户人数：%d\n"</span>,NeedIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	需要取款的客户人数：%d\n"</span>,NeedOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	成功办理存款的客户人数：%d\n"</span>,SuccessIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	成功办理取款的客户人数：%d\n"</span>,SuccessOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	存款成功办理率：%f\n"</span>,float(SuccessIn*<span class="number">100</span>)/NeedIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	取款成功办理率：%f\n"</span>,float(SuccessOut*<span class="number">100</span>)/NeedOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	客户逗留平均时间为:%f\n"</span>,float(BankAmountTime)/counter)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	银行当前余额：%d\n"</span>,BankAmount)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">break</span>;  </span></div><div class="line"><span class="function">	&#125;  </span></div><div class="line"><span class="function">	<span class="title">if</span><span class="params">(n==<span class="number">0</span>)</span>   </span></div><div class="line"><span class="function">		<span class="title">printf</span><span class="params">(<span class="string">"请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">	<span class="title">end</span>:<span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">    <span class="title">return</span> 0;  </span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure>
<p>3.5函数调用关系及程序流程<br>以下为程序的大致流程图：<br><img src="http://img.blog.csdn.net/20180114155604536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>函数调用关系图如下：<br><img src="http://img.blog.csdn.net/20180114155723213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4.调试分析<br>4.1调试中遇到的问题<br>调试中遇到的问题不是很多，但遇到的问题在一定程度上让我更加的了解整个程序的运作机理，对于理解数据结构也有很大的帮助。<br>主要的问题在于一开始的时候实现检查Q2队列的接口时，在进行检查后，未再让经过检查却不满足处理的元素重新进入Q2队列，导致最后的元素缺少。经过调试发现了这个问题，对代码进行修正，最终解决了问题。<br>4.2算法分析<br><img src="http://img.blog.csdn.net/20180114155950287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4.3经验体会<br>通过这次的课程设计的编写，学会了在多种数据结构之间进行巧妙的结合运用。同时，对于用到的多种数据结构也有了更多的了解。<br>在测试功能的时候一定要注意选取的测试数据的正确性和实用性。<br>5.用户使用说明<br>在进入银行业务模拟界面时，选择操作编号，0-退出系统，1-进入模拟系统.<br>进入模拟系统后，输入的银行初始存款必须大于0；<br>输入的银行营业时间必须大于0且必须小于1440（一天）；<br>输入的最大到达时间间隔必须大于0且必须小于银行营业时间；<br>输入的最小到达时间间隔必须大于0且必须小于最大到达时间间隔；<br>输入的最大处理时间必须大于0且必须小于银行营业时间；<br>输入的最小处理时间必须大于0且必须小于最大处理时间；<br>输入的交易额的最大上线必须大于0且必须小于银行初始存款且必须小于50000；<br>若输入有误会进行提示，三次错误后退出模拟系统。若输入无误，则开始进行输出，输出事件处理的列表信息，以及需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</p>
<p>6.测试结果<br>6.1输出测试1<br>输入较大的银行初始存款，输入较大的到达时间间隔和较大的处理时间，较小的交易额上限<br><img src="http://img.blog.csdn.net/20180114160021122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由于到达时间间隔和处理时间输入较大，测试数据会比较少，相对于来说，求得的银行业务模拟的客户平均用时等信息可能就没有那么的精确<br><img src="http://img.blog.csdn.net/20180114160101587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>6.2输出测试2</p>
<p>输入较大的银行初始存款，输入较小的到达时间间隔范围，较小的交易额上限<br><img src="http://img.blog.csdn.net/20180114160117632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在较小的到达时间间隔和处理时间的输入下，会得到比前一种情况更多的测试数据输出，在此情况下，样本的容量足够大，对于客户平均用时等信息的统计就可能会更加的精确一些</p>
<p><img src="http://img.blog.csdn.net/20180114160156400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114160211784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114160245673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>6.3输出测试3<br>输入较小的银行初始存款，较大的处理时间和较大的时间间隔，较大的交易金额上限。<br><img src="http://img.blog.csdn.net/20180114160340916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在这样的输出下，对于客户平均用时的影响比较大，且只能产生少量的数据。<br><img src="http://img.blog.csdn.net/20180114160354039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>7.参考文献</p>
<p>参考文献<br>[1]    张小艳，龚尚福编著. 数据结构与算法. 徐州：中国矿业大学出版社，2007<br>[2]    严蔚敏，吴伟民编著. 数据结构(C语言版). 北京： 清华大学出版社，1997<br>[3]    谭浩强编著.  C程序设计(第三版). 北京： 清华大学出版社，2005</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[组合逻辑电路]]></title>
      <url>/2018/01/05/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>组合电路是由各种逻辑门构成的</p>
<p>组合逻辑电路逻辑功能的表示方法：<br>1.逻辑表达式<br>2.真值表<br>3.卡诺图<br>4.逻辑图</p>
<hr>
<p>组合逻辑电路的分析方法：<br>1.根据给定的逻辑电路，写出输出函数的逻辑表达式<br>2.进行表达式的变换与化简，直接利用公式或定理对表达式进行变换，也可通过卡诺图的方法进行化简<br>3.根据表达式列出真值表。真值表能直接反映出输入变量和输出结果之间的逻辑关系，它直观地描述了电路的逻辑功能<br>4.对给定电路的功能进行逻辑描述。根据所得到的表达式和真值表，用文字输出给定电路的逻辑功能，判断功能是否满足设计要求。</p>
<hr>
<p><strong>常用的组合逻辑电路</strong><br>1.二进制普通编码器<br>用n位二进制代码对m=2的n次方个信号进行编码的电路称为二进制编码器。<br>2.BCD普通编码器<br>功能是将十进制数0~9转换为二进制代码<br>3.优先编码器<br>与普通编码器一样，外加优先级设定。<br>4.编码器集成电路<br>74HC148是8-3优先编码器<br>有8个信号输入端，3个编码输出端，还有使能输入端EIN，使能输出端EON，优先级标志输出端GSN。<br>功能：<br>1.EIN为使能输入端，低电平有效。当EIN输入高电平（H信号）时，编码器不工作，所有输出端均输出高电平（H信号）<br>。当EIN输入低电平时，编码器工作。<br>2.编码器工作时，I7优先级最高，I0优先级最低.<br>3.如果编码器工作，输入端均有效，则EON输出高电平,否则输出低电平。<br>4..GSN用于表示是否有编码输出</p>
<hr>
<p><strong>译码器</strong><br>译码是编码的逆过程</p>
<p>1.二进制译码器<br>2.数码显示译码器<br>八字形最上面为a，顺时针分别为bcdef，中间为g</p>
<p>3.译码器集成电路<br>74HC138<br>1.当使能输入端EIN,E2N=0,E3=1，译码器不工作。<br>2.其余情况正常译码</p>
<p>4.集成数码显示译码器<br>74HC4511<br>当使能输入端为LHH时工作，对应输出字形对应的a~g</p>
<hr>
<p><strong>数据选择器</strong><br>4-1数据选择器-74HC153<br>1.输入使能EN=0，选择器工作，否则不工作<br>2.I0-I3数据输入，S0-S1选择输入</p>
<hr>
<p><strong>数值比较器</strong><br>1.4位数值比较器-74HC85<br>当能判断大小时，直接就大小比较进行输出；<br>否则，由级联输入决定输出。</p>
<hr>
<p><strong>加法器</strong><br>1.串行进位加法器<br>2.超前进位加法器<br>3.有符号二进制数加法器<br>有符号加法器利用补码进行运算，符号相异时运算结果正确，符号相同时考虑是否溢出</p>
<hr>
<p>竞争冒险是指当输入信号发生变化后，在输出达到稳定之前，输出端可能出现异常的虚假信号，称为竞争冒险</p>
<p>卡诺图中的圈不相切，则不会有竞争冒险</p>
<p>解决方案：<br>1.选通法<br>2.滤波法<br>3.增加冗余项法</p>
<hr>
]]></content>
      
        <categories>
            
            <category> eda </category>
            
        </categories>
        
        
        <tags>
            
            <tag> eda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数字逻辑基础]]></title>
      <url>/2018/01/05/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>-基本知识<br><a id="more"></a><br><strong>十六进制数</strong><br>十六进制数的特点是：<br>1.由16个数码，0~9和A~F组成<br>2.基数是16，运算规则是逢16进1<br>3.在小数点左边，从右至左的位权依次是：$16^0$,$16^1$,$16^2$……在小数点右边，从左至右的位权依次是：$16^{-1}$,$16^{-2}$,$16^{-3}$,……;</p>
<p><strong>数制转换</strong><br><strong>1.非十进制数转换成十进制数</strong><br>转换方法是：将非十进制数按维权展开后求和<br>(1011.101)<sub>2</sub>=1<em>$2^3$+0</em>$2^2$+1<em>$2^1$+1</em>$2^0$+1<em>$2^{-1}$+0</em>$2^{-2}$+1*$2^{-3}$=11.625</p>
<p>(723.24)<sub>8</sub>=7<em>$8^2$+2</em>$8^1$+3<em>$8^0$+2</em>$8^{-1}$+4*$8^{-2}$=467.3125</p>
<p>(2D9.A8)<sub>16</sub>=2<em>$16^2$+13</em>$16^1$+9<em>$16^0$+10</em>$16^{-1}$+8*$16^{-2}$=729.65625</p>
<p><strong>2.十进制树转换成非十进制数</strong><br>十进制数转换成非十进制数，需要分别对整数部分和小数部分进行转换<br>①整数部分转换方法：不断除以技术取余数直到商为0，从下至上读取余数<br>②小数部分转换方法：不断乘以基数取余数，从上到下读取整数，直到满足精度要求为止<br>(179)<sub>10</sub>=(10110011)<sub>2</sub>=(263)<sub>8</sub>=(B3)<sub>16</sub><br>(0.6875)<sub>10</sub>=(0.1011)<sub>2</sub>=(0.54)<sub>8</sub>=(0.B)<sub>16</sub></p>
<p><strong>码制</strong><br><strong>1.原码</strong><br>将数的真值形式整数符号用0表示，负数符号用符号位1表示，叫做数的原码形式。<br><strong>2.反码</strong><br>对于正数，反码与原码相同<br>对于负数，保留原码符号位，其他位取反<br><strong>3.补码</strong><br>对于正数，补码与原码相同<br>对于负数，补码为反码+1</p>
]]></content>
      
        <categories>
            
            <category> eda </category>
            
        </categories>
        
        
        <tags>
            
            <tag> eda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B树完整实现]]></title>
      <url>/2017/12/25/B%E6%A0%91%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0-C%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>-B树完整接口实现<br><a id="more"></a><br> <strong>B树的定义</strong><br>B树是一种平衡的多路查找树。<br>一颗m阶B树，或为空树，或为满足下列特性的m叉树。<br>（1）树中每个结点最多含有m棵子树;<br>（2）若根结点不是叶子结点，则至少有两颗子树;<br>（3）除根之外的所有非终端结点至少有[m/2];<br>（4）每个非终端结点中包含信息：（n,A0,K1,A1,K2,A2,…,Kn,An)。其中<br>①Ki（1≤i≤n）为关键字，且关键字按升序排序。<br>②指针Ai（0≤i≤n）指向子树的根结点。<br>③关键字的个数n必须满足：[m/2]-1≤n≤m-1<br>（5）所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部节点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）</p>
<p><strong>编程环境与配置</strong><br>IDE：Dev-C++ 5.11<br>编程语言：C</p>
<p><strong>程序结构图</strong><br><img src="http://img.blog.csdn.net/20171225173432967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>B树的抽象数据类型定义</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">ADT BTree&#123;</div><div class="line">数据对象：D是具有相同特性的数据元素的集合</div><div class="line">数据关系：<span class="symbol">R1</span>=&#123;&lt;ai-<span class="number">1</span>,ai&gt;|ai-<span class="number">1</span>,ai∈D，i=<span class="number">2</span>，...,<span class="built_in">n</span>&#125;</div><div class="line">     		  <span class="symbol">R2</span>=&#123;&lt;ptr[i-<span class="number">1</span>],ptr[i]&gt;|i=<span class="number">1</span>...,<span class="built_in">n</span>&#125;</div><div class="line">  约定<span class="symbol">a1</span>|key[<span class="number">1</span>]为关键字数组头，an|key[p-&lt;keynum]为关键字数组尾</div><div class="line">  约定ptr[i]为结点的第i个子树</div><div class="line">基本操作：</div><div class="line">InitBTree(<span class="built_in">t</span>)</div><div class="line">初始条件：B树已定义</div><div class="line">操作结果：初始化B树</div><div class="line">SearchBTNode(BTNode *p,KeyType k)</div><div class="line">初始条件：结点p已存在</div><div class="line">操作结果：在结点p中查找关键字k的插入位置i </div><div class="line">Result SearchBTree(BTree <span class="built_in">t</span>,KeyType k)</div><div class="line">初始条件：B树已存在</div><div class="line">操作结果：在B树查找关键字k的插入位置，返回查找结果</div><div class="line">InsertBTNode(BTNode *&amp;p,<span class="built_in">int</span> i,KeyType k,BTNode *q)</div><div class="line">初始条件：结点p和结点q已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：将关键字k和结点q分别插入到p-&gt;key[i+<span class="number">1</span>]和p-&gt;ptr[i+<span class="number">1</span>]中</div><div class="line">SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)</div><div class="line">初始条件：结点p和结点q已存在</div><div class="line">操作结果：将结点p分裂成两个结点,前一半保留,后一半移入结点q</div><div class="line">NewRoot(BTNode *&amp;<span class="built_in">t</span>,KeyType k,BTNode *p,BTNode *q)</div><div class="line">初始条件：结点<span class="built_in">t</span>,p,q已存在</div><div class="line">操作结果：生成新的根结点<span class="built_in">t</span>,原p和q为子树指针</div><div class="line">InsertBTree(BTree &amp;<span class="built_in">t</span>,<span class="built_in">int</span> i,KeyType k,BTNode *p)</div><div class="line">初始条件：结点p和结点<span class="built_in">t</span>已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：在B树<span class="built_in">t</span>中插入关键字k</div><div class="line">Remove(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：p结点删除key[i]和它的孩子指针ptr[i]</div><div class="line">Substitution(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：查找替代值</div><div class="line">MoveRight(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整右移操作</div><div class="line">MoveLeft(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整左移操作</div><div class="line">Combine(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整合并操作</div><div class="line">AdjustBTree(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：B树调整操作</div><div class="line">BTNodeDelete(BTNode *p,KeyType k)</div><div class="line">初始条件：结点p已存在</div><div class="line">操作结果：在结点p中删除关键字k</div><div class="line">BTreeDelete(BTree &amp;<span class="built_in">t</span>,KeyType k)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：在B树<span class="built_in">t</span>中删除关键字k</div><div class="line">DestroyBTree(BTree &amp;<span class="built_in">t</span>)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：递归释放B树</div><div class="line">PrintBTree(BTree <span class="built_in">t</span>)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：遍历打印B树</div><div class="line">&#125;ADT BTree</div></pre></td></tr></table></figure>
<p><strong>头文件</strong><br>定义了需要用到的数据类型，结构体类型，以及所有函数接口;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//==========ADT BTree的表示与实现==========</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10              	<span class="comment">//定义B树的最大的阶数</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">4</span>;               		<span class="comment">//设定B树的阶数 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=m<span class="number">-1</span>;           		<span class="comment">//结点的最大关键字数量 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=(m<span class="number">-1</span>)/<span class="number">2</span>;				<span class="comment">//结点的最小关键字数量 </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;       	 		<span class="comment">//KeyType为关键字类型</span></div><div class="line"></div><div class="line"><span class="comment">//===============B树存储结构==============</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>         		<span class="comment">//B树和B树结点类型 </span></div><div class="line">	<span class="keyword">int</span> keynum;    		        <span class="comment">//结点关键字个数</span></div><div class="line">	KeyType key[MAXM];          	<span class="comment">//关键字数组，key[0]不使用 </span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span>        	<span class="comment">//双亲结点指针</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ptr</span>[<span class="title">MAXM</span>];</span>     	<span class="comment">//孩子结点指针数组 </span></div><div class="line">&#125;BTNode,*BTree;</div><div class="line">   </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              		<span class="comment">//B树查找结果类型 </span></div><div class="line">	BTNode *pt;              	<span class="comment">//指向找到的结点</span></div><div class="line">	<span class="keyword">int</span> i;                   		<span class="comment">//在结点中的关键字位置; </span></div><div class="line">	<span class="keyword">int</span> tag;                 		<span class="comment">//查找成功与否标志</span></div><div class="line">&#125;Result;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>               <span class="comment">//链表和链表结点类型 </span></div><div class="line">  	BTree data;     				<span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>     		<span class="comment">//指针域</span></div><div class="line">&#125;LNode, *LinkList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> status&#123;               <span class="comment">//枚举类型（依次递增） </span></div><div class="line">    TRUE,</div><div class="line">    FALSE,</div><div class="line">    OK,</div><div class="line">    ERROR,</div><div class="line">    OVERFLOW,</div><div class="line">  	EMPTY</div><div class="line">&#125;Status;</div><div class="line"></div><div class="line"><span class="comment">//============基本操作的函数原型声明=============</span></div><div class="line"><span class="function">Status <span class="title">InitBTree</span><span class="params">(BTree &amp;t)</span></span>;</div><div class="line"><span class="comment">//初始化B树 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBTNode</span><span class="params">(BTNode *p,KeyType k)</span></span>;                  		</div><div class="line"><span class="comment">//在结点p中查找关键字k的插入位置i</span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree t,KeyType k)</span></span>;               			</div><div class="line"><span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTNode</span><span class="params">(BTNode *&amp;p,<span class="keyword">int</span> i,KeyType k,BTNode *q)</span></span>; 		</div><div class="line"><span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitBTNode</span><span class="params">(BTNode *&amp;p,BTNode *&amp;q)</span></span>;						</div><div class="line"><span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewRoot</span><span class="params">(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)</span></span>;			</div><div class="line"><span class="comment">//生成新的根结点t,原结点p和结点q为子树指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTree</span><span class="params">(BTree &amp;t,<span class="keyword">int</span> i,KeyType k,BTNode *p)</span></span>;			</div><div class="line"><span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>; 									</div><div class="line"><span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Substitution</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;      						</div><div class="line"><span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                               </div><div class="line"><span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">将左结点aq中的最后一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveLeft</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="comment">/*将双亲结点p中的第一个关键字移入结点aq中，</span></div><div class="line"><span class="comment">将结点q中的第一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                  </div><div class="line"><span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">并调整双亲结点p中的剩余关键字的位置*/</span>										 </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustBTree</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                              </div><div class="line"><span class="comment">//删除结点p中的第i个关键字后,调整B树										 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindBTNode</span><span class="params">(BTNode *p,KeyType k,<span class="keyword">int</span> &amp;i)</span></span>;                     </div><div class="line"><span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDelete</span><span class="params">(BTNode *p,KeyType k)</span></span>;                          </div><div class="line"><span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeDelete</span><span class="params">(BTree &amp;t,KeyType k)</span></span>;                          	</div><div class="line"><span class="comment">//构建删除框架，执行删除操作 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBTree</span><span class="params">(BTree &amp;t)</span></span>;                                    </div><div class="line"><span class="comment">//递归释放B树</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkList &amp;L)</span></span>;                                  </div><div class="line"><span class="comment">//初始化队列 </span></div><div class="line"><span class="function">LNode* <span class="title">CreateNode</span><span class="params">(BTree t)</span></span>;                               		</div><div class="line"><span class="comment">//新建一个结点 </span></div><div class="line"><span class="function">Status <span class="title">Enqueue</span><span class="params">(LNode *p,BTree t)</span></span>;								</div><div class="line"><span class="comment">//元素q入队列</span></div><div class="line"><span class="function">Status <span class="title">Dequeue</span><span class="params">(LNode *p,BTNode *&amp;q)</span></span>;                            </div><div class="line"><span class="comment">//出队列，并以q返回值</span></div><div class="line"><span class="function">Status <span class="title">IfEmpty</span><span class="params">(LinkList L)</span></span>;                       				</div><div class="line"><span class="comment">//队列判空 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkList L)</span></span>;    								</div><div class="line"><span class="comment">//销毁队列 </span></div><div class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(BTree t,LinkList L,<span class="keyword">int</span> newline,<span class="keyword">int</span> sum)</span></span>;		</div><div class="line"><span class="comment">//用队列遍历输出B树 </span></div><div class="line"><span class="function">Status <span class="title">PrintBTree</span><span class="params">(BTree t)</span></span>;                                     </div><div class="line"><span class="comment">//输出B树 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>;                  									</div><div class="line"><span class="comment">//测试B树功能函数 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><strong>B树具体接口实现</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.4</span>.<span class="number">1</span>InitBTree函数</div><div class="line">功能:初始化B树</div><div class="line">代码实现:</div><div class="line">Status InitBTree(BTree &amp;t)&#123;</div><div class="line">    t=NULL;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">2</span>SearchBTNode函数</div><div class="line">功能：在结点p中查找关键字k的插入位置i</div><div class="line">代码实现：</div><div class="line">int SearchBTNode(BTNode *p,KeyType k)&#123;</div><div class="line">    int i=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>&amp;&amp;p-&gt;</span>key[i+<span class="number">1</span>]&lt;=k;i++);</div><div class="line">    return i;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">3</span>SearchBTree函数</div><div class="line">功能：在树t中查找关键字k，返回查找结果类型</div><div class="line">代码实现：</div><div class="line">Result SearchBTree(BTree t,KeyType k)&#123;</div><div class="line">    BTNode *p=t,*q=NULL; 							<span class="comment">//初始化结点p和结点q,p指向待查结点,q指向p的双亲</span></div><div class="line">    int found_tag=<span class="number">0</span>;                        		<span class="comment">//设定查找成功与否标志 </span></div><div class="line">	int i=<span class="number">0</span>;                 </div><div class="line">    Result r;                             			<span class="comment">//设定返回的查找结果 </span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(p!=NULL&amp;&amp;found_tag==<span class="number">0</span>)&#123;</div><div class="line">        <span class="function"><span class="title">i</span>=SearchBTNode(p,k);              			//在结点p中查找关键字k        			<span class="keyword">if</span>(i&gt;0&amp;&amp;p-&gt;</span>key[i]==k)    		  			<span class="comment">//找到待查关键字</span></div><div class="line">            found_tag=<span class="number">1</span>;                    		<span class="comment">//查找成功 </span></div><div class="line">        <span class="keyword">else</span>&#123;                               		<span class="comment">//查找失败 </span></div><div class="line">            q=p;                            </div><div class="line">            <span class="function"><span class="title">p</span>=p-&gt;</span>ptr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;                   			<span class="comment">//查找成功</span></div><div class="line">        r.pt=p;</div><div class="line">        r.i=i;</div><div class="line">        r.tag=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                            				<span class="comment">//查找失败</span></div><div class="line">        r.pt=q;</div><div class="line">		r.i=i;</div><div class="line">        r.tag=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    return r;                       				<span class="comment">//返回关键字k的位置(或插入位置)</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">4</span>InsertBTNode函数</div><div class="line">功能：关键字<span class="function"><span class="title">k</span>和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]中</div><div class="line">代码实现：</div><div class="line">void InsertBTNode(BTNode *&amp;p,int i,KeyType k,BTNode *q)&#123;</div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=p-&gt;</span>keynum;j&gt;i;j--)&#123;  						<span class="comment">//整体后移空出一个位置</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>key[i+<span class="number">1</span>]=k;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>ptr[i+<span class="number">1</span>]=q;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=p;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum++;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">5</span>SplitBTNode函数</div><div class="line">功能：将结点p分裂成两个结点,前一半保留,后一半移入结点q</div><div class="line">代码实现：</div><div class="line">void SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)&#123;</div><div class="line">    int i;</div><div class="line">	int s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    q=(BTNode *)malloc(sizeof(BTNode));    			<span class="comment">//给结点q分配空间</span></div><div class="line">	 </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=p-&gt;</span>ptr[s];                   			<span class="comment">//后一半移入结点q</span></div><div class="line">    <span class="keyword">for</span>(i=s+<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[i-s]=p-&gt;</span>key[i];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i-s]=p-&gt;</span>ptr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">keynum</span>=p-&gt;</span>keynum-s;                </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum-s;i++) 						<span class="comment">//修改双亲指针 </span></div><div class="line">        <span class="function"><span class="title">if</span>(q-&gt;</span>ptr[i]!=NULL) </div><div class="line">			<span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>parent=q;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum=s-<span class="number">1</span>;                 				<span class="comment">//结点p的前一半保留,修改结点p的keynum</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">6</span>NewRoot函数</div><div class="line">功能：生成新的根结点t,原p和q为子树指针</div><div class="line">代码实现：</div><div class="line">void NewRoot(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)&#123;</div><div class="line">    t=(BTNode *)malloc(sizeof(BTNode));       		<span class="comment">//分配空间 </span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>keynum=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">0</span>]=p;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">1</span>]=q;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>key[<span class="number">1</span>]=k;</div><div class="line">    <span class="keyword">if</span>(p!=NULL) 									<span class="comment">//调整结点p和q的双亲指针 </span></div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>parent=t;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=t;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>parent=NULL;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">7</span>InsertBTree函数</div><div class="line">功能：在树t中插入关键字k，返回插入结果</div><div class="line">代码实现：</div><div class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTNode *p)&#123;</div><div class="line">    BTNode *q;</div><div class="line">    int finish_tag,newroot_tag,s;                   <span class="comment">//设定需要新结点标志和插入完成标志 </span></div><div class="line">    KeyType x;</div><div class="line">    <span class="keyword">if</span>(p==NULL)                      				<span class="comment">//t是空树</span></div><div class="line">        NewRoot(t,k,NULL,NULL);         			<span class="comment">//生成仅含关键字k的根结点t</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x=k;</div><div class="line">        q=NULL;</div><div class="line">        finish_tag=<span class="number">0</span>;       </div><div class="line">        newroot_tag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(finish_tag==<span class="number">0</span>&amp;&amp;newroot_tag==<span class="number">0</span>)&#123;</div><div class="line">            I<span class="function"><span class="title">nsertBTNode</span>(p,i,x,q);               	//将关键字x和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]</div><div class="line">            <span class="function"><span class="title">if</span> (p-&gt;</span>keynum&lt;=Max) </div><div class="line">				finish_tag=<span class="number">1</span>; 						<span class="comment">//插入完成</span></div><div class="line">            <span class="keyword">else</span>&#123;         </div><div class="line">                s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">                SplitBTNode(p,q);                 <span class="comment">//分裂结点 </span></div><div class="line">                <span class="function"><span class="title">x</span>=p-&gt;</span>key[s];</div><div class="line">                <span class="function"><span class="title">if</span>(p-&gt;</span>parent)&#123;              		<span class="comment">//查找x的插入位置</span></div><div class="line">                    <span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">                    i=SearchBTNode(p, x);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>                            <span class="comment">//没找到x，需要新结点 </span></div><div class="line">					newroot_tag=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(newroot_tag==<span class="number">1</span>)                 		<span class="comment">//根结点已分裂为结点p和q </span></div><div class="line">            NewRoot(t,x,p,q);              		<span class="comment">//生成新根结点t,p和q为子树指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">8</span>Remove函数</div><div class="line">功能：从p结点删除key[i]和它的孩子指针ptr[i]</div><div class="line">代码实现：</div><div class="line">void Remove(BTNode *p,int i)&#123;</div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=i+1;j&lt;=p-&gt;</span>keynum;j++)&#123;      				<span class="comment">//前移删除key[i]和ptr[i]</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j-1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j-1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">9</span>Substitution函数</div><div class="line">功能：寻找替代值（右子树中最小的关键字）</div><div class="line">代码实现：</div><div class="line">void Substitution(BTNode *p,int i)&#123;</div><div class="line">    BTNode *q;</div><div class="line">    <span class="function"><span class="title">for</span>(q=p-&gt;</span><span class="function"><span class="title">ptr</span>[i];q-&gt;</span><span class="function"><span class="title">ptr</span>[0]!=NULL;q=q-&gt;</span>ptr[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];    						<span class="comment">//复制关键字值</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">10</span>MoveRight函数</div><div class="line">功能：双亲结点p中的最后一个关键字移入右结点q中</div><div class="line">将左结点aq中的最后一个关键字移入双亲结点p中</div><div class="line">代码实现：</div><div class="line">void MoveRight(BTNode *p,int i)&#123;    </div><div class="line">int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=q-&gt;</span>keynum;j&gt;<span class="number">0</span>;j--)&#123; 						<span class="comment">//将右兄弟q中所有关键字向后移动一位</span></div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[1]=q-&gt;</span>ptr[<span class="number">0</span>];        					<span class="comment">//从双亲结点p移动关键字到右兄弟q中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[1]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum++;</div><div class="line">    				</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=aq-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span>keynum];					<span class="comment">//将左兄弟aq中最后一个关键字移动到双亲结点p中</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span><span class="function"><span class="title">ptr</span>[0]=aq-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span>keynum];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">11</span>MoveLeft函数</div><div class="line">功能：将双亲结点p中的第一个关键字移入左结点aq中，</div><div class="line">将右结点q中的第一个关键字移入双亲结点p中</div><div class="line">代码实现：</div><div class="line">void MoveLeft(BTNode *p,int i)&#123; </div><div class="line">	int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">                					</div><div class="line">	<span class="function"><span class="title">aq</span>-&gt;</span>keynum++;									<span class="comment">//把双亲结点p中的关键字移动到左兄弟aq中</span></div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i]; </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">                			</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];							<span class="comment">//把右兄弟q中的关键字移动到双亲节点p中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=q-&gt;</span>ptr[<span class="number">1</span>];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum--;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=aq-&gt;</span>keynum;j++)&#123;    					<span class="comment">//将右兄弟q中所有关键字向前移动一位</span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=aq-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=aq-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">12</span>Combine函数</div><div class="line">功能：双亲结点p、右结点q合并入左结点aq，</div><div class="line">并调整双亲结点p中的剩余关键字的位置</div><div class="line">代码实现：</div><div class="line">void Combine(BTNode *p,int i)&#123;</div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];            				</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">keynum</span>++;                    		       //将双亲结点的关键字p-&gt;</span>key[i]插入到左结点aq		</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=q-&gt;</span>keynum;j++)&#123;        				<span class="comment">//将右结点q中的所有关键字插入到左结点aq </span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span>keynum++;</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=i;j&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>;j++)&#123;     					//将双亲结点p中的p-&gt;</span>key[i]后的所有关键字向前移动一位 </div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=p-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=p-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;                                    <span class="comment">//修改双亲结点p的keynum值 </span></div><div class="line">    free(q);                        				<span class="comment">//释放空右结点q的空间</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">13</span>AdjustBTree函数</div><div class="line">功能：删除结点p中的第i个关键字后,调整B树</div><div class="line">代码实现：</div><div class="line">void AdjustBTree(BTNode *p,int i)&#123;</div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)                           				<span class="comment">//删除的是最左边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[1]-&gt;</span>keynum&gt;Min)                   <span class="comment">//右结点可以借</span></div><div class="line">            MoveLeft(p,<span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span>                                        <span class="comment">//右兄弟不够借 </span></div><div class="line">            Combine(p,<span class="number">1</span>);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(i==p-&gt;</span>keynum)              				<span class="comment">//删除的是最右边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)                 <span class="comment">//左结点可以借 </span></div><div class="line">            MoveRight(p,i);</div><div class="line">        <span class="keyword">else</span>										<span class="comment">//左结点不够借 </span></div><div class="line">            Combine(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)  	 			<span class="comment">//删除关键字在中部且左结点够借 </span></div><div class="line">        MoveRight(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i+1]-&gt;</span>keynum&gt;Min)                <span class="comment">//删除关键字在中部且右结点够借 </span></div><div class="line">        MoveLeft(p,i+<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span>                                            <span class="comment">//删除关键字在中部且左右结点都不够借</span></div><div class="line">        Combine(p,i);</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">14</span>BTNodeDelete函数</div><div class="line">功能：在结点p中查找并删除关键字k</div><div class="line">代码实现：</div><div class="line">int BTNodeDelete(BTNode *p,KeyType k)&#123;</div><div class="line">    int i;</div><div class="line">    int found_tag;                                 	<span class="comment">//查找标志 </span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">        return <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    	found_tag=FindBTNode(p,k,i);				<span class="comment">//返回查找结果 </span></div><div class="line">        <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;       			        <span class="comment">//查找成功 </span></div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i-<span class="number">1</span>]!=NULL)&#123;             		<span class="comment">//删除的是非叶子结点</span></div><div class="line">                Substitution(p,i);                 	<span class="comment">//寻找相邻关键字(右子树中最小的关键字) </span></div><div class="line">                BTN<span class="function"><span class="title">odeDelete</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i],p-&gt;</span>key[i]); 	<span class="comment">//执行删除操作 </span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Remove(p,i);                    	<span class="comment">//从结点p中位置i处删除关键字</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="function"><span class="title">found_tag</span>=BTNodeDelete(p-&gt;</span>ptr[i],k);    <span class="comment">//沿孩子结点递归查找并删除关键字k</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i]!=NULL)</div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>keynum&lt;Min)          		<span class="comment">//删除后关键字个数小于MIN</span></div><div class="line">                AdjustBTree(p,i);					<span class="comment">//调整B树 </span></div><div class="line">        return found_tag;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">15</span>BTreeDelete函数</div><div class="line">功能：构建删除框架，执行删除操作</div><div class="line">代码实现：</div><div class="line">void BTreeDelete(BTree &amp;t,KeyType k)&#123;  </div><div class="line">    BTNode *p;</div><div class="line">	int a=BTNodeDelete(t,k);                 		<span class="comment">//删除关键字k </span></div><div class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)                                    	<span class="comment">//查找失败 </span></div><div class="line">        printf(<span class="string">"   关键字%d不在B树中\n"</span>,k);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(t-&gt;</span>keynum==<span class="number">0</span>)&#123;                          <span class="comment">//调整 </span></div><div class="line">        p=t;</div><div class="line">        <span class="function"><span class="title">t</span>=t-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">        free(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">16</span>DestroyBTree函数</div><div class="line">功能：递归释放B树</div><div class="line">代码实现：</div><div class="line">void DestroyBTree(BTree &amp;t)&#123;</div><div class="line">    int i;  </div><div class="line">    BTNode* p=t;  </div><div class="line">    <span class="keyword">if</span>(p!=NULL)&#123;                                 	<span class="comment">//B树不为空  </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum;i++)&#123;  				<span class="comment">//递归释放每一个结点 </span></div><div class="line">            D<span class="function"><span class="title">estroyBTree</span>(*&amp;p-&gt;</span>ptr[i]);  </div><div class="line">        &#125;  </div><div class="line">        free(p);  </div><div class="line">    &#125;  </div><div class="line">    t=NULL;  </div><div class="line">&#125;  </div><div class="line"><span class="number">2.4</span>.<span class="number">17</span>InitQueue函数</div><div class="line">功能：初始化队列</div><div class="line">代码实现： </div><div class="line">Status InitQueue(LinkList &amp;L)&#123;</div><div class="line">	L=(LNode*)malloc(sizeof(LNode));				<span class="comment">//分配结点空间 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//分配失败				</span></div><div class="line">        return OVERFLOW;</div><div class="line">     L-&gt;next=NULL;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">18</span>CreateNode函数</div><div class="line">功能：新建一个结点</div><div class="line">代码实现：</div><div class="line">LNode* CreateNode(BTNode *p)&#123;</div><div class="line">    LNode *q;</div><div class="line">    q=(LNode*)malloc(sizeof(LNode)); 				<span class="comment">//分配结点空间</span></div><div class="line">    <span class="keyword">if</span>(q!=NULL)&#123;                                    <span class="comment">//分配成功 </span></div><div class="line">    	<span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=p;</div><div class="line">       	<span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    &#125;</div><div class="line">   return q;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">19</span>Enqueue函数</div><div class="line">功能：元素q入队列</div><div class="line">代码实现：</div><div class="line">Status Enqueue(LNode *p,BTNode *q)&#123; </div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">		return ERROR; 								</div><div class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next!=NULL)                            <span class="comment">//调至队列最后 </span></div><div class="line">        <span class="function"><span class="title">p</span>=p-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=CreateNode(q);                          <span class="comment">//生成结点让q进入队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">20</span>Dequeue函数</div><div class="line">功能：出队列，并以q返回值</div><div class="line">代码实现： </div><div class="line">Status Dequeue(LNode *p,BTNode *&amp;q)&#123;</div><div class="line">	LNode *aq;</div><div class="line">    <span class="function"><span class="title">if</span>(p==NULL||p-&gt;</span>next==NULL) 						<span class="comment">//删除位置不合理 </span></div><div class="line">		return ERROR; </div><div class="line">    <span class="function"><span class="title">aq</span>=p-&gt;</span>next;										<span class="comment">//修改被删结点aq的指针域</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=aq-&gt;</span>next; 								</div><div class="line">    <span class="function"><span class="title">q</span>=aq-&gt;</span><span class="keyword">data</span>;</div><div class="line">    free(aq); 										<span class="comment">//释放结点aq</span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">21</span>IfEmpty函数</div><div class="line">功能：队列判空 </div><div class="line">代码实现：</div><div class="line">Status IfEmpty(LinkList L)&#123;</div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//队列不存在 </span></div><div class="line">		return ERROR;</div><div class="line">    <span class="function"><span class="title">if</span>(L-&gt;</span>next==NULL) 								<span class="comment">//队列为空 </span></div><div class="line">		return TRUE;</div><div class="line">    return FALSE;									<span class="comment">//队列非空 </span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">22</span>DestroyQueue函数</div><div class="line">功能：销毁队列</div><div class="line">代码实现：</div><div class="line">void DestroyQueue(LinkList L)&#123;</div><div class="line">   LinkList p;</div><div class="line">    <span class="keyword">if</span>(L!=NULL)&#123;</div><div class="line">    	p=L;</div><div class="line">       	L=L-&gt;next;</div><div class="line">       	free(p);                                   	<span class="comment">//逐一释放 </span></div><div class="line">        DestroyQueue(L);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">23</span>Traverse函数</div><div class="line">功能：用队列遍历输出B树</div><div class="line">代码实现：</div><div class="line">Status Traverse(BTree t,LinkList L,int newline,int sum)&#123; </div><div class="line">    int i;</div><div class="line">    BTree p;</div><div class="line">    <span class="keyword">if</span>(t!=NULL)&#123;</div><div class="line">        printf(<span class="string">"  [ "</span>);</div><div class="line">        E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[<span class="number">0</span>]);                      	<span class="comment">//入队         </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=1;i&lt;=t-&gt;</span>keynum;i++)&#123;</div><div class="line">            <span class="function"><span class="title">printf</span>(" %d ",t-&gt;</span>key[i]);</div><div class="line">            E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[i]);					<span class="comment">//子结点入队 </span></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="title">sum</span>+=t-&gt;</span>keynum+<span class="number">1</span>;</div><div class="line">        printf(<span class="string">"]"</span>);</div><div class="line">        <span class="keyword">if</span>(newline==<span class="number">0</span>)&#123;                             <span class="comment">//需要另起一行 </span></div><div class="line">        	printf(<span class="string">"\n"</span>);</div><div class="line">            newline=sum-<span class="number">1</span>;</div><div class="line">            sum=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            newline--;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">if</span>(IfEmpty(L)==FALSE)&#123;                       	<span class="comment">//l不为空 </span></div><div class="line">         Dequeue(L,p);								<span class="comment">//出队，以p返回 </span></div><div class="line">         Traverse(p,L,newline,sum);					<span class="comment">//遍历出队结点 </span></div><div class="line">     &#125;</div><div class="line">     return OK;</div><div class="line"> &#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">24</span>PrintBTree函数</div><div class="line">功能：输出B树</div><div class="line">代码实现：</div><div class="line">Status PrintBTree(BTree t)&#123;</div><div class="line">   LinkList L;</div><div class="line">    <span class="keyword">if</span>(t==NULL)&#123;</div><div class="line">        printf(<span class="string">"  B树为空树"</span>);</div><div class="line">        return OK;</div><div class="line">    &#125;</div><div class="line">    InitQueue(L);                        			<span class="comment">//初始化队列 </span></div><div class="line">    Traverse(t,L,<span class="number">0</span>,<span class="number">0</span>);								<span class="comment">//利用队列输出 </span></div><div class="line">    DestroyQueue(L);								<span class="comment">//销毁队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">25</span>Test1函数</div><div class="line">功能：测试B树功能</div><div class="line">代码实现：</div><div class="line">void Test1()&#123; </div><div class="line">	system(<span class="string">"color 70"</span>);  </div><div class="line">    BTNode *t=NULL;</div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">    int j,n=<span class="number">15</span>;</div><div class="line">    KeyType k;</div><div class="line">    KeyType a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;                           </div><div class="line">    printf(<span class="string">"创建一棵%d阶B树:\n"</span>,m);</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;								<span class="comment">//逐一插入元素 </span></div><div class="line">        s=SearchBTree(t,a[j]);</div><div class="line">        <span class="keyword">if</span>(s.tag==<span class="number">0</span>)</div><div class="line">            InsertBTree(t,s.i,a[j],s.pt);</div><div class="line">        printf(<span class="string">"   第%d步,插入元素%d:\n "</span>,j+<span class="number">1</span>,a[j]);</div><div class="line">        PrintBTree(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"删除操作:\n"</span>);                         	<span class="comment">//删除操作 </span></div><div class="line">    k=<span class="number">9</span>;														</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    k=<span class="number">1</span>;</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"  递归释放B树\n"</span>); 						<span class="comment">//递归释放B树</span></div><div class="line">    DestroyBTree(t);								 </div><div class="line">	PrintBTree(t);</div><div class="line">&#125; </div><div class="line"><span class="number">2.4</span>.<span class="number">26</span>Test2函数</div><div class="line">功能：测试B树功能</div><div class="line">代码实现：</div><div class="line">void Test2()&#123;</div><div class="line">	int i,k; </div><div class="line">	system(<span class="string">"color 70"</span>);</div><div class="line">	BTree t=NULL;  </div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">	printf(<span class="string">"此时的B树：\n"</span>);</div><div class="line">	PrintBTree(t); </div><div class="line">	printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"=============Operation Table=============\n"</span>);</div><div class="line">    printf(<span class="string">"   1.Init     2.Insert    3.Delete    \n"</span>);</div><div class="line">    printf(<span class="string">"   4.Destroy  5.Exit  	  \n"</span>);</div><div class="line">    printf(<span class="string">"=========================================\n"</span>);</div><div class="line">    printf(<span class="string">"Enter number to choose operation:_____\b\b\b"</span>);</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;i);</div><div class="line">    switch(i)&#123;</div><div class="line">    	case <span class="number">1</span>:&#123;</div><div class="line">			InitBTree(t);</div><div class="line">			printf(<span class="string">"InitBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		case <span class="number">2</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to InsertBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			s=SearchBTree(t,k);</div><div class="line">			InsertBTree(t,s.i,k,s.pt);</div><div class="line">			printf(<span class="string">"InsertBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">3</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to DeleteBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			BTreeDelete(t,k);</div><div class="line">			printf(<span class="string">"\n"</span>);</div><div class="line">			printf(<span class="string">"DeleteBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">4</span>:&#123;</div><div class="line">			DestroyBTree(t);</div><div class="line">			break;</div><div class="line">			printf(<span class="string">"DestroyBTree successfully.\n"</span>);</div><div class="line">		&#125;</div><div class="line">		case <span class="number">5</span>:&#123;</div><div class="line">			exit(-<span class="number">1</span>);				</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>三.功能测试</strong><br>插入功能测试/遍历功能测试<br>依次插入1-15进行测试输出，结果如下：<br><img src="http://img.blog.csdn.net/20171225173213197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由输出的B树可知，插入功能正常并且遍历功能正常<br>3.2删除功能测试<br>在之前插入1-15后进行删除关键字的功能测试，选取9和1依次进行删除测试，结果如下：<br><img src="http://img.blog.csdn.net/20171225173233140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>根据B树的定义和该B树的输出，删除功能正常<br>3.3释放功能测试<br>在之前的基础上进行递归释放B树功能测试，结果如下：<br><img src="http://img.blog.csdn.net/20171225173241746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>遍历输出的结果为B数为空树，说明释放功能正常<br>3.4其他功能测试<br>其他接口在以上功能中已经有所体现，均正常，不再一一调用测试。<br><strong>四.思考与小结</strong><br><strong>错误总结</strong><br>（1）在部分需要判空的地方没有判空<br>（2）递归实现的时候多次爆栈<br>（3）插入分裂的SplitBTNode函数一开始写的时候分裂成两个<br>（4）删除操作中的Combine函数的指针忘记调整<br><strong>4.2部分优化</strong><br>4.2.1输出优化<br>在一开始输出的时候选用的是括号输出法(测试功能选用的值略有不同),在直观上比较难的去分辨哪些是双亲结点的左右结点，因此在输出函数上进行了优化<br><img src="http://img.blog.csdn.net/20171225173325462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>通过队列遍历，在每一次遍历的过程中能够，模拟层次遍历，在B树的结构上更加美观，而且更容易看清楚B树的结构<br><img src="http://img.blog.csdn.net/20171225173335299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>4.2.2测试界面优化<br>在保持原本接口不变的情况下，写了Test2函数，自行创建和进行各种B树的操作.<br><img src="http://img.blog.csdn.net/20171225173348525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>整个程序源代码</strong><br><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10              		<span class="comment">//定义B树的最大的阶数</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">4</span>;               		<span class="comment">//设定B树的阶数 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=m<span class="number">-1</span>;           		<span class="comment">//结点的最大关键字数量 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=(m<span class="number">-1</span>)/<span class="number">2</span>;				<span class="comment">//结点的最小关键字数量 </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;       	 		<span class="comment">//KeyType为关键字类型</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>         		<span class="comment">//B树和B树结点类型 </span></div><div class="line">	<span class="keyword">int</span> keynum;    		         	<span class="comment">//结点关键字个数</span></div><div class="line">	KeyType key[MAXM];          	<span class="comment">//关键字数组，key[0]不使用 </span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span>        	<span class="comment">//双亲结点指针</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ptr</span>[<span class="title">MAXM</span>];</span>     	<span class="comment">//孩子结点指针数组 </span></div><div class="line">&#125;BTNode,*BTree;</div><div class="line">   </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              		<span class="comment">//B树查找结果类型 </span></div><div class="line">	BTNode *pt;              		<span class="comment">//指向找到的结点</span></div><div class="line">	<span class="keyword">int</span> i;                   		<span class="comment">//在结点中的关键字位置; </span></div><div class="line">	<span class="keyword">int</span> tag;                 		<span class="comment">//查找成功与否标志</span></div><div class="line">&#125;Result;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>               <span class="comment">//链表和链表结点类型 </span></div><div class="line">  	BTree data;     				<span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>     		<span class="comment">//指针域</span></div><div class="line">&#125;LNode, *LinkList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> status&#123;               <span class="comment">//枚举类型（依次递增） </span></div><div class="line">    TRUE,</div><div class="line">    FALSE,</div><div class="line">    OK,</div><div class="line">    ERROR,</div><div class="line">    OVERFLOW,</div><div class="line">  	EMPTY</div><div class="line">&#125;Status;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitBTree</span><span class="params">(BTree &amp;t)</span></span>;                                     <span class="comment">//初始化B树 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBTNode</span><span class="params">(BTNode *p,KeyType k)</span></span>;                  		<span class="comment">//在结点p中查找关键字k的插入位置i </span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree t,KeyType k)</span></span>;               			<span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">																tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">																关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTNode</span><span class="params">(BTNode *&amp;p,<span class="keyword">int</span> i,KeyType k,BTNode *q)</span></span>; 		<span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitBTNode</span><span class="params">(BTNode *&amp;p,BTNode *&amp;q)</span></span>;						<span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewRoot</span><span class="params">(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)</span></span>;			<span class="comment">//生成新的根结点t,原结点p和结点q为子树指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTree</span><span class="params">(BTree &amp;t,<span class="keyword">int</span> i,KeyType k,BTNode *p)</span></span>;			<span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">																 结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>; 									<span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Substitution</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;      						<span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                <span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">																将左结点aq中的最后一个关键字移入双亲结点p中*/</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveLeft</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                 <span class="comment">/*将双亲结点p中的第一个关键字移入结点aq中，</span></div><div class="line"><span class="comment">																 将结点q中的第一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                  <span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">																并调整双亲结点p中的剩余关键字的位置*/</span>																 </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustBTree</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                              <span class="comment">//删除结点p中的第i个关键字后,调整B树																 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindBTNode</span><span class="params">(BTNode *p,KeyType k,<span class="keyword">int</span> &amp;i)</span></span>;                     <span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDelete</span><span class="params">(BTNode *p,KeyType k)</span></span>;                          <span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeDelete</span><span class="params">(BTree &amp;t,KeyType k)</span></span>;                          	<span class="comment">//构建删除框架，执行删除操作 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBTree</span><span class="params">(BTree &amp;t)</span></span>;                                    <span class="comment">//递归释放B树</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkList &amp;L)</span></span>;                                  <span class="comment">//初始化队列 </span></div><div class="line"><span class="function">LNode* <span class="title">CreateNode</span><span class="params">(BTree t)</span></span>;                               		<span class="comment">//新建一个结点 </span></div><div class="line"><span class="function">Status <span class="title">Enqueue</span><span class="params">(LNode *p,BTree t)</span></span>;								<span class="comment">//元素q入队列</span></div><div class="line"><span class="function">Status <span class="title">Dequeue</span><span class="params">(LNode *p,BTNode *&amp;q)</span></span>;                            <span class="comment">//出队列，并以q返回值</span></div><div class="line"><span class="function">Status <span class="title">IfEmpty</span><span class="params">(LinkList L)</span></span>;                       				<span class="comment">//队列判空 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkList L)</span></span>;    								<span class="comment">//销毁队列 </span></div><div class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(BTree t,LinkList L,<span class="keyword">int</span> newline,<span class="keyword">int</span> sum)</span></span>;		<span class="comment">//用队列遍历输出B树 </span></div><div class="line"><span class="function">Status <span class="title">PrintBTree</span><span class="params">(BTree t)</span></span>;                                     <span class="comment">//输出B树 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>;                  									<span class="comment">//测试B树功能函数 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><strong>BTree代码</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div></pre></td><td class="code"><pre><div class="line">#include<span class="string">"BTREE.h"</span></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;malloc.h&gt;</div><div class="line">#include &lt;stdlib.h&gt; </div><div class="line"></div><div class="line">Status InitBTree(BTree &amp;t)&#123;</div><div class="line"><span class="comment">//初始化B树 </span></div><div class="line">    t=NULL;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int SearchBTNode(BTNode *p,KeyType k)&#123;</div><div class="line"><span class="comment">//在结点p中查找关键字k的插入位置i </span></div><div class="line">    int i=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>&amp;&amp;p-&gt;</span>key[i+<span class="number">1</span>]&lt;=k;i++);</div><div class="line">    return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Result SearchBTree(BTree t,KeyType k)&#123;</div><div class="line"><span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"></div><div class="line">    BTNode *p=t,*q=NULL; 							<span class="comment">//初始化结点p和结点q,p指向待查结点,q指向p的双亲</span></div><div class="line">    int found_tag=<span class="number">0</span>;                        		<span class="comment">//设定查找成功与否标志 </span></div><div class="line">	int i=<span class="number">0</span>;                 </div><div class="line">    Result r;                             			<span class="comment">//设定返回的查找结果 </span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(p!=NULL&amp;&amp;found_tag==<span class="number">0</span>)&#123;</div><div class="line">        <span class="function"><span class="title">i</span>=SearchBTNode(p,k);              			//在结点p中查找关键字k,使得p-&gt;</span><span class="function"><span class="title">key</span>[i]&lt;=k&lt;p-&gt;</span>key[i+<span class="number">1</span>]</div><div class="line">        <span class="function"><span class="title">if</span>(i&gt;0&amp;&amp;p-&gt;</span>key[i]==k)    		  			<span class="comment">//找到待查关键字</span></div><div class="line">            found_tag=<span class="number">1</span>;                    		<span class="comment">//查找成功 </span></div><div class="line">        <span class="keyword">else</span>&#123;                               		<span class="comment">//查找失败 </span></div><div class="line">            q=p;                            </div><div class="line">            <span class="function"><span class="title">p</span>=p-&gt;</span>ptr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;                   			<span class="comment">//查找成功</span></div><div class="line">        r.pt=p;</div><div class="line">        r.i=i;</div><div class="line">        r.tag=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                            				<span class="comment">//查找失败</span></div><div class="line">        r.pt=q;</div><div class="line">		r.i=i;</div><div class="line">        r.tag=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return r;                       				<span class="comment">//返回关键字k的位置(或插入位置)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void InsertBTNode(BTNode *&amp;p,int i,KeyType k,BTNode *q)&#123;</div><div class="line"><span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=p-&gt;</span>keynum;j&gt;i;j--)&#123;  						<span class="comment">//整体后移空出一个位置</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>key[i+<span class="number">1</span>]=k;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>ptr[i+<span class="number">1</span>]=q;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=p;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)&#123;</div><div class="line"><span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line">    int i;</div><div class="line">	int s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    q=(BTNode *)malloc(sizeof(BTNode));    			<span class="comment">//给结点q分配空间</span></div><div class="line">	 </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=p-&gt;</span>ptr[s];                   			<span class="comment">//后一半移入结点q</span></div><div class="line">    <span class="keyword">for</span>(i=s+<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[i-s]=p-&gt;</span>key[i];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i-s]=p-&gt;</span>ptr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">keynum</span>=p-&gt;</span>keynum-s;                </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum-s;i++) 					<span class="comment">//修改双亲指针 </span></div><div class="line">        <span class="function"><span class="title">if</span>(q-&gt;</span>ptr[i]!=NULL) </div><div class="line">			<span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>parent=q;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum=s-<span class="number">1</span>;                 					<span class="comment">//结点p的前一半保留,修改结点p的keynum</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void NewRoot(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)&#123;</div><div class="line"><span class="comment">//生成新的根结点t,原p和q为子树指针</span></div><div class="line">    t=(BTNode *)malloc(sizeof(BTNode));       		<span class="comment">//分配空间 </span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>keynum=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">0</span>]=p;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">1</span>]=q;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>key[<span class="number">1</span>]=k;</div><div class="line">    <span class="keyword">if</span>(p!=NULL) 									<span class="comment">//调整结点p和结点q的双亲指针 </span></div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>parent=t;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=t;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>parent=NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTNode *p)&#123;</div><div class="line"><span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line">    BTNode *q;</div><div class="line">    int finish_tag,newroot_tag,s;                   <span class="comment">//设定需要新结点标志和插入完成标志 </span></div><div class="line">    KeyType x;</div><div class="line">    <span class="keyword">if</span>(p==NULL)                      				<span class="comment">//t是空树</span></div><div class="line">        NewRoot(t,k,NULL,NULL);         			<span class="comment">//生成仅含关键字k的根结点t</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x=k;</div><div class="line">        q=NULL;</div><div class="line">        finish_tag=<span class="number">0</span>;       </div><div class="line">        newroot_tag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(finish_tag==<span class="number">0</span>&amp;&amp;newroot_tag==<span class="number">0</span>)&#123;</div><div class="line">            I<span class="function"><span class="title">nsertBTNode</span>(p,i,x,q);               	//将关键字x和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]</div><div class="line">            <span class="function"><span class="title">if</span> (p-&gt;</span>keynum&lt;=Max) </div><div class="line">				finish_tag=<span class="number">1</span>; 						<span class="comment">//插入完成</span></div><div class="line">            <span class="keyword">else</span>&#123;         </div><div class="line">                s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">                SplitBTNode(p,q);                   <span class="comment">//分裂结点 </span></div><div class="line">                <span class="function"><span class="title">x</span>=p-&gt;</span>key[s];</div><div class="line">                <span class="function"><span class="title">if</span>(p-&gt;</span>parent)&#123;              		<span class="comment">//查找x的插入位置</span></div><div class="line">                    <span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">                    i=SearchBTNode(p, x);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>                                <span class="comment">//没找到x，需要新结点 </span></div><div class="line">					newroot_tag=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(newroot_tag==<span class="number">1</span>)                 			<span class="comment">//根结点已分裂为结点p和q </span></div><div class="line">            NewRoot(t,x,p,q);              			<span class="comment">//生成新根结点t,p和q为子树指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Remove(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=i+1;j&lt;=p-&gt;</span>keynum;j++)&#123;      				<span class="comment">//前移删除key[i]和ptr[i]</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j-1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j-1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Substitution(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line">    BTNode *q;</div><div class="line">    <span class="function"><span class="title">for</span>(q=p-&gt;</span><span class="function"><span class="title">ptr</span>[i];q-&gt;</span><span class="function"><span class="title">ptr</span>[0]!=NULL;q=q-&gt;</span>ptr[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];    						<span class="comment">//复制关键字值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void MoveRight(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">将左结点aq中的最后一个关键字移入双亲结点p中*/</span> </div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=q-&gt;</span>keynum;j&gt;<span class="number">0</span>;j--)&#123; 						<span class="comment">//将右兄弟q中所有关键字向后移动一位</span></div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[1]=q-&gt;</span>ptr[<span class="number">0</span>];        					<span class="comment">//从双亲结点p移动关键字到右兄弟q中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[1]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum++;</div><div class="line">    				</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=aq-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span>keynum];					<span class="comment">//将左兄弟aq中最后一个关键字移动到双亲结点p中</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span><span class="function"><span class="title">ptr</span>[0]=aq-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span>keynum];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void MoveLeft(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p中的第一个关键字移入左结点aq中，</span></div><div class="line"><span class="comment">将右结点q中的第一个关键字移入双亲结点p中*/</span> </div><div class="line">	int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">                					</div><div class="line">	<span class="function"><span class="title">aq</span>-&gt;</span>keynum++;									<span class="comment">//把双亲结点p中的关键字移动到左兄弟aq中</span></div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i]; </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">                			</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];							<span class="comment">//把右兄弟q中的关键字移动到双亲节点p中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=q-&gt;</span>ptr[<span class="number">1</span>];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum--;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=aq-&gt;</span>keynum;j++)&#123;    					<span class="comment">//将右兄弟q中所有关键字向前移动一位</span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=aq-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=aq-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Combine(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">并调整双亲结点p中的剩余关键字的位置*/</span> </div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];            				</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">keynum</span>++;                    		       //将双亲结点的关键字p-&gt;</span>key[i]插入到左结点aq		</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=q-&gt;</span>keynum;j++)&#123;        				<span class="comment">//将右结点q中的所有关键字插入到左结点aq </span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span>keynum++;</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=i;j&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>;j++)&#123;     					//将双亲结点p中的p-&gt;</span>key[i]后的所有关键字向前移动一位 </div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=p-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=p-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;                                    <span class="comment">//修改双亲结点p的keynum值 </span></div><div class="line">    free(q);                        				<span class="comment">//释放空右结点q的空间</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void AdjustBTree(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//删除结点p中的第i个关键字后,调整B树</span></div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)                           				<span class="comment">//删除的是最左边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[1]-&gt;</span>keynum&gt;Min)                   <span class="comment">//右结点可以借</span></div><div class="line">            MoveLeft(p,<span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span>                                        <span class="comment">//右兄弟不够借 </span></div><div class="line">            Combine(p,<span class="number">1</span>);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(i==p-&gt;</span>keynum)              				<span class="comment">//删除的是最右边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)                 <span class="comment">//左结点可以借 </span></div><div class="line">            MoveRight(p,i);</div><div class="line">        <span class="keyword">else</span>										<span class="comment">//左结点不够借 </span></div><div class="line">            Combine(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)  	 			<span class="comment">//删除关键字在中部且左结点够借 </span></div><div class="line">        MoveRight(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i+1]-&gt;</span>keynum&gt;Min)                <span class="comment">//删除关键字在中部且右结点够借 </span></div><div class="line">        MoveLeft(p,i+<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span>                                            <span class="comment">//删除关键字在中部且左右结点都不够借</span></div><div class="line">        Combine(p,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int FindBTNode(BTNode *p,KeyType k,int &amp;i)&#123;</div><div class="line"><span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line">	<span class="function"><span class="title">if</span>(k&lt;p-&gt;</span>key[<span class="number">1</span>])&#123;    							<span class="comment">//结点p中查找关键字k失败 </span></div><div class="line">        i=<span class="number">0</span>;</div><div class="line">        return <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                							<span class="comment">//在p结点中查找</span></div><div class="line">        <span class="function"><span class="title">i</span>=p-&gt;</span>keynum;</div><div class="line">        <span class="function"><span class="title">while</span>(k&lt;p-&gt;</span>key[i]&amp;&amp;i&gt;<span class="number">1</span>)</div><div class="line">            i--;</div><div class="line">    	<span class="function"><span class="title">if</span>(k==p-&gt;</span>key[i])                            <span class="comment">//结点p中查找关键字k成功 </span></div><div class="line">    		return <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int BTNodeDelete(BTNode *p,KeyType k)&#123;</div><div class="line"><span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line">    int i;</div><div class="line">    int found_tag;                                 	<span class="comment">//查找标志 </span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">        return <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    	found_tag=FindBTNode(p,k,i);				<span class="comment">//返回查找结果 </span></div><div class="line">        <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;       			        <span class="comment">//查找成功 </span></div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i-<span class="number">1</span>]!=NULL)&#123;             		<span class="comment">//删除的是非叶子结点</span></div><div class="line">                Substitution(p,i);                 	<span class="comment">//寻找相邻关键字(右子树中最小的关键字) </span></div><div class="line">                BTN<span class="function"><span class="title">odeDelete</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i],p-&gt;</span>key[i]); 	<span class="comment">//执行删除操作 </span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Remove(p,i);                    	<span class="comment">//从结点p中位置i处删除关键字</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="function"><span class="title">found_tag</span>=BTNodeDelete(p-&gt;</span>ptr[i],k);    <span class="comment">//沿孩子结点递归查找并删除关键字k</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i]!=NULL)</div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>keynum&lt;Min)          		<span class="comment">//删除后关键字个数小于MIN</span></div><div class="line">                AdjustBTree(p,i);					<span class="comment">//调整B树 </span></div><div class="line">        return found_tag;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void BTreeDelete(BTree &amp;t,KeyType k)&#123;</div><div class="line"><span class="comment">//构建删除框架，执行删除操作  </span></div><div class="line">    BTNode *p;</div><div class="line">	int a=BTNodeDelete(t,k);                 		<span class="comment">//删除关键字k </span></div><div class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)                                    	<span class="comment">//查找失败 </span></div><div class="line">        printf(<span class="string">"   关键字%d不在B树中\n"</span>,k);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(t-&gt;</span>keynum==<span class="number">0</span>)&#123;                          <span class="comment">//调整 </span></div><div class="line">        p=t;</div><div class="line">        <span class="function"><span class="title">t</span>=t-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">        free(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void DestroyBTree(BTree &amp;t)&#123;</div><div class="line"><span class="comment">//递归释放B树 </span></div><div class="line">    int i;  </div><div class="line">    BTNode* p=t;  </div><div class="line">    <span class="keyword">if</span>(p!=NULL)&#123;                                 	<span class="comment">//B树不为空  </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum;i++)&#123;  				<span class="comment">//递归释放每一个结点 </span></div><div class="line">            D<span class="function"><span class="title">estroyBTree</span>(*&amp;p-&gt;</span>ptr[i]);  </div><div class="line">        &#125;  </div><div class="line">        free(p);  </div><div class="line">    &#125;  </div><div class="line">    t=NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">Status InitQueue(LinkList &amp;L)&#123;</div><div class="line"><span class="comment">//初始化队列 </span></div><div class="line">	L=(LNode*)malloc(sizeof(LNode));				<span class="comment">//分配结点空间 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//分配失败				</span></div><div class="line">        return OVERFLOW;</div><div class="line">     L-&gt;next=NULL;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">LNode* CreateNode(BTNode *p)&#123;</div><div class="line"><span class="comment">//新建一个结点 </span></div><div class="line">    LNode *q;</div><div class="line">    q=(LNode*)malloc(sizeof(LNode)); 				<span class="comment">//分配结点空间</span></div><div class="line">    <span class="keyword">if</span>(q!=NULL)&#123;                                    <span class="comment">//分配成功 </span></div><div class="line">    	<span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=p;</div><div class="line">       	<span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    &#125;</div><div class="line">   return q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status Enqueue(LNode *p,BTNode *q)&#123; </div><div class="line"><span class="comment">//元素q入队列</span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">		return ERROR; 								</div><div class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next!=NULL)                            <span class="comment">//调至队列最后 </span></div><div class="line">        <span class="function"><span class="title">p</span>=p-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=CreateNode(q);                          <span class="comment">//生成结点让q进入队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line">Status Dequeue(LNode *p,BTNode *&amp;q)&#123;</div><div class="line"><span class="comment">//出队列，并以q返回值 </span></div><div class="line">	LNode *aq;</div><div class="line">    <span class="function"><span class="title">if</span>(p==NULL||p-&gt;</span>next==NULL) 						<span class="comment">//删除位置不合理 </span></div><div class="line">		return ERROR; </div><div class="line">    <span class="function"><span class="title">aq</span>=p-&gt;</span>next;										<span class="comment">//修改被删结点aq的指针域</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=aq-&gt;</span>next; 								</div><div class="line">    <span class="function"><span class="title">q</span>=aq-&gt;</span><span class="keyword">data</span>;</div><div class="line">    free(aq); 										<span class="comment">//释放结点aq</span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">Status IfEmpty(LinkList L)&#123;</div><div class="line"><span class="comment">//队列判空 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//队列不存在 </span></div><div class="line">		return ERROR;</div><div class="line">    <span class="function"><span class="title">if</span>(L-&gt;</span>next==NULL) 								<span class="comment">//队列为空 </span></div><div class="line">		return TRUE;</div><div class="line">    return FALSE;									<span class="comment">//队列非空 </span></div><div class="line">&#125;</div><div class="line"></div><div class="line">void DestroyQueue(LinkList L)&#123;</div><div class="line"><span class="comment">//销毁队列 </span></div><div class="line">   LinkList p;</div><div class="line">    <span class="keyword">if</span>(L!=NULL)&#123;</div><div class="line">    	p=L;</div><div class="line">       	L=L-&gt;next;</div><div class="line">       	free(p);                                   	<span class="comment">//逐一释放 </span></div><div class="line">        DestroyQueue(L);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Traverse(BTree t,LinkList L,int newline,int sum)&#123;</div><div class="line"><span class="comment">//用队列遍历输出B树 </span></div><div class="line">    int i;</div><div class="line">    BTree p;</div><div class="line">    <span class="keyword">if</span>(t!=NULL)&#123;</div><div class="line">        printf(<span class="string">"  [ "</span>);</div><div class="line">        E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[<span class="number">0</span>]);                      	<span class="comment">//入队         </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=1;i&lt;=t-&gt;</span>keynum;i++)&#123;</div><div class="line">            <span class="function"><span class="title">printf</span>(" %d ",t-&gt;</span>key[i]);</div><div class="line">            E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[i]);					<span class="comment">//子结点入队 </span></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="title">sum</span>+=t-&gt;</span>keynum+<span class="number">1</span>;</div><div class="line">        printf(<span class="string">"]"</span>);</div><div class="line">        <span class="keyword">if</span>(newline==<span class="number">0</span>)&#123;                             <span class="comment">//需要另起一行 </span></div><div class="line">        	printf(<span class="string">"\n"</span>);</div><div class="line">            newline=sum-<span class="number">1</span>;</div><div class="line">            sum=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            newline--;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">if</span>(IfEmpty(L)==FALSE)&#123;                       	<span class="comment">//l不为空 </span></div><div class="line">         Dequeue(L,p);								<span class="comment">//出队，以p返回 </span></div><div class="line">         Traverse(p,L,newline,sum);					<span class="comment">//遍历出队结点 </span></div><div class="line">     &#125;</div><div class="line">     return OK;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line">Status PrintBTree(BTree t)&#123;</div><div class="line"><span class="comment">//输出B树 </span></div><div class="line">   LinkList L;</div><div class="line">    <span class="keyword">if</span>(t==NULL)&#123;</div><div class="line">        printf(<span class="string">"  B树为空树"</span>);</div><div class="line">        return OK;</div><div class="line">    &#125;</div><div class="line">    InitQueue(L);                        			<span class="comment">//初始化队列 </span></div><div class="line">    Traverse(t,L,<span class="number">0</span>,<span class="number">0</span>);								<span class="comment">//利用队列输出 </span></div><div class="line">    DestroyQueue(L);								<span class="comment">//销毁队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Test1()&#123; </div><div class="line">	system(<span class="string">"color 70"</span>);  </div><div class="line">    BTNode *t=NULL;</div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">    int j,n=<span class="number">15</span>;</div><div class="line">    KeyType k;</div><div class="line">    KeyType a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;                           </div><div class="line">    printf(<span class="string">"创建一棵%d阶B树:\n"</span>,m);</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;								<span class="comment">//逐一插入元素 </span></div><div class="line">        s=SearchBTree(t,a[j]);</div><div class="line">        <span class="keyword">if</span>(s.tag==<span class="number">0</span>)</div><div class="line">            InsertBTree(t,s.i,a[j],s.pt);</div><div class="line">        printf(<span class="string">"   第%d步,插入元素%d:\n "</span>,j+<span class="number">1</span>,a[j]);</div><div class="line">        PrintBTree(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"删除操作:\n"</span>);                         	<span class="comment">//删除操作 </span></div><div class="line">    k=<span class="number">9</span>;														</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    k=<span class="number">1</span>;</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"  递归释放B树\n"</span>); 						<span class="comment">//递归释放B树</span></div><div class="line">    DestroyBTree(t);								 </div><div class="line">	PrintBTree(t);</div><div class="line">&#125; </div><div class="line"></div><div class="line">void Test2()&#123;</div><div class="line">	int i,k; </div><div class="line">	system(<span class="string">"color 70"</span>);</div><div class="line">	BTree t=NULL;  </div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">	printf(<span class="string">"此时的B树：\n"</span>);</div><div class="line">	PrintBTree(t); </div><div class="line">	printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"=============Operation Table=============\n"</span>);</div><div class="line">    printf(<span class="string">"   1.Init     2.Insert    3.Delete    \n"</span>);</div><div class="line">    printf(<span class="string">"   4.Destroy  5.Exit  	  \n"</span>);</div><div class="line">    printf(<span class="string">"=========================================\n"</span>);</div><div class="line">    printf(<span class="string">"Enter number to choose operation:_____\b\b\b"</span>);</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;i);</div><div class="line">    switch(i)&#123;</div><div class="line">    	case <span class="number">1</span>:&#123;</div><div class="line">			InitBTree(t);</div><div class="line">			printf(<span class="string">"InitBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		case <span class="number">2</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to InsertBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			s=SearchBTree(t,k);</div><div class="line">			InsertBTree(t,s.i,k,s.pt);</div><div class="line">			printf(<span class="string">"InsertBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">3</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to DeleteBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			BTreeDelete(t,k);</div><div class="line">			printf(<span class="string">"\n"</span>);</div><div class="line">			printf(<span class="string">"DeleteBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">4</span>:&#123;</div><div class="line">			DestroyBTree(t);</div><div class="line">			break;</div><div class="line">			printf(<span class="string">"DestroyBTree successfully.\n"</span>);</div><div class="line">		&#125;</div><div class="line">		case <span class="number">5</span>:&#123;</div><div class="line">			exit(-<span class="number">1</span>);				</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	Test2();</div><div class="line">	return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note success"><p>卡了下代码量<br>521lines<br>Merry christmas！</p></div>]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B树]]></title>
      <url>/2017/11/29/B%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-B树定义<br>-B树操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>B树定义</strong><br>B树，称为多路平衡查找树。B树中所有结点的孩子结点树的最大值称为B树的阶，通常称为m。</p>
<p>一颗m阶B树或为空树，或为满足以下特性的m叉树：<br>1.树中每个结点至多有m棵子树（至多含有m-1个关键字）<br>2.若根结点不是终端结点，则至少有两颗子树<br>3.除根结点外的所有非叶结点至少有【m/2】棵子树。（至少含有【m/2】-1个关键字）【】是向上取整符号。<br>4.所有的叶结点都出现在同一层次上，并且不带信息</p>
<hr>
<p><strong>B树的查找</strong><br>B树的具体查找步骤如下：<br>1.先让key与根结点中的关键字比较，如果key等于k[i]（k[]为结点内的关键字数组），则查找成功</p>
<p>2.若key &lt; k[1],则到p[0]所指示的子树中进行继续查找</p>
<p>3.若key &gt; k[n],则到p[n]所指示的子树中进行继续查找</p>
<p>4.若k[i] &lt; key &lt;  k [i+1],则到p[i]所指示的子树继续查找</p>
<p>5.如果最后遇到空指针，则证明查找不成功</p>
<hr>
<p><strong>B树的插入</strong></p>
<p>对于关键字的插入，需要找到插入位置。在B树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶结点中的插入位置。</p>
<p>为了方便，称最底层的非叶结点为<strong>终端结点</strong>。由此可见，B树结点的插入总是落在终端结点上。在插入过程中有可能破坏B树的特性，如果新关键字的插入使得结点中关键字的个数超过规定个数，这时要进行<strong>结点的拆分</strong>。</p>
<hr>
<p><strong>B树删除</strong><br>对于关键字的删除，需要找到待删除关键字。在结点中删除关键字的过程中也可能破除B树的特性，如旧关键字的删除可能使得结点中关键字的个数少于规定个数，这时可能需要向其兄弟结点借关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并。其中，和当前结点的孩子结点进行关键字的操作可以保证删除操作总是发生在终端结点上。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/11/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-快速排序算法思想<br>-快速排序算法实现<br>-快速排序性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<div class="note success"><p>算法介绍</p></div>
<p>快速排序是“交换”累的排序，通过多次划分操作实现排序。以升序为例，其执行流程可以概括下：每一趟选择当前所有子序列中的一个关键字（通常是第一个）作为枢轴，将子序列中比枢轴小的移到枢轴前面，比枢轴打的移到枢轴后面；当本趟所有子序列都被枢轴以上述规则划分后会得到新的一组更短的子序列。</p>
<hr>
<p><strong>算法思想</strong><br>选第一个为关键字，从右开始找小于他的交换，再从左找大于它的交换，完成一趟排序。依次类推，多趟排序后使序列有序。</p>
<hr>
<p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line"><span class="comment">//对从R[low]到R[r]的关键字排序</span></div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> i=low,j=r;</div><div class="line"><span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">	temp=R[low];</div><div class="line">	<span class="keyword">while</span>(i!=j)&#123;</div><div class="line">		<span class="keyword">while</span>(j&gt;i&amp;&amp;R[i]&gt;=temp)</div><div class="line">			--j;</div><div class="line">		<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">			R[i]=R[j];</div><div class="line">			++i;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;R[i]&lt;temp)</div><div class="line">			++i;</div><div class="line">		</div><div class="line">	<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">		R[j]=R[i];</div><div class="line">		--j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	R[i]=temp;</div><div class="line">	QuickSort(R,low,i<span class="number">-1</span>);</div><div class="line">	QuickSort(R,i+<span class="number">1</span>,high);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>时间复杂度</strong><br>最好情况下，复杂度为O（nlog2n）<br>最坏情况下，复杂度为O（n2）<br>平均情况下，复杂度为O（nlog2n）</p>
<hr>
<p><strong>空间复杂度</strong><br>快速排序是递归进行的，递归需要栈的辅助，算法的空间复杂度为O（log2n）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/11/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-冒泡排序算法思想<br>-冒泡排序算法实现</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>算法介绍</p></div>
冒泡排序又称起泡排序。它是通过一系列的“交换”动作完成的。首先，第一个关键字和第二个关键字比较，如果第一个大，则二者交换，否则不执行交换；然后第二个关键字和第三个关键字比较，如果第二个大，则执行交换，否则不交换......依次执行下去。第一趟冒泡排序完成，最大的关键字被交换到了最后。经过多趟排序，最终使整个序列有序。

起泡排序算法结束的条件是在一趟排序过程中没有发生关键字交换。

---
<div class="note danger"><p>算法实现</p></div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"> <span class="comment">//默认待排序关键字为整型</span></div><div class="line">	<span class="keyword">int</span> i,j,flag;</div><div class="line">	<span class="keyword">int</span> temp;</div><div class="line">	<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</div><div class="line">		flag=<span class="number">0</span>;              <span class="comment">//flag用来标记本趟排序是否发生了交换</span></div><div class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</div><div class="line">			<span class="keyword">if</span>(R[i<span class="number">-1</span>]&gt;R[i])&#123;</div><div class="line">				temp=R[i];</div><div class="line">				R[i]=R[i<span class="number">-1</span>];</div><div class="line">				R[i<span class="number">-1</span>]=temp;</div><div class="line">				flag=<span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">if</span>(flag==<span class="number">0</span>)</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note primary"><p>时间复杂度</p></div>
最坏情况下，每趟都要发生交换，复杂度为O（n2）
最好情况下，每一趟只进行循环，不进行交换，复杂度为O（n）
平均时间下时间复杂度为O（n2）

---
<div class="note default"><p>空间复杂度</p></div>
<p>由算法可知，额外辅助空间只有一个temp，因此空间复杂度为O（1）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/11/26/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-希尔排序算法思想</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>算法介绍</p></div>
希尔排序又叫做缩小增量排序，其本质还是插入排序，只不过是将待排序序列按照某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。这个规则的体现就是增量的选取，如果增量为1，就是直接排序。

增量是逐渐减小的。直接插入排序适合于序列基本有序的情况，希尔排序的每趟排序都会使整个序列变得更加有序，等整个序列基本又虚了，再进行一次直接插入排序，这样会使排序效率更高，这就是希尔排序的思想。

---
<div class="note danger"><p>时间复杂度</p></div>
<p>希尔排序的时间复杂度和增量选取有关，希尔排序的增量选取规则有很多，常见的增量选取规则有以下两个。<br>1.希尔自己提出的选取规则：<br>[n/2],[n/4],…,2,1<br>每次将增量除2向下取整，其中n为序列长度，此时时间复杂度为O（n2）</p>
<p>2.帕佩尔诺夫和斯塔舍维奇提出的选取规则：<br>2的k次方+1,…,65,33,17,9,5,3,1<br>其中，k为大于等于1的整数，2的k次方小于待排序列长度，增量序列末尾的1是额外添加的。此时时间复杂度为O(n1.5)</p>
<hr>
<div class="note primary"><p>空间复杂度</p></div>
<p>希尔排序的空间复杂度同直接插入排序一样，为O（1）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-3]]></title>
      <url>/2017/11/26/Verilog%20HDL-3/</url>
      <content type="html"><![CDATA[<p>-模块与端口</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>模块的组成</p></div>
模块是Verilog HDL设计中的基本功能块，用于描述某个设计的功能或结构，以及它与其他模块进行通信的端口。端口是模块与外部环境交互的接口和通道。

模块定义说明：
1.模块以关键字module开始，并以关键字endmodule结束
2.模块名、端口列表、端口声明和可选的参数声明必须出现在其他部分前面；同样地，为了使模块描述清晰和具有良好的可读性，变量、寄存器、线网和参数等的声明部分必须在使用前出现，放在任何语句的前面。
3.端口是模块和外部环境交互的通道，一个模块可以没有端口
4.模块内部有5个组成部分：变量声明、数据流语句、地层模块实例、行为语句以及任务和函数。
5.对于模块的定义只有关键字module、endmodule和模块名是必须的，其他都是可选的
6.一个Verilog源文件可以包含多个模块，而且对于模块的排列没有要求

---
<div class="note danger"><p>模块的端口定义</p></div>
<p>在模块名的后面紧跟着的就是端口列表，如果模块和外界没有任何交互信号，也可以没有端口列表。</p>
<p>端口列表中的所有端口都必须在模块中进行声明，根据端口的流动方向，端口分为input(输入)、output(输出)和inout(输入/输出双向)三种类型。</p>
<p>所有端口默认的声明为wire型，如果希望输出端口能够保存数据，那就需要显式地将端口声明为reg型；不能将input端口和inout端口设为reg型，因为reg型式用于保存数据的，而输入端口用来反映外界数据的变化，并不可以进行保存。</p>
<hr>
<div class="note primary"><p>模块的调用</p></div>
<p>模块调用语法：<br>模块名    实例名（端口连接关系表）<br>·“模块名”是模块定义的（紧接着module关键字）名称<br>·“实例名”是所调用模块的实例名称<br>·“端口连接关系表”用于说明该模块实例端口所连接的外部信号，它指明了模块实例和外界的连接关系</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-2]]></title>
      <url>/2017/11/26/Verilog%20HDL-2/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note warning"><p>标识符</p></div> 
Verilog HDL中的标识符可以是任意一组字母、数字、$符号和_（下划线）符号的组合。标识符是区分大小写的，第一个字符必须是字母或者下划线，不能以数字和$符号开始。例如:Max,MIN,Four$,_Y2011.

---
<div class="note primary"><p>关键字</p></div> 
<p>关键字时Verilog HDL中预留的表示特定含义的保留标识符，Verilog HDL中的关键字全部是小写的。<br>例如：BEGIN（非关键字）与begin（关键字）是不同的</p>
<hr>
<div class="note danger"><p>注释</p></div>
Verilog HDL有两种形式的注释
风格与C语言一样

---
<div class="note default"><p>编写格式</p></div>
<p>Verilog HDL是自由格式的，代码可以在一行内编写，也可以跨越多行编写。空格、制表符和空白行没有意义。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//举例</span></div><div class="line">initial  begin  pa=<span class="number">0</span>;pb=<span class="number">0</span>;pCin=<span class="number">0</span>;  end</div><div class="line"><span class="comment">//上面代码与下面的是一样的</span></div><div class="line">initial </div><div class="line">	begin</div><div class="line">		pa=<span class="number">0</span>;</div><div class="line">		pb=<span class="number">0</span>;</div><div class="line">		pCin=<span class="number">0</span>;</div><div class="line">	end</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-1]]></title>
      <url>/2017/11/26/Verilog%20HDL-1/</url>
      <content type="html"><![CDATA[<p>-风格描述介绍<br>-测试平台的编写</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>门级风格的描述</p></div> 
<pre><code>数据流风格描述方式是最常用的一种风格，用数据流描述方式对一个设计建模的最基本机制就是使用连续赋值语句。在连续赋值语句中，线网类型变量被赋予某个值，右边表达式的操作时无论何时发生变化，表达式都要重新计算，计算结果被赋予左边表达式的线网类型变量。
</code></pre>

---
<div class="note warning"><p>数据流风格的描述</p></div> 
<pre><code>数据流风格描述方式是最常用的一种风格，用数据流描述方式对一个设计建模的最基本机制就是使用连续赋值语句。在连续赋值语句中，线网类型变量被赋予某个值，右边表达式的操作时无论何时发生变化，表达式都要重新计算，计算结果被赋予左边表达式的线网类型变量。
</code></pre><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> mux<span class="number">_f</span>low(<span class="keyword">out</span>,a,b,sel);</div><div class="line">	input a,b,sel;</div><div class="line">	output <span class="keyword">out</span>;</div><div class="line">	<span class="keyword">assign</span> <span class="keyword">out</span>=(sel)?b:a;      <span class="comment">//连续赋值</span></div><div class="line">endmodule</div></pre></td></tr></table></figure>
<hr>
<div class="note primary"><p>行为风格的描述</p></div> 
行为风格使用initial语句（语句只执行一次）和always语句（重复执行），只有变量类型数据能够在这两种语句中被赋值，所有initial语句和always语句在0时刻开始并发执行
undefined

---
<div class="note danger"><p>测试平台的编写</p></div> 
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">module testMux;</div><div class="line">	reg pa,pb,psel;</div><div class="line">	wire pout;</div><div class="line">	mux_beha tmux(pout,pa,pb,psel);      <span class="comment">//调用</span></div><div class="line"></div><div class="line">   initial</div><div class="line">	   begin</div><div class="line">		   pa=<span class="number">0</span>;pb=<span class="number">0</span>;psel=<span class="number">0</span>;<span class="comment">//赋初值</span></div><div class="line">		   #<span class="number">5</span> pa=<span class="number">1</span>;  <span class="comment">//五个单位时间延迟后进行赋值</span></div><div class="line">		   #<span class="number">5</span> pb=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">0</span>;</div><div class="line">		   #<span class="number">5</span> psel=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pb=<span class="number">0</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">0</span>;</div><div class="line">		end</div><div class="line"> </div><div class="line"> initial</div><div class="line">	 $monitor(<span class="string">"time=%t,a=%b.b=%b,sel=%b,out=%b"</span>,$time,pa,pb,psel,pout);</div><div class="line">	 <span class="comment">//调用系统任务$monitor，当pa、pb、psel、pout中任一个发生变化时就输出显示</span></div><div class="line">endmodule</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-6]]></title>
      <url>/2017/11/26/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-6<br>-广义表部分</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>/<strong><strong>**</strong></strong><br>【题目】试按依次对每个元素递归分解的分析方法重写求广义表的深度的递归算法。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> GListDepth(GList <span class="keyword">ls</span>)</div><div class="line"><span class="comment">/* Return the depth of list */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> h1,h2;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">ls</span>==NULL)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">ls</span>-&gt;tag==ATOM)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    h1=GListDepth(<span class="keyword">ls</span>-&gt;un.ptr.hp)+<span class="number">1</span>;</div><div class="line">    h2=GListDepth(<span class="keyword">ls</span>-&gt;un.ptr.tp);</div><div class="line">    <span class="keyword">return</span> h1&gt;h2?h1:h2;</div><div class="line">              </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写判别两个广义表是否相等的递归算法。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Status Equal(GList A, GList B)</div><div class="line"><span class="comment">/* 判断广义表A和B是否相等,是则返回TRUE,否则返回FALSE */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(A-&gt;tag==ATOM&amp;&amp;B-&gt;tag==ATOM)</div><div class="line">        <span class="keyword">if</span>(A-&gt;un.atom==B-&gt;un.atom)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(A-&gt;tag==<span class="keyword">LIST</span>&amp;&amp;B-&gt;tag==<span class="keyword">LIST</span>)</div><div class="line">        <span class="keyword">if</span>(Equal(A-&gt;un.ptr.hp,B-&gt;un.ptr.hp)&amp;&amp;Equal(A-&gt;un.ptr.tp,B-&gt;un.ptr.tp))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写递归算法，输出广义表中所有原子项及其所在层次。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void OutAtom<span class="comment">(GList A, int layer, void(*Out2)</span><span class="comment">(char, int)</span>)</div><div class="line"><span class="comment">/* 递归地用函数Out2输出广义表的原子及其所在层次,layer表示当前层次 */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span><span class="comment">(A)</span>&#123;</div><div class="line">        <span class="keyword">if</span><span class="comment">(A-&gt;tag==ATOM)</span></div><div class="line">            Out<span class="number">2</span><span class="comment">(A-&gt;un.atom,layer)</span>;</div><div class="line">        else&#123;</div><div class="line">            OutAtom<span class="comment">(A-&gt;un.ptr.hp,layer+1,Out2)</span>;</div><div class="line">            OutAtom<span class="comment">(A-&gt;un.ptr.tp,layer,Out2)</span>;</div><div class="line">        &#125;</div><div class="line">   &#125;         </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[折半插入排序]]></title>
      <url>/2017/11/26/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-折半插入算法介绍</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>折半插入排序</p></div>
<p>如果线性表是有序的，进行查找可以用折半查找来实现。在确定出待插入位置后，就可以统一的向后移动元素了。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line">	int i,j,low,high,mid;</div><div class="line">	for(i=<span class="number">2</span>;i&lt;=n;i++)&#123;           <span class="comment">//依次将A[2]~A[n]插入到前面已排好序的序列中</span></div><div class="line">		A[<span class="number">0</span>]=A[i];               <span class="comment">//将A[i]暂存到A[0]</span></div><div class="line">		low=<span class="number">1</span>;</div><div class="line">		high=i<span class="number">-1</span>;                <span class="comment">//设置查找范围</span></div><div class="line">		while(low&lt;=high)&#123;</div><div class="line">			mid=(low+high)/<span class="number">2</span>;    <span class="comment">//去中间点</span></div><div class="line">			if(A.[mid].<span class="type">key</span>&gt;A[<span class="number">0</span>].<span class="type">key</span>)</div><div class="line">				high=mid<span class="number">-1</span>;      <span class="comment">//查询左子表</span></div><div class="line">				else</div><div class="line">					low=mid+<span class="number">1</span>;   <span class="comment">//查询右子表</span></div><div class="line">			&#125;</div><div class="line">		for(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</div><div class="line">			A[j+<span class="number">1</span>]=A[j];         <span class="comment">//统一后移元素，空出插入位置</span></div><div class="line">		A[high+<span class="number">1</span>]=A[<span class="number">0</span>];          <span class="comment">//插入操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述算法中，不难看出折半插入排序仅仅是减少了比较元素的次数，约为O（nlog2n），该比较次数与待排序表的初始状态无关，仅取决于表中元素个数n；而元素的移动次数没有改变，它取决于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O（n2）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[直接插入排序]]></title>
      <url>/2017/11/23/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1/</url>
      <content type="html"><![CDATA[<p>-直接插入排序算法简介<br>-直接插入排序算法分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>插入排序</p></div>
<p>插入排序是一种简单直观的排序方法，其基本思想在于每次将一个待排序的记录，按其关键字大小插入到前面已经排序的子序列中，知道全部记录插入完成。</p>
<hr>
<p><strong>直接插入排序</strong><br>为了实现将元素L(i)插入到已有序的子序列L[1…i-1]，需要执行以下操作：<br>1.查找出L(i)在L[1…i-1]中的插入位置k<br>2.将L[k…i-1]中所有元素全部后移一个位置<br>3.将L[i]复制到L[k]</p>
<p>为了实现排序，将L(2)~L(n)依次插入到前面已排好序的子序列中，初始假定L[1]是一个已排好序的子序列。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line"><span class="comment">//直接插入排序算法</span></div><div class="line">	int i,j;</div><div class="line">	for(i=<span class="number">2</span>;i&lt;=n;i++)             <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></div><div class="line">		if(A[i].<span class="type">key</span>&lt;A[i<span class="number">-1</span>].<span class="type">key</span>)&#123;  <span class="comment">//若A[i]的关键码小于其前驱，需将A[i]插入到有序表</span></div><div class="line">			A[<span class="number">0</span>]=A[i];            <span class="comment">//复制为哨兵</span></div><div class="line">			for(j=i<span class="number">-1</span>;A[<span class="number">0</span>].<span class="type">key</span>&lt;A[j].<span class="type">key</span>;--j)  <span class="comment">//从后往前查找待插入位置</span></div><div class="line">				A[j+<span class="number">1</span>]=A[j];      <span class="comment">//复制到插入位置</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>性能分析</strong><br>空间效率：使用了常数个辅助单元，空间复杂度为O（1）<br>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。<br>在最好的情况下，表中元素已经有序，每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O（n）<br>在最坏的情况下，表中顺序刚好与排序结果中元素顺序相反时，总的比较次数达到最大，为2+3+…+n，总的移动次数也达到最大，3+4+…+n+1.<br>平均情况下，考虑待排序表中的元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与移动次数约为n2/4.</p>
<p>由此，直接插入排序算法的时间复杂度为O（n2）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>/2017/11/22/%E6%8E%92%E5%BA%8F-1/</url>
      <content type="html"><![CDATA[<p>-排序简介</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>排序</p></div>
<p>排序就是重新排列表中的元素，使表中的元素满足按关键字递增或递减的过程</p>
<hr>
<div class="note danger"><p>算法稳定性</p></div>
<p>如果待排序表中有两个元素Ri、Rj，其对应关键字keyi=keyj，且在排序前Ri在Rj的前面，如果使用某一排序算法后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的<br>算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述</p>
<hr>
<div class="note info"><p>内部排序</p></div>
<p>指在排序期间元素全部存放在内存中的排序</p>
<hr>
<div class="note primary"><p>外部排序</p></div>
<p>指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并查集]]></title>
      <url>/2017/11/22/%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8--%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>-并查集的基本操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>并查集的操作</strong><br>并查集是一种简单的集合表示，它支持一下三种操作：<br>1.Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合Root1中。要求Root1和Root2互不相交，否则不执行合并。<br>2.Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的名字。<br>3.Initial(S)：将集合S中每一个元素都初始化为只有一个单元素的子集合。</p>
<p>通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的树，存放在双亲表示数组内。通常用数组元素的下标代表元素名，根结点的下标代表子集合名，根结点的双亲结点为负数。</p>
<hr>
<p>为了得到两个子集合的并，只要将其中一个子集合根结点的双亲之争指向另一个集合的根结点即可。<br>在采用树的双亲指针表示作为并查集的存储表示时，集合元素编号从0到size-1，其中size是最大元素的个数</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//并查集的结构定义</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></div><div class="line"><span class="keyword">int</span> UFSets[SIZE];            <span class="comment">//集合元素数组（双亲指针数组）</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//并查集的初始化操作</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)        <span class="comment">//每个自成单元素集合</span></div><div class="line">		S[i]=<span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Find操作（函数在并查集S中查找并返回包含元素x的树的根）</span></div><div class="line"><span class="keyword">Int</span> <span class="keyword">Find</span>(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)&#123;</div><div class="line">	<span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)         <span class="comment">//循环查找x的根</span></div><div class="line">		x=S[x];</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Union操作(函数求两个不相交子集合的并集)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</div><div class="line">	<span class="comment">//要求Root1与Root2是不同的，且表示子集合的名字</span></div><div class="line">	S[Root2]=Root1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树、森林与二叉树的转换]]></title>
      <url>/2017/11/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>-树型结构的相互转换</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p>由于二叉树和树都可以用二叉链表作为存储结构，则以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树，可以找到唯一的一颗二叉树与之对应。从物理结构上看，树的孩子兄弟表示法语二叉树的二叉链表表示法相同，即每个结点共有两个指针，分别指向结点第一个孩子和结点的下一兄弟结点，而二叉链表使用双指针。因此，就可以用同一存储结构的不同解释将一棵树转换为二叉树。</p>
<hr>
<p><strong>树转换成二叉树</strong><br>每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为“左孩子右兄弟”。由于根结点没有兄弟，所以，由树转换而得的二叉树没有右子树。</p>
<p><img src="http://img.blog.csdn.net/20171122094256947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><strong>森林转换成二叉树</strong><br>将森林转换成二叉树的规则与树类似。先将森林中的每一棵树转换成二叉树，再将第一棵树的根作为转换后的二叉树的根，第一棵树的左子树作为转换后二叉树根的左子树，第二棵树作为转换后二叉树根的右子树，第三棵树作为转换后二叉树根的右子树的右子树，以此类推。</p>
<hr>
<p><strong>二叉树转换成森林</strong><br>若二叉树非空，则二叉树根及其左子树为第一棵树的二叉树形式，二叉树根的右子树可以看作是一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后产生一颗没有右子树的二叉树为止，这样就得到了原森林。</p>
<hr>
<p><strong>树转换成二叉树的画法</strong><br>1.在兄弟结点之前加一连线<br>2.对每一个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉<br>3.以树根为轴心，顺时针旋转45</p>
<hr>
<p><strong>森林转换成二叉树的画法</strong><br>1.将每棵树的根相连<br>2.将森林中的每棵树转换成相应的二叉树<br>3.以第一棵树的根为轴心顺时针旋转45</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树与森林]]></title>
      <url>/2017/11/21/%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97/</url>
      <content type="html"><![CDATA[<p>-树的存储结构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>树的存储结构</strong><br>树的存储方式有多种，可以采用顺序存储结构，也可以采用链式存储结构。</p>
<hr>
<p><strong>双亲表示法</strong><br>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br><img src="http://img.blog.csdn.net/20171121224128464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双亲表示法的存储结构</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100            <span class="comment">//树中最多结点数</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                      <span class="comment">//树中结点定义</span></div><div class="line">	ElemType data;                   <span class="comment">//数据元素</span></div><div class="line">	<span class="keyword">int</span> parent;                      <span class="comment">//双亲位置域</span></div><div class="line">&#125;PTNode;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                     <span class="comment">//树类型的定义</span></div><div class="line">	PTNode nodes[MAX_TREE_SIZE];    <span class="comment">//双亲表示</span></div><div class="line">	<span class="keyword">int</span> n;                          <span class="comment">//结点数</span></div><div class="line">&#125;PTree;</div></pre></td></tr></table></figure>
<hr>
<p><strong>孩子表示法</strong><br>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，则N个结点就有N个孩子结点（叶子结点的孩子链表为空表）<br>对于这种存储方式寻找子女的操作非常直接，但是寻找双亲的操作需要遍历N个结点中孩子链表指针域所指向的N个孩子链表。</p>
<hr>
<p><strong>孩子兄弟表示法</strong><br>孩子兄弟表示法又称为二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针。<img src="http://img.blog.csdn.net/20171121231935558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//孩子兄弟表示法的存储结构描述如下：</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></div><div class="line">	ElemType data;                           <span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></div><div class="line">&#125;CSNode,*CSTree;</div></pre></td></tr></table></figure>
<p>这种存储表示法灵活，最大优点是可以方便的将树转换为二叉树，易于查找结点的孩子等，但缺点是从当前结点寻找其双亲结点比较麻烦。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平衡二叉树]]></title>
      <url>/2017/11/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-平衡二叉树及调整规律</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>平衡二叉树的定义</strong><br>为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树，简称平衡树(AVL树)。</p>
<p><strong>平衡因子</strong><br>定义结点的左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子只可能为-1,0,1。</p>
<hr>
<p><strong>平衡二叉树的插入</strong><br>二叉排序树保证平衡的基本思想：每当在二叉排序树中插入（或删除）一个结点时，首先要检查其插入路径上的结点是否因为此次操作导致了不平衡。如果导致了不平衡，则先要找到插入路径上离插入结点最近的平衡因子绝对值大于1的结点，再对A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p>
<hr>
<p><strong>失衡调整规律</strong><br>1.LL平衡旋转（右单旋转）<br>由于在结点A的左孩子B（L）的左子树BL（L）上插入了新结点，该结点的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行一次向右的旋转操作。<br>将A的左孩子向右上旋转成为根结点，将A结点向右下旋转称为B的右子树的根结点，而B的原右子树BR成为A结点的左子树。</p>
<p>2.RR平衡旋转<br>由于在结点A的右孩子B（R）的右子树BR（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行一次向左的旋转操作。<br>将A的右孩子B向左上旋转成为根结点，将A结点向左下旋转成为B的左子树根结点，将B的原左子树作为A结点的右子树。</p>
<p>3.LR平衡旋转（先左后右双旋转）<br>由于在A的左孩子B（L）的右子树BR（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。<br>先将A的左孩子B的右子树的根结点向左上旋转到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。</p>
<p>4.RL平衡旋转（先右后左双旋转）<br>由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。<br>先将A结点的右孩子B的左子树的根结点C向右上旋转提升至B结点的位置，然后再把该C结点向左上旋转到A的位置。<br><img src="http://img.blog.csdn.net/20171121131347624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><strong>平衡二叉树的查找</strong><br>在平衡二叉树上进行查找的过程和二叉排序树相同，因此，在查找的过程中和给定值进行比较的关键字个数不超过树的深度。假设以Nh表示深度为h的平衡树中含有的最少结点树。显然，N0=1，N1=1,N2=2，并且有Nh=Nh-1+Nh-2+1.可以证明含有n个结点平衡二叉树的最大深度为log2n，因此，平衡二叉树的平均查找长度为O(log2n).</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++数据类型]]></title>
      <url>/2017/11/20/C++%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>-接近拖了一个月了才继续…</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>变量名命名规则</strong><br>·在名称中只能使用字母字符、数字和下划线（_）<br>·名称的第一个字符不能是数字<br>·区分大写字符与小写字符<br>·不能将C++关键字用作名称<br>·以两个下划线或下划线和大写字母打头的名称全部被保留给实现<br>·C++对于名称的长度没有限制</p>
<hr>
<p><strong>整型</strong><br>C++的基本整型有char，short，int，long和long long</p>
<p>C++提供了一种灵活的标准，它确保了最小长度：<br>·short至少16位<br>·int至少与short一样长<br>·long至少32位，且至少与int一样长<br>·long long至少64位，且至少与long一样长</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明变量</span></div><div class="line"><span class="keyword">short</span> score;</div><div class="line"><span class="keyword">int</span> temperature;</div><div class="line"><span class="keyword">long</span> <span class="built_in">position</span>;</div></pre></td></tr></table></figure>
<p>sizeof运算符可以用来返回类型或变量的长度</p>
<hr>
<p><strong>变量初始化</strong><br>初始化将赋值与声明合并在一起<br>可以将变量初始化成字面值，可以将变量初始化为另一个变量，条件是后者已经被定义过<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">int uncles</span>=5;</div><div class="line"><span class="attribute">int aunts</span>=uncles;</div><div class="line"><span class="attribute">int chairs</span>=aunts+uncles+4;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++初始化方式</span></div><div class="line"><span class="keyword">int</span> hamburgers=&#123;<span class="number">24</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">wren</span><span class="params">(<span class="number">432</span>)</span></span>;</div></pre></td></tr></table></figure>
<hr>
<p><strong>无符号类型</strong><br>要创建无符号版本的基本整型，只需在关键词unsigned来修改声明即可</p>
<hr>
<p><strong>char类型</strong><br>char类型是专为存储字符而设计的<br>char最常被用来处理字符，但也可以用做比short更小的整型</p>
<p>cout.put()函数可以用来输出单个字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">'s'</span>;     <span class="comment">//输出s字符对应的整数值</span></div><div class="line"><span class="built_in">cout</span>.put(<span class="string">'s'</span>);    <span class="comment">//输出s字符</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>bool类型</strong><br>bool类型用来表示真和假<br>字面值true和false可以通过提升转换为int类型，true被转换为1，而false被转换为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans=<span class="literal">true</span>;        <span class="comment">//1</span></div><div class="line"><span class="keyword">int</span> promise=<span class="literal">false</span>;   <span class="comment">//0</span></div><div class="line"><span class="keyword">bool</span> start=<span class="number">-100</span>;     <span class="comment">//true</span></div><div class="line"><span class="keyword">bool</span> stop=<span class="number">0</span>;         <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>const限定符</strong><br>与#define类似，const也是用来处理符号常量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> months=<span class="number">12</span>;</div><div class="line"><span class="comment">//months是int类型常量12</span></div><div class="line"><span class="comment">//无法修改</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>浮点数</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//书写浮点数的方式</span></div><div class="line">double a=<span class="number">12.34</span>;</div><div class="line">dounle b=<span class="number">2.52e+8</span>;</div></pre></td></tr></table></figure></p>
<p>C++有三种浮点类型：float,duble,long double.<br>通常float为32位，double为64位</p>
<p>在默认情况下，浮点常量属于double类型。希望常量为float类型，则使用f或F后缀。对于long double类型，使用l或L后缀</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉排序树]]></title>
      <url>/2017/11/20/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-二叉排序树的基本操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉排序树的定义</strong><br>二叉排序树，也称为二叉查找树。<br>二叉排序树要么是空树，要么是具有以下特征的非空二叉树：<br>·若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字值<br>·若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字值<br>·左右子树本身也是一颗二叉排序树</p>
<p>根据二叉排序树的定义，有左子树结点值&lt;根结点值&lt;右子树结点值<br>因此，如果对二叉排序树进行中序遍历，可以得到一个递增的序列</p>
<hr>
<p><strong>二叉排序树的查找</strong><br>二叉排序树的查找是从根结点开始，沿某一个分支逐层向下进行比较的过程。若二叉排序树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当根结点的关键字大于给定关键字时，在根结点的左子树中查找，否则在根结点的右子树中查找。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//二叉排序树的非递归查找算法</div><div class="line">BSTNode *BST_Search(BiTree <span class="literal">T</span>,ElemType key,BSTNode *&amp;p)&#123;</div><div class="line">	//查找函数返回指向关键字为key的节点指针，若不存在，则返回<span class="literal">NULL</span></div><div class="line">	p=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>&amp;&amp;key!=<span class="literal">T</span>-&gt;data)&#123;</div><div class="line">		p=<span class="literal">T</span>;</div><div class="line">		<span class="keyword">if</span>(key&lt;<span class="literal">T</span>-&gt;data)</div><div class="line">			<span class="literal">T</span>=<span class="literal">T</span>-&gt;lchild;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="literal">T</span>=<span class="literal">T</span>-&gt;rchild;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">T</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的插入</strong><br>二叉树作为一种动态集合，其特点是树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入<br>由于二叉排序树是递归定义，插入结点的过程是，若原二叉排序树为空，则直接插入结点。若关键字k小于根结点关键字，则插入到左子树中，若关键字k大于根结点关键字，则插入到右结点中。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int BST_Insert(BiTree &amp;<span class="literal">T</span>,KeyType k)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)&#123;</div><div class="line">		<span class="literal">T</span>=(BiTree)malloc(sizeof(BSTNode));</div><div class="line">		<span class="literal">T</span>-&gt;data=k;</div><div class="line">		<span class="literal">T</span>-&gt;lchild=<span class="literal">T</span>-&gt;rchild=<span class="literal">NULL</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">else</span>	<span class="keyword">if</span>(<span class="literal">T</span>-&gt;data=k)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">T</span>-&gt;data&gt;k)    //左子树中插入</div><div class="line">		<span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;lchild,k);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">T</span>-&gt;data&lt;k)   //右子树中插入</div><div class="line">		<span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;rchild,k);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的构造</strong><br>构造一颗二叉排序树就是依次输入数据元素，并将它们插入到二叉排序树中的适当位置上的过程。具体过程是，每读入一个元素，就建立一个结点，若二叉排序树非空，则将新节点的值与根结点的比较，如果小于根结点，插入到左子树中，否则插入到右子树中；<br>若二叉排序树为空，则新节点作为二叉排序树的根结点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T,KeyTypestr [],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="comment">//用关键字数组str [] 建立一个二叉排序树</span></div><div class="line">	T=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(i&lt;n)&#123;   <span class="comment">//依次读入元素</span></div><div class="line">		BST_Insert(T,str[i]);</div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的删除</strong><br>删除操作有三种情况：<br>1.如果被删除结点z是叶结点，直接进行删除操作即可<br>2.如果结点z只有一颗左子树或右子树，则让z的子树成为z父结点的子树<br>3.如果结点z有左右两颗子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），转换成第一或第二种情况。（中序遍历的下一个）（不断取左子树的最大或者右子树的最小递归删除）</p>
<hr>
<p><strong>二叉排序树的查找效率分析</strong><br>对于高度为H的二叉排序树，其插入和删除操作的运行时间都是O(H).<br>但在最坏的情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的二叉树，高度也增加为元素个数N</p>
<p>二叉排序树查找算法的平均查找长度，主要取决于树的高度，即与二叉树的形态有关。<br>如果二叉排序树是只有左（右）孩子的二叉树，算法复杂度为O(n).如果是平衡二叉树，算法复杂度为O（log2n）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线索二叉树]]></title>
      <url>/2017/11/13/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-6天回归战场<br>-希望有个好成绩吧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>线索二叉树基本概念</strong><br>二叉树的遍历就是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到，二叉树结点的各种遍历序列。二叉树遍历的实质就是对一个非线性结构进行线性化操作，使在这个访问序列中每一个结点（除第一个和最后一个）都有一个直接前驱和直接后继。<br>传统的链式存储只能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。通过观察，我们发现在二叉链表表示的二叉树中存在大量的空指针，若利用这些空链域存放指向其直接前驱或后继的指针，便可以更方便地运用某些二叉树的操作算法。引入线索二叉树是为了加快查找结点前驱和后继的速度。</p>
<p><strong>在有N个结点的二叉树中，有N+1个空指针。</strong>这是因为每一个叶子结点有两个空指针，而每一个度为1的结点有一个空指针，总计2N0+N1，又有N0=N2+1，所以，总的空指针为N+1.</p>
<hr>
<p><strong>线索化</strong><br>在二叉树线索化时，通常规定：若无左子树，令lchild指向其前驱结点；若无右结点，令rchild指向其后继结点。因此，需要增加两个标志域表明当前指针域所指对象是指向左（右）子结点还是直接前驱（后继）。</p>
<p><img src="http://img.blog.csdn.net/20171113114056883" alt="这里写图片描述"><br>其中标志域的含义：<br>ltag=0 时lchild指向左子女；<br>ltag=1 时lchild指向前驱；<br>rtag=0 时rchild指向右子女；<br>rtag=1 时rchild指向后继；</p>
<p>线索二叉树的存储结构描述如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></div><div class="line">	ElemType data;                       <span class="comment">//数据元素</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>   <span class="comment">//左、右孩子指针</span></div><div class="line">	<span class="keyword">int</span> ltag,rtag;                       <span class="comment">//左右线索标志</span></div><div class="line">&#125;ThreadNode,*ThreadTree;</div></pre></td></tr></table></figure></p>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>，其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p>
<hr>
<p><strong>线索二叉树的构造</strong><br>对二叉树的线索化，实质上就是遍历一次二叉树，在遍历过程中，检查当前结点左、右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。</p>
<p>通过中序遍历对二叉树线索化的递归算法如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void InThread(ThreadTree &amp;p,ThreadTree &amp;pre)&#123;</div><div class="line">	<span class="comment">//中序遍历对二叉树线索化的递归算法</span></div><div class="line">		<span class="keyword">if</span>(p!=NULL)&#123;</div><div class="line">			I<span class="function"><span class="title">nThread</span>(p-&gt;</span>lchild,pre);       <span class="comment">//递归，线索化左子树</span></div><div class="line"> 			<span class="function"><span class="title">if</span>(p-&gt;</span>lchild==NULL)&#123;           <span class="comment">//左子树为空，建立前驱线索</span></div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span>lchild=pre;</div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span>ltag=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="title">if</span>(pre!=NULL&amp;&amp;pre-&gt;</span>rchild==NULL)&#123;</div><div class="line">				<span class="function"><span class="title">pre</span>-&gt;</span>rchild=p;             <span class="comment">//建立前驱结点的后继线索</span></div><div class="line">				<span class="function"><span class="title">pre</span>-&gt;</span>rtag=<span class="number">1</span>;               </div><div class="line">			&#125;</div><div class="line">			pre=p;                         <span class="comment">//标记当前结点称为刚刚访问过的结点</span></div><div class="line">			I<span class="function"><span class="title">nThread</span>(p-&gt;</span>rchild,pre);       <span class="comment">//递归，线索化右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过中序遍历建立中序线索二叉树的主过程算法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</div><div class="line">	ThreadTree pre=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;              <span class="comment">//非空二叉树，线索化</span></div><div class="line">		InThread(T,pre);      <span class="comment">//线索化二叉树</span></div><div class="line">		pre-&gt;rchild=<span class="literal">NULL</span>;     <span class="comment">//处理遍历的最后一个结点</span></div><div class="line">		pre-&gt;rtag=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>线索二叉树的遍历</strong><br>中序线索化二叉树主要是为了访问运算服务的，这种遍历不再需要借助栈，因为它的结点中隐含了线索二叉树的前驱和后继。利用线索二叉树，可以实现二叉树遍历而非递归算法。不含头结点的线索二叉树的遍历算法如下：<br>1.<strong>求中序线索二叉树中中序序列下的第一个结点</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadNode *Firstnode(ThreadNode *p)&#123;</div><div class="line">	<span class="keyword">while</span>(p-&gt;ltag=<span class="number">0</span>)</div><div class="line">		p=p-&gt;lchild;    <span class="regexp">//</span>最左下结点</div><div class="line">	<span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<strong>求中序线索二叉树中结点p在中序序列下的后继结点</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ThreadNode *Nextnode(ThreadNode *p)&#123;</div><div class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)                   </div><div class="line">		<span class="keyword">return</span> Firstnode(p-&gt;rchild);</div><div class="line">	<span class="keyword">else</span> <span class="comment">//rtag==1直接返回后继线索</span></div><div class="line">		<span class="keyword">return</span> p-&gt;rchild;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<strong>利用上面两个算法，写出不含头结点的中序线索二叉树的中序遍历算法</strong><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void Inorder(<span class="name">ThreadNode</span> *T)&#123;</div><div class="line">	for(ThreadNode *p=Firstnode(<span class="name">T</span>)<span class="comment">; p!=NULL; p=Nextnode(p))</span></div><div class="line">		visit(<span class="name">p</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-3]]></title>
      <url>/2017/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91-3/</url>
      <content type="html"><![CDATA[<p>-遍历二叉树</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉树的遍历</strong><br>所谓二叉树的遍历，是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且只被访问一次。<br>由二叉树的递归定义可知，遍历一颗二叉树便要决定对根结点N，左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）、后序（LRN）三种遍历算法。</p>
<hr>
<p><strong>先序遍历</strong><br>先序遍历的操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.访问根结点<br>2.先序遍历左子树<br>3.先序遍历右子树</p>
<p>对应的递归算法如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void PreOrder<span class="comment">(BiTree T)</span>&#123;</div><div class="line">	<span class="keyword">if</span><span class="comment">(T!=NULL)</span>&#123;               </div><div class="line">		visit<span class="comment">(T)</span>;              <span class="comment">//访问根结点 </span></div><div class="line">		PreOrder<span class="comment">(T-&gt;lchild)</span>;   <span class="comment">//递归遍历左子树</span></div><div class="line">		PreOrder<span class="comment">(T-&gt;rchild)</span>;   <span class="comment">//递归遍历右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>中序遍历</strong><br>中序遍历的操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.中序遍历左子树<br>2.访问根结点<br>3.中序遍历右子树</p>
<p>对应的递归算法如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Inorder(BiTree T)&#123;</div><div class="line">	<span class="keyword">if</span>(T!=NULL）</div><div class="line">		I<span class="function"><span class="title">norder</span>(T-&gt;</span>lchild);   <span class="comment">//递归遍历左子树</span></div><div class="line">		visit(T);             <span class="comment">//访问根结点  </span></div><div class="line">		I<span class="function"><span class="title">norder</span>(T-&gt;</span>rchild);   <span class="comment">//递归遍历右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>后序遍历</strong><br>后序遍历操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.后序遍历左子树<br>2.后序遍历右子树<br>3.访问根结点</p>
<p>对应的递归算法如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void PostOrder(BiTree <span class="literal">T</span>)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</div><div class="line">		PostOrder(<span class="literal">T</span>-&gt;lchild);</div><div class="line">		PostOrder(<span class="literal">T</span>-&gt;rchild);</div><div class="line">		visit(<span class="literal">T</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>不管是哪种便利算法，每个结点都只访问一次，时间复杂度都是O（n）</strong></p>
<hr>
<p><strong>递归算法与非递归算法的转换</strong><br>可以借助栈，将二叉树的递归算法转换成非递归算法</p>
<p>以中序遍历为例，给出非递归算法的实现<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void InOrder2(BiTree T)&#123;</div><div class="line">	<span class="comment">//二叉树中序遍历的非递归算法，算法需要借助一个栈</span></div><div class="line">	InitStack(S);                 <span class="comment">//初始化栈</span></div><div class="line">	BiTree p=T;                   <span class="comment">//p是遍历指针</span></div><div class="line">	<span class="keyword">while</span>(p||!IsEmpty(s))&#123;        <span class="comment">//栈不空或p不空时循环</span></div><div class="line">		<span class="keyword">if</span>(p)&#123;                    <span class="comment">//根指针进栈，遍历左子树</span></div><div class="line">			Push(S,p);            <span class="comment">//没遇到非空二叉树先向左走</span></div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;                     <span class="comment">//根指针退栈，访问根结点，遍历右子树  </span></div><div class="line">			Pop(S,p);             <span class="comment">//退栈，访问根结点 </span></div><div class="line">			visit(p);              </div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;          <span class="comment">//再向右子树走</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先扫描（并非访问）根结点的所有左结点并将它们一一进栈。然后出战一个结点<em>p（显然结点</em>p没有左孩子结点或者左孩子结点均已访问过），则访问它。然后扫描该结点的右孩子结点，将其进栈，再扫描该右孩子结点的所有左结点并一一进栈，如此继续，直到栈空为止。<br>显然，非递归算法的执行效率要高于递归算法。</p>
<hr>
<p><strong>层次遍历</strong><br>二叉树的层次遍历，即按照箭头所指方向，按照1,2,3,4的层次顺序，对二叉树中各个结点进行访问。<br>要进行层次遍历，需要借助一个队列。先将二叉树的结点入队，然后出队，访问该结点，如果它有左子树，则将左子树根结点入队；如果它有右子树，则将右子树根结点入队。然后出队，对出队结点进行访问，如此反复，直到队列为空。</p>
<p>二叉树的层次遍历算法如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">LevelOrder</span>(BiTree T)&#123;</div><div class="line">	<span class="selector-tag">InitQueue</span>(Q);                    <span class="comment">//初始化辅助队列</span></div><div class="line">	<span class="selector-tag">BiTree</span> <span class="selector-tag">p</span>;                        </div><div class="line">	<span class="selector-tag">EnQueue</span>(Q,T);                    <span class="comment">//将根结点入队</span></div><div class="line">	<span class="selector-tag">while</span>(!IsEmpty(Q))&#123;              <span class="comment">//队列不空循环</span></div><div class="line">		<span class="selector-tag">DeQueue</span>(Q,p);                <span class="comment">//队头元素出队  </span></div><div class="line">		<span class="selector-tag">visit</span>(p);                    <span class="comment">//访问当前结点</span></div><div class="line">		<span class="selector-tag">if</span>(p-&gt;lchild!=NULL)          <span class="comment">//左子树不空，左子树入队列</span></div><div class="line">			<span class="selector-tag">EnQueue</span>(Q,p-&gt;lchild);</div><div class="line">		<span class="selector-tag">if</span>(p-&gt;rchild!=NULL)          <span class="comment">//右子树不空，右子树入队列</span></div><div class="line">			<span class="selector-tag">EnQueue</span>(Q,p-&gt;rchild);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>由遍历序列构造二叉树</strong><br>由二叉树的先序序列和中序序列可以唯一地确定一颗二叉树，在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这颗二叉树。<br>同理，由二叉树的后序序列和中序序列也可以唯一地确定一颗二叉树，因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，就可以得到一颗二叉树。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-2]]></title>
      <url>/2017/11/12/%E4%BA%8C%E5%8F%89%E6%A0%91-2/</url>
      <content type="html"><![CDATA[<p>-二叉树存储结构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉树的存储结构</strong><br><strong>1.顺序存储结构</strong><br>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在某个数组下标为i-1的分量中，然后通过一些办法确定结点在逻辑上的父子和兄弟关系。</p>
<p>对于完全二叉树和满二叉树采用顺序存储比较合适<br>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点让其每个结点与完全二叉树上的结点相对照。用0表示其中并不存在的结点。</p>
<hr>
<p><strong>2.链式存储结构</strong><br>顺序存储对空间利用率是非常低的，因此，一般二叉树都采用链式存储结构。<br>链式结构使用一个链表来存储一颗二叉树，二叉树中每一个结点用链表的一个链结点来存储。<br>二叉链表至少包含三个域：<strong>数据域data、左指针域lchild、右指针域rchild</strong></p>
<p>二叉树的链式存储结构描述如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></div><div class="line">	ElemType data;     <span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左、右孩子指针</span></div><div class="line">&#125;BiTNode,*BiTree;</div></pre></td></tr></table></figure></p>
<p>使用不同的存储结构，实现二叉树操作的算法也会完全不同。因此要选择合适的存储结构。<br><strong>容易验证，在含有n个结点的二叉链表中含有n+1个空链域</strong></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-1]]></title>
      <url>/2017/11/12/%E4%BA%8C%E5%8F%89%E6%A0%91-1/</url>
      <content type="html"><![CDATA[<p>-终于度过了低迷期</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>1.二叉树的定义</strong><br>二叉树是一种树形结构，其特点是每个节点至多只有两颗子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<p><strong>二叉树与度为2的有序树的区别</strong><br>1.度为2的树至少有三个结点，而二叉树可以为空<br>2.度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，如果某个结点只有一个孩子结点，这个孩子结点就无需区分其左右次序</p>
<p><strong>结点编号方式</strong><br>自上而下，自左向右<br>对于一个编号为i的结点，如果有双亲，双亲编号为i/2，如果有左孩子，左孩子编号为2i；如果有右孩子，则右孩子为2i+1；</p>
<hr>
<p><strong>特殊的二叉树</strong><br><strong>满二叉树</strong>：一颗高度为h，并且含有2的h次方-1个结点的二叉树称为满二叉树，树中每一层都含有最多的结点。</p>
<p><strong>完全二叉树</strong>：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。换言之，就是每一个结点都与高度为h的满二叉树的结点一一对应。</p>
<p><img src="http://img.blog.csdn.net/20171110155605187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>二叉排序树</strong>：左子树上所有结点的关键字均小于根结点的关键字；右子树上所有节点的关键字均大于根结点的关键字。左子树和右子树又各是一颗二叉排序树。</p>
<p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的深度之差不超过1</p>
<hr>
<p><strong>二叉树的性质</strong><br>1.非空二叉树上叶子结点数N0等于度为2的结点树加1，即N0=N2+1</p>
<ol>
<li>非空二叉树上第k层上只是多有2的H次方-1个结点</li>
<li>高度为H的二叉树中至多有2的H次方-1个结点</li>
<li>对完全二叉树按从上到下，从左到右的顺序依次编号，有以下关系：<br>①当i&gt;1,结点i的双亲结点编号为i/2，即当i为偶数时，其双亲结点编号为i/2，它是双亲结点的左结点；当i为奇数时，其双亲结点的编号为(i-1)/2，它是双亲结点的右孩子<br>②当2i≤N时，结点i的左孩子编号为2i，否则无左孩子<br>③当2i+1≤N时，结点i的右孩子编号为2i+1，否则无右孩子<br>④结点i所在深度为log2i+1<br>5.具有N个结点的完全二叉树的高度为log2(N+1)或log2N+1</li>
</ol>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2>]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-5]]></title>
      <url>/2017/11/10/Anyview%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-5<br>-递归基础<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试编写如下定义的递归函数的递归算法:<br>    g(m,n) = 0             当m=0,n&gt;=0<br>    g(m,n) = g(m-1,2n)+n   当m&gt;0,n&gt;=0<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 如果 m&lt;0 或 n&lt;0 则返回 -1 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&gt;<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)</div><div class="line">       <span class="keyword">return</span> G(m<span class="number">-1</span>,<span class="number">2</span>*n)+n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写出求递归函数F(n)的递归算法：<br>    F(n) = n+1      当n=0<br>    F(n) = nF(n/2)  当n&gt;0<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"><span class="comment">/* 如果 n&lt;0 则返回 -1 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n*F(n/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p<em>p-A|&lt;e<br>  sqrt(A,p,e) = sqrt(A,(p+A/p)/2,e) 当|p</em>p-A|&gt;=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的递归算法。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">float</span> A, <span class="keyword">float</span> p, <span class="keyword">float</span> e)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p*p-A)&lt;e)</div><div class="line">       <span class="keyword">return</span> p;</div><div class="line">    <span class="keyword">else</span></div><div class="line">       <span class="keyword">return</span> Sqrt(A,(p+A/p)/<span class="number">2</span>,e); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知Ackerman函数的定义如下：<br>   akm(m,n) = n+1                 当m=0<br>   akm(m,n) = akm(m-1,1)          当m!=0,n=0<br>   akm(m,n) = akm(m-1,akm(m,n-1)) 当m!=0,n!=0<br>请写出递归算法。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Akm</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"><span class="comment">/* 若 m&lt;0 或 n&lt;0 则返回-1  */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Akm(m<span class="number">-1</span>,<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;n!=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Akm(m<span class="number">-1</span>,Akm(m,n<span class="number">-1</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写出求递归函数F(n)的非递归算法：<br>    F(n) = n+1      当n=0<br>    F(n) = nF(n/2)  当n&gt;0<br><strong><strong>**</strong></strong>/<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> F(<span class="keyword">int</span> n)</div><div class="line"><span class="comment">/* 如果 n&lt;0 则返回 -1 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i=n,<span class="keyword">count</span>=<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;        </div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i=i/<span class="number">2</span>)</div><div class="line">            <span class="keyword">count</span>=<span class="keyword">count</span>*i;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p<em>p-A|&lt;e<br>  sqrt(A,p,e) = sqrt(A,(p+A/p)/2,e) 当|p</em>p-A|&gt;=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的非递归算法。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">float</span> A, <span class="keyword">float</span> p, <span class="keyword">float</span> e)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">float</span> mp=p;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p*p-A)&lt;e)</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">while</span>(<span class="built_in">fabs</span>(mp*mp-A)&gt;=e)</div><div class="line">            mp=(mp+A/mp)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> mp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设以二维数组g[1..m][1..n]表示一个图像<br>区域，g[i][j]表示该区域中点(i,j)所具颜色，其值<br>为从0到k的整数。试编写递归算法，将点(i0,j0)所在<br>区域的颜色置换为颜色c。约定与(i0,j0)同色的上、<br>下、左、右的邻接点为同色区域的点。</p>
<p>表示图像区域的类型定义如下：<br>typedef char GTYPE[m+1][n+1];<br><strong><strong>**</strong></strong>/<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void ChangeColor(GTYPE g, int m, int n, </div><div class="line">                 char c, int <span class="built_in">i0</span>, int <span class="built_in">j0</span>)</div><div class="line"><span class="comment">/* 在g[1..m][1..n]中，将元素g[i0][j0] */</span></div><div class="line"><span class="comment">/* 所在的同色区域的颜色置换为颜色c    */</span></div><div class="line">&#123;   </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>&gt;m||<span class="built_in">j0</span>&gt;n)</div><div class="line">         <span class="built_in">return</span>;  </div><div class="line"> </div><div class="line">     int <span class="built_in">color</span>;  </div><div class="line">     <span class="built_in">color</span>=g[<span class="built_in">i0</span>][<span class="built_in">j0</span>];  </div><div class="line">     g[<span class="built_in">i0</span>][<span class="built_in">j0</span>]=c; </div><div class="line">      </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>-<span class="number">1</span>&gt;=<span class="number">1</span>)//判断是否越界，下同       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>-<span class="number">1</span>][<span class="built_in">j0</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>-<span class="number">1</span>,<span class="built_in">j0</span>);                        </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>+<span class="number">1</span>&lt;=m)       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>+<span class="number">1</span>][<span class="built_in">j0</span>]==<span class="built_in">color</span>)         </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>+<span class="number">1</span>,<span class="built_in">j0</span>);                    </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">j0</span>-<span class="number">1</span>&gt;=<span class="number">1</span>)       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>][<span class="built_in">j0</span>-<span class="number">1</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>,<span class="built_in">j0</span>-<span class="number">1</span>);                    </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">j0</span>+<span class="number">1</span>&lt;=n)           </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>][<span class="built_in">j0</span>+<span class="number">1</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>,<span class="built_in">j0</span>+<span class="number">1</span>);                    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑模拟-2]]></title>
      <url>/2017/11/06/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%A8%A1%E6%8B%9F-2/</url>
      <content type="html"><![CDATA[<p>-2013题型<br><a id="more"></a></p>
<hr>
<p><strong>推理题之CP规则</strong><br>一般用于S-&gt;T的类型<br>将S作为附加前提<br>推导出T<br>这就是CP规则的用法</p>
<hr>
<p><strong>证明代数系统</strong><br>先确定集合为非空集合<br>再保证运算在该集合上是封闭运算</p>
<hr>
<p><strong>主析取范式与主合取范式的转换</strong><br>若有主析取范式<br>G=m1+m2+m3+m5+m7<br>则¬G=m0+m4+m6<br>主合取范式为G=¬m0+¬m4+¬m6</p>
<hr>
<p><strong>单射双射满射</strong><br>单射就是只能一对一，不能多对一，满射就是不论一对一，还是多对一，在映射f:X→Y中，Y中任一元素y都是X中某元素的像，也就是Y中所有元素在X中都能找到原像，至于找到的只有一个原像,那就是双射，但有的可以找到一个以上的那就不是双射，即双射就是既是单射又是满射。<br>单射：一对一<br>满射：不管映射方式，保证每个元素都有对应的<br>双射：一一对应<br><img src="http://img.blog.csdn.net/20171106205147588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<hr>
<p><strong>同态同构</strong><br>C是从A-B的映射<br>A中封闭运算为a，B中封闭运算为b<br>C（x a y）=C（x） b  C（y）<br>称为<strong>同态</strong><br>C为单射，满射，双射时<br>分别称C是<strong>单一同态，满同态，同构</strong></p>
<hr>
<p><strong>证明一个代数系统为半群</strong><br>半群性质：满足结合律</p>
<hr>
<p><strong>证明一个代数系统是群</strong><br>运算满足结合律<br>有幺元<br>每个元素都有逆元</p>
<hr>
<p><strong>求元素的周期</strong><br>求幺元e<br>求使元素a的n次方等于e的最小正整数</p>
<hr>
<p><strong>循环群与生成元</strong><br>每个元素都能用一个元素g的n次方表示，称为循环群<br>g为一个生成元</p>
<hr>
<p><strong>拉格朗日定理结论</strong><br>1.阶为n的有限群中，对任意a∈ G，有a的n次方等于e（e为幺元）<br>2.素数阶有限群G都是循环群，除了幺元外的所有元素都是它的生成元</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑模拟-1]]></title>
      <url>/2017/11/04/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%A8%A1%E6%8B%9F-1/</url>
      <content type="html"><![CDATA[<p>-2015题型<br><a id="more"></a><br><strong>求公式的主合取范式</strong><br>先消去公式中的<strong>→</strong>与<strong>↔</strong><br>如果需要补基础元(P)，可以使用<strong>∧(P∨¬P）</strong>或者<strong>∨（P∧¬P）</strong><br>接着进行结合的调换，调成主合取范式<br>（主析取范式也是如此）</p>
<hr>
<p><strong>已知主析取范式求主合取范式</strong><br>将所有的主析取范式剩下的极小项转换成极大项<br>再用合取连接起来<br>这样就得到了主合取范式<br>（已知主合取范式求主析取范式的过程类似）</p>
<hr>
<p><strong>证明过程题</strong><br>US：全称特指<br>ES：存在特指<br>UG：全称推广<br>EG：存在推广<br>P：引用<br>T：推理</p>
<hr>
<p><strong>代数系统题</strong><br>结合律，交换律，幂等律（a<em>a=a），消去律（a</em>x=a<em>y），分配律，吸收律（x-(x</em>y)=x）<br>幺元（单位元）<br>零元（a<em>b=b</em>a=b）<br>逆元（a*b=e）</p>
<hr>
<p><strong>群与陪集</strong><br>求陪集的方法：<br>以右陪集为例；<br>用子群与群中每一元素进行二元运算，删除重复部分，即为陪集</p>
<hr>
<p><strong>拉格朗日定理</strong><br>子群的阶记为m，有限群的阶记为n，子群的陪集个数为k<br>首先n一定是m的倍数，即n能被m整除<br>k=n/m<br>由此可计算陪集的个数</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑复习笔记-2]]></title>
      <url>/2017/10/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      <content type="html"><![CDATA[<p>-必考题解法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>利用真值表技术求某公式的主析取范式和主合取范式（一般是大题）</strong><br>1.先列出真值表（真值表中不需要列出极大项和极小项）<br>2.根据真值表中的公式等于1对应的情况写出极小项，构造主析取范式<br>3.根据剩余极小项，进行取反获得主合取范式<br><img src="http://img.blog.csdn.net/20171031090255154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171031090053020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>先列真值表<br>再求主析取范式<br>再根据主析取范式求主合取范式</p>
<hr>
<p><strong>求某公式的主析取范式和主合取范式（选择填空题）</strong><br>如果是要同时求主析取范式和主合取范式，先看公式容不容易化简，否则用真值表技术</p>
<p>如果只是求主析取范式和主合取范式中的一个，可以尝试用<strong>分析法</strong>，直接去分析什么情况下公式等于0或什么情况下公式等于1，一般取范式不会太长，所以只用做一个极大项或极小项的<strong>排除</strong>，即简化真值表操作</p>
<hr>
<p><strong>几大元的定义</strong><br><strong>消去元</strong>：存在一个元素a∈A对于任意的x,y∈A，都有a<em>x=a</em>y，即可以消去a，a称为消去元<br><strong>幂等元</strong>：若元素a∈A，且满足a<em>a=a，则a称为A关于“</em>”的幂等元<br><strong>幺元（单位元）</strong>：对于任意a∈A，存在e∈A，使得a<em>e=e</em>a=a，则称e为幺元（单位元）<br><strong>零元</strong>：对于任意a∈A，存在b∈A，使得a<em>b=b</em>a=b,则称b为零元<br><strong>逆元</strong>：e是幺元，a∈A，存在b∈A，使得a<em>b=b</em>a=e，则称a是b的逆元（可倒置）</p>
<p>幺元对应1<br>零元对应0<br>逆元对应倒数</p>
<hr>
<p><strong>代数系统定义</strong><br><strong>代数系统</strong>：集合和定义在集合上的n元封闭运算称为代数系统<br><strong>广群</strong>：二元运算不加限制的一般代数系统<br><strong>半群</strong>：若代数系统中的二元运算满足结合律，则称为半群<br><strong>循环半群</strong>：存在a∈A，对任意x∈S，有x=a^n,则称此代数系统为循环半群<br><strong>生成元</strong>：循环半群中的a，称为循环半群的一个生成元<br><strong>群</strong>：二元运算满足结合律，存在幺元，每个元素都有逆元，这样的二元代数系统称为群</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑复习笔记-1]]></title>
      <url>/2017/10/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<p>-模糊概念<br><a id="more"></a></p>
<hr>
<p><strong>量词辖域的确定方法</strong>：<br>1.若量词后有括号，则括号内的子公式就是量词的辖域<br>2.若量词后没有括号，则与量词邻接的子公式就是该量词的辖域</p>
<hr>
<p><strong>约束变元的改名规则</strong>：<br>1.将量词中出现的变元以及该量词辖域中此变量所有约束出现都用新的个体变元替换<br>2.新的变元一定要有别于改名辖域中的所有其他变量</p>
<p><strong>自由变元的代入规则</strong>：<br>1.将公式中出现该自由变元的每一处都用新的个体变元替换<br>2.新变元不允许在原公式中以任何约束形式出现</p>
<hr>
<p><strong>前束范式的转换方法</strong>：<br>设G施任一公式，通过下述步骤可将其转换为与之等价的前束范式<br>1.消去公式中包含的联结词“-&gt;””&lt;-&gt;”<br>2.反复运用德摩根定律，直接将“¬”內移到原子谓词公式的前端<br>3.使用谓词的等价公式将所有量词提到公式的最前端</p>
<hr>
<p><strong>求Skolem标准型的方法</strong>：<br>将原公式中的前置量词逐一消去，存在量词替换成一些特定的字母，全称量词可以不变，但是，如果存在量词在全称量词后方，应转换成用全称量词表示的函数</p>
<hr>
<p><strong>使用推理规则注意</strong>：<br><strong>使用US规则来消去量词时，所选用取代x的变量y在公式中必须是自由的</strong></p>
<p><strong>使用ES规则来消去量词时，若还有其他自由变元时，必须用关于自由变元的函数符号来取代常数符号</strong></p>
<p><strong>使用UG规则来添加量词时，所使用的的变元符号不能与辖域内的变元符号相同</strong></p>
<p><strong>使用EG规则来添加量词时，所使用的的变元符号不能与辖域内的变元符号相同</strong></p>
<hr>
<p><strong>谓词演算综合推理方法</strong>：<br>1.推导过程中可以引用命题演算中的规则P和规则T<br>2.如果结论是以条件形式给出，可以使用规则CP<br>3.若需消去量词，可以引用规则US和ES<br>4.当所需要的结论可能被定量时，此时可引用规则UG和EG将量词加入</p>
<hr>
<p><strong>代数系统判断方法</strong>：<br>判断集合A和其上代数运算是否为代数系统，关键是判断两点：<br>1.集合A非空<br>2.这些运算在A上是否满足封闭性</p>
<hr>
<p><strong>特殊元计算方法</strong>：<br>计算幺元，零元，幂等元等特殊元时，首先可以假设这些元存在，然后根据定义直接得到方程，解这个方程计算这些元，如果无解则不存在，如果有解还要进一步验证是否是对应的特殊元</p>
<hr>
<p><strong>证明同态与同构</strong>：<br>首先可以假设f就是同态或同构映射，然后利用同态，同构的定义，导出f的一些性质，并利用这些性质来构造同态与同构映射，从而证明代数系统的同态与同构</p>
<hr>
<p><strong>群的性质</strong>：<br>满足结合律<br>有幺元<br>每个元有逆元</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDOJ-1001]]></title>
      <url>/2017/10/30/HDOJ-1001/</url>
      <content type="html"><![CDATA[<p>-simple<br>-sum problem<br><a id="more"></a></p>
<hr>
<p>Sum Problem</p>
<p>Time Limit: 1000/500 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 500758    Accepted Submission(s): 127099</p>
<p>Problem Description<br>Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge).</p>
<p>In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n.</p>
<p>Input<br>The input will consist of a series of integers n, one integer per line.</p>
<p>Output<br>For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer.</p>
<p>Sample Input<br>1<br>100</p>
<p>Sample Output<br>1</p>
<p>5050</p>
<hr>
<p>sum问题，注意下中间多一个空行就好</p>
<hr>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> i,sum=<span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)&#123;</div><div class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=x;i++)  </div><div class="line">        sum+=i;</div><div class="line">	 <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     sum=<span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> HDOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDOJ-1000]]></title>
      <url>/2017/10/30/HDOJ-1000/</url>
      <content type="html"><![CDATA[<p>-simple<br>-A+B problem<br><a id="more"></a></p>
<hr>
<p>A + B Problem</p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 701093    Accepted Submission(s): 216996</p>
<p>Problem Description<br>Calculate A + B.</p>
<p>Input<br>Each line will contain two integers A and B. Process to end of file.</p>
<p>Output<br>For each case, output A + B in one line.</p>
<p>Sample Input<br>1 1</p>
<p>Sample Output<br>2</p>
<hr>
<p>简单A+B题</p>
<hr>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> x,y;</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y)</div><div class="line">	     <span class="built_in">cout</span>&lt;&lt;x+y&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> HDOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[静电场-2]]></title>
      <url>/2017/10/30/%E9%9D%99%E7%94%B5%E5%9C%BA-2/</url>
      <content type="html"><![CDATA[<p>-电通量<br>-静电场中的高斯定理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>电场线</strong>：用于形象描述电场在空间的分布情况</p>
<p>电场线有如下性质：<br>1.电场线起自正电荷（或来自无穷远），终止于负电荷（或伸向无限远），在无电荷的地方不会中断<br>2.任意两条电场线不相交，即静电场中每一点的场强只有一个方向<br>3.电场线不形成闭合回线<br>4.电场强处电场线密集，电场弱处电场线稀疏</p>
<hr>
<p><strong>电通量</strong>：穿过电场中任意给定面的电场线条数称为通过该面的电场强度通量</p>
<p>均匀电场中，穿过垂直于电场方向的任意平面S的电通量为<strong>φ=ES</strong>，若与场强成θ角，则<strong>φ=EScosθ</strong></p>
<p>如果是曲面，则通过dS的电通量为：<strong>dφ=EdScosθ=E·dS</strong><br>通过整个曲面S的电通量为<strong>φ=∫s（dφ）=∫s（E·dS）</strong></p>
<p><strong>如果是闭合曲面，则规定由内向外的方向为个面积元法矢en的正方向</strong></p>
<hr>
<p><strong>高斯定理</strong>：静电场的高斯定理表述为：真空中任何静电场中，穿过任一闭合曲面的电通量等于该闭合曲面包围电荷代数和的ε0分之一，即<br><strong>φ=∫s（E·dS）=（1/ε0）∑qi</strong></p>
<p>对高斯定理的理解应注意：<br>1.高斯定理表达式作坊的场强E是闭合面上dS处的场强，它是由闭合面内外全部电荷共同产生的，即闭合面外的电荷对空间各点的E有贡献，要影响闭合面上各面元的通量dφ<br>2.通过闭合曲面的总电通量只决定于闭合面内所包围的电荷，闭合曲面外部的电荷对闭合面的总电通量∫E·dS无贡献.</p>
<hr>
]]></content>
      
        <categories>
            
            <category> 大学物理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> basic courses </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开始学习C++]]></title>
      <url>/2017/10/30/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/</url>
      <content type="html"><![CDATA[<p>-C++基础介绍</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>Hello world</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  //预处理器编译指令</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">//编译指令</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   <span class="comment">//函数头</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"HelloWorld"</span>&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//cout语句输出，endl换行</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;   <span class="comment">//C++注释用“//......”或者“/* ...... */”来进行注释</span></div></pre></td></tr></table></figure></p>
<p>如C一般，这种程序在运行完之后立即关闭，需要加一句<code>cin.get();</code>语句来保持打开状态，直到按任何键才关闭。</p>
<p>using编译指令使得std名称空间中的所有名称都可用，例如：可以直接使用cout和cin，而不用加std：：前缀。</p>
<hr>
<p><strong>C++语句</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int i<span class="comment">; //声明语句</span></div><div class="line"><span class="attribute">i</span>=<span class="number">1</span><span class="comment">;  //赋值语句</span></div></pre></td></tr></table></figure></p>
<p>除此之外，C++还有许多的其他语句，循环等。</p>
<hr>
<p><strong>类简介</strong><br>类是面向对象编程的核心概念之一，也是JAVA语言的核心，C++的优势在于既可以面向过程，也可以面向对象，是一种综合编程语言。类定义描述的是数据格式及其用法，而对象是根据数据格式规范创建的实体</p>
<hr>
<p><strong>关键字</strong><br>C++中有int,double,new等关键字，这些关键字都是C++专用的，不能用于自定义变量名，函数名……</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[静电场-1]]></title>
      <url>/2017/10/29/%E9%9D%99%E7%94%B5%E5%9C%BA-1/</url>
      <content type="html"><![CDATA[<p>-电荷基础<br>-电场基础</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>自然界只存在正负两种电荷，同种电荷相互排斥，异种电荷相互吸引</p>
<p><strong>电荷守恒定律</strong>：在一个孤立系统内，无论发生怎样的物理过程，系统内电荷的代数和是不变的，这个结论称为电荷守恒定律</p>
<p>任何带电体所带电量都是某一基本电量的整数倍，这一基本电量就是电子所带电量的绝对值，以e表示，电荷的这一特性称为<strong>电荷的量子化</strong></p>
<p>电子的电量大小为<strong>$e=1.602*10^-19C$</strong></p>
<p>实验证明，粒子所带的电荷量与其运动状态无关。例如：加速器将质子或电子加速时，随着它们速度的变化，其质量变化是显著的，但是电荷却没有任何变化。这一性质叫<strong>电荷的相对论不变性</strong></p>
<hr>
<p><strong>库仑定律</strong>：真空中两个静止点电荷之间的相互作用力大小与这两个点电荷量q1和q2的乘积成正比，与他们之间距离r的平方成反比，作用力的方向沿它们的连线方向，同号电荷相斥，异号电荷相吸</p>
<p>库伦定律可以用矢量式表示为<strong>$F=kq1q2/(r^2)$</strong></p>
<p>1.当F＞0时，F与r同方向表示斥力；当F＜0时，F与r反方向表示引力<br>2.比例系数k写成<strong>$k=1/(4πε0)$</strong></p>
<p>因此，库仑定律可以写成<strong>$F=1/(4πε0) *q1q2/(r^2)$</strong></p>
<hr>
<p>静电场重要的对外表现有：<br>1.力的表现；放入电场中的电荷要受到电场的作用力<br>2.功的表现；电荷在静电场中移动式，电场力将对电荷做功</p>
<p><strong>电场强度</strong>：用E表示，<strong>E=F/q0</strong>，电场中某一点的电场强度等于单位正电荷在该点受到的电场力</p>
<p><strong>场强叠加定理</strong>：<strong>E=E1+E2+…+En</strong><br>点电荷系电场中任一点的电场强度等于各点电荷单独存在时在该点产生的场强的矢量和</p>
<p>若将实验电荷q0放在距离q为r的P点，则q0所受的电场力为<strong>F=(1/4πε0)<em>(q</em>q0/(r^3)*r)</strong><br>因此场强<strong>E=F/q0=(1/4πε0)<em>(q/(r^3)</em>r)</strong></p>
<hr>
<p><strong>任意带电体的场强</strong><br>真空中一电荷连续分布的任意带电体，把带电体看成许多电荷元dq组成，电荷元dq可视为点电荷，它在场点P产生的场强为dE<br>由此可得：<strong>dE=F/q0=(1/4πε0)<em>(dq/(r^3)</em>r)</strong></p>
<p>由场强叠加原理，<strong>E=∫dE=(1/4πε0)<em>∫(dq/(r^3)</em>r)</strong></p>
<hr>
]]></content>
      
        <categories>
            
            <category> 大学物理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> basic courses </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1048题解]]></title>
      <url>/2017/10/28/ZOJ-1048/</url>
      <content type="html"><![CDATA[<p>-简单的求均值题</p>
<a id="more"></a>
<p>Financial Management<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB</p>
<p>Larry graduated this year and finally has a job. He’s making a lot of money, but somehow never seems to have enough. Larry has decided that he needs to grab hold of his financial portfolio and solve his financing problems. The first step is to figure out what’s been going on with his money. Larry has his bank account statements and wants to see how much money he has. Help Larry by writing a program to take his closing balance from each of the past twelve months and calculate his average account balance.</p>
<p>Input Format: </p>
<p>The input will be twelve lines. Each line will contain the closing balance of his bank account for a particular month. Each number will be positive and displayed to the penny. No dollar sign will be included.</p>
<p>Output Format: </p>
<p>The output will be a single number, the average (mean) of the closing balances for the twelve months. It will be rounded to the nearest penny, preceded immediately by a dollar sign, and followed by the end-of-line. There will be no other spaces or characters in the output. </p>
<p>Sample Input: </p>
<p>100.00<br>489.12<br>12454.12<br>1234.10<br>823.05<br>109.20<br>5.27<br>1542.25<br>839.18<br>83.99<br>1295.01<br>1.75</p>
<p>Sample Output: </p>
<p>$1581.42</p>
<hr>
<p>简单的入门题，输入求均值输出就行</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt; </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">float</span> a[<span class="number">12</span>];</div><div class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	<span class="keyword">float</span> sum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		sum+=a[i];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"$"</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;sum/<span class="number">12</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1037题解]]></title>
      <url>/2017/10/28/ZOJ-1037/</url>
      <content type="html"><![CDATA[<p>-注意提交格式！</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>Gridland<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB<br>Background</p>
<p>For years, computer scientists have been trying to find efficient solutions to different computing problems. For some of them efficient algorithms are already available, these are the “easy” problems like sorting, evaluating a polynomial or finding the shortest path in a graph. For the “hard” ones only exponential-time algorithms are known. The traveling-salesman problem belongs to this latter group. Given a set of N towns and roads between these towns, the problem is to compute the shortest path allowing a salesman to visit each of the towns once and only once and return to the starting point.</p>
<p>Problem</p>
<p>The president of Gridland has hired you to design a program that calculates the length of the shortest traveling-salesman tour for the towns in the country. In Gridland, there is one town at each of the points of a rectangular grid. Roads run from every town in the directions North, Northwest, West, Southwest, South, Southeast, East, and Northeast, provided that there is a neighbouring town in that direction. The distance between neighbouring towns in directions North-South or East-West is 1 unit. The length of the roads is measured by the Euclidean distance. For example, Figure 7 shows 2 <em> 3-Gridland, i.e., a rectangular grid of dimensions 2 by 3. In 2 </em> 3-Gridland, the shortest tour has length 6.</p>
<p>Figure 7: A traveling-salesman tour in 2 * 3-Gridland.</p>
<p>Input</p>
<p>The first line contains the number of scenarios.</p>
<p>For each scenario, the grid dimensions m and n will be given as two integer numbers in a single line, separated by a single blank, satisfying 1 &lt; m &lt; 50 and 1 &lt; n &lt; 50.</p>
<p>Output</p>
<p>The output for each scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. In the next line, print the length of the shortest traveling-salesman tour rounded to two decimal digits. The output for every scenario ends with a blank line.</p>
<p>Sample Input</p>
<p>2<br>2 2<br>2 3</p>
<p>Sample Output</p>
<p>Scenario #1:<br>4.00</p>
<p>Scenario #2:<br>6.00 </p>
<hr>
<p>题目大意：先给案例个数，每个案例有两个数，作为长宽，然后以此来走，求走完所有点的最短长度</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> x,y;</div><div class="line">	<span class="keyword">int</span> count=<span class="number">1</span>;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>);</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Scenario #"</span>&lt;&lt;count&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;y%<span class="number">2</span>==<span class="number">1</span>)  <span class="comment">//都是奇数 </span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;(<span class="keyword">double</span>)(x*y+<span class="number">0.41</span>)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;(<span class="keyword">double</span>)(x*y)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>; </div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>submit了几次才成功，也是很久没有做OJ题了。<br>主要的问题都不大，就是要注意下格式，不然就会Presentation Error</p>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1001题解]]></title>
      <url>/2017/10/28/ZOJ-1001/</url>
      <content type="html"><![CDATA[<p>……</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>A + B Problem<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB</p>
<p>Calculate a + b<br>Input<br>The input will consist of a series of pairs of integers a and b,separated by a space, one pair of integers per line.<br>Output<br>For each pair of input integers a and b you should output the sum of a and b in one line,and with one line of output for each line in input.<br>Sample Input<br>1 5<br>Sample Output<br>6<br>Hint<br>Use + operator</p>
<hr>
<p>解题思路：没有什么思路，直接加输出就是了</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> a,b;  </div><div class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)&#123;  </div><div class="line">     <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树]]></title>
      <url>/2017/10/28/%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-树的定义与基本性质<br><a id="more"></a><br><strong>树</strong>：树是N（N≥0）个结点的有限集合，N=0时，称为空树。<br>在任意一棵非空树中应满足：<br>1.有且仅有一个特定的称为<strong>根</strong>的结点<br>2.当N&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，称为根结点的<strong>子树</strong></p>
<p>显然树的定义是递归的，是一种递归的数据结构。树作为一种逻辑结构，同时也使一种分层结构，具有以下两个特点：<br>1.树的根结点没有前驱结点之外，所有结点有且仅有一个前驱结点<br>2.树的所有节点可以有零个或多个后继结点</p>
<p><strong>由特点2可以推出，在n个结点的树中有n-1条边</strong></p>
<hr>
<p><strong><font size="5">基本术语</font></strong><br><strong>度</strong>：树中一个结点的子结点个数称为该结点的度，树中结点的最大度数称为树的度<br><strong>分支结点</strong>：度大于0的结点称为分支结点（又称非终端结点）<br><strong>叶子结点</strong>：度为0（没有子女结点）的结点称为叶子结点（又称终端结点）<br><strong>树的高度（深度）</strong>：树中结点的最大层数<br><strong>有序树与无序树</strong>：树中结点的子树从左到右是有次序的，不能交换，这样的树叫做有序树，有序树中，一个结点其子结点按从左到右顺序出现时有关联的。反之称为无序树<br><strong>路径与路径长度</strong>：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数<br><strong>森林</strong>：森林是m(m≥0)棵互不相交的树的集合</p>
<hr>
<p><strong><font size="5">树的基本性质</font></strong><br>1.树中结点数等于所有结点的度数加一<br>2.度为m的树中第i层上至多有m^i-1个结点<br>3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点<br>4.具有n个结点的m叉树的最小高度为[logm(n(m-1)+1)]</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-4]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-4<br><a id="more"></a></p>
<p>/<strong><strong>**</strong></strong><br>【题目】已知某哈希表的装载因子小于1，哈希函数H(key)<br>为关键字(标识符)的第一个字母在字母表中的序号，处理<br>冲突的方法为线性探测开放定址法。试编写一个按第一个<br>字母的顺序输出哈希表中所有关键字的算法。<br>哈希表的类型HashTable定义如下：</p>
<p>#define SUCCESS    1</p>
<p>#define UNSUCCESS  0</p>
<p>#define DUPLICATE -1<br>typedef char StrKeyType[4];<br>typedef struct {<br>   StrKeyType key; // 关键字项<br>   int    tag;     // 标记 0:空；1:有效; -1:已删除<br>   void  <em>any;     // 其他信息<br>} RcdType;<br>typedef struct {<br>  RcdType </em>rcd;    // 存储空间基址<br>  int      size;   // 哈希表容量<br>  int      count;  // 表中当前记录个数<br>} HashTable;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PrintKeys(HashTable ht, <span class="keyword">void</span>(*<span class="built_in">print</span>)(StrKeyType))</div><div class="line"><span class="comment">/* 依题意用print输出关键字 */</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> n,i,<span class="built_in">size</span>;</div><div class="line">    <span class="built_in">char</span> c;</div><div class="line">    <span class="keyword">for</span>(c=<span class="string">'A'</span>;c&lt;=<span class="string">'Z'</span>;c++)&#123;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ht.<span class="built_in">size</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(ht.rcd[i].tag==<span class="number">-1</span>) </div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(ht.rcd[i].<span class="built_in">key</span>[<span class="number">0</span>]==c)</div><div class="line">                <span class="built_in">print</span>(ht.rcd[i].<span class="built_in">key</span>);</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设哈希表长为m，哈希函数为H(x)，用链地址法<br>处理冲突。试编写输入一组关键字并建造哈希表的算法。<br>哈希表的类型ChainHashTab定义如下：</p>
<p>#define NUM         7</p>
<p>#define NULLKEY    -1</p>
<p>#define SUCCESS     1</p>
<p>#define UNSUCCESS   0</p>
<p>#define DUPLICATE  -1<br>typedef char HKeyType;<br>typedef struct HNode {<br>   HKeyType  data;<br>   struct HNode<em>  next;<br>}</em>HLink;<br>typedef struct {<br>   HLink  <em>rcd;   // 指针存储基址，动态分配数组<br>   int    count;  // 当前表中含有的记录个数<br>   int    size;  // 哈希表的当前容量<br>}ChainHashTab;    // 链地址哈希表<br>int Hash(ChainHashTab H, HKeyType k) { // 哈希函数<br>  return k % H.size;<br>}<br>Status Collision(ChainHashTab H, HLink &amp;p) {<br>  // 求得下一个探查地址p<br>  if (p &amp;&amp; p-&gt;next) {<br>    p = p-&gt;next;<br>    return SUCCESS;<br>  } else return UNSUCCESS;<br>}<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">int BuildHashTab(ChainHashTab &amp;H, int n, HKeyType es[]) </div><div class="line"><span class="comment">/* 直接调用下列函数                             */</span></div><div class="line"><span class="comment">/* 哈希函数：                                   */</span></div><div class="line"><span class="comment">/*    int Hash(ChainHashTab H, HKeyType k);     */</span></div><div class="line"><span class="comment">/* 冲突处理函数：                               */</span></div><div class="line"><span class="comment">/*    int Collision(ChainHashTab H, HLink &amp;p);  */</span></div><div class="line">&#123;</div><div class="line">    int i,k,j;</div><div class="line">    HLink p,q,p1;</div><div class="line">    H.rcd = (HLink*)malloc(<span class="number">7</span>*sizeof(HLink));</div><div class="line">    H.size = <span class="number">7</span>;</div><div class="line">    H.count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;es[i] &gt;= <span class="string">'A'</span>;i++)&#123;</div><div class="line">        p = (HNode*)malloc(sizeof(HNode));</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span> = es[i];</div><div class="line">        <span class="function"><span class="title">k</span> = Hash( H, p-&gt;</span><span class="keyword">data</span>) ;</div><div class="line">        <span class="keyword">if</span>(NULL !=H.rcd[k])&#123;  <span class="comment">// 判断其中是否有相同的HKeyType</span></div><div class="line">            p1 =  H.rcd[k];</div><div class="line">            <span class="keyword">while</span>(NULL != p1)&#123;  <span class="comment">//用j作为标记，如果j = 0表示没有相同的，插入p</span></div><div class="line">                <span class="function"><span class="title">if</span>(p1-&gt;</span><span class="function"><span class="title">data</span> == p-&gt;</span><span class="keyword">data</span>)</div><div class="line">                    j = <span class="number">1</span>;</div><div class="line">                <span class="function"><span class="title">p1</span> = p1-&gt;</span>next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                q =  H.rcd[k];</div><div class="line">                <span class="function"><span class="title">p</span>-&gt;</span>next = q;</div><div class="line">                H.rcd[k] = p;</div><div class="line">            &#125;</div><div class="line">           j = <span class="number">0</span>;</div><div class="line">        &#125;         </div><div class="line">        <span class="keyword">else</span>   </div><div class="line">            H.<span class="function"><span class="title">rcd</span>[k] = p; //为什么H.rcd[k]-&gt;</span>next = p;不会报错</div><div class="line">    H.count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-3]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-3<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试以顺序表L的L.rcd[L.length+1]作为监视哨，<br>改写教材3.2节中给出的升序直接插入排序算法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void InsertSort(RcdSqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i,j;</div><div class="line">   for(i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</div><div class="line">     if(L.rcd[i+<span class="number">1</span>].<span class="type">key</span>&lt;L.rcd[i].<span class="type">key</span>)&#123;</div><div class="line">        L.rcd[<span class="number">0</span>]=L.rcd[i+<span class="number">1</span>];</div><div class="line">        j=i+<span class="number">1</span>;</div><div class="line">        do&#123;</div><div class="line">           j--;</div><div class="line">           L.rcd[j+<span class="number">1</span>] = L.rcd[j];</div><div class="line">        &#125;while(L.rcd[<span class="number">0</span>].<span class="type">key</span>&lt;L.rcd[j<span class="number">-1</span>].<span class="type">key</span>);</div><div class="line">        L.rcd[j] = L.rcd[<span class="number">0</span>];</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如下所述，改写教材1.3.2节例1-10的冒泡排序算法：<br>将算法中用以起控制作用的布尔变量change改为一个整型<br>变量，指示每一趟排序中进行交换的最后一个记录的位置，<br>并以它作为下一趟起泡排序循环终止的控制值。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void BubbleSort(RcdSqList &amp;L)</div><div class="line"><span class="comment">/* 元素比较和交换必须调用如下定义的比较函数和交换函数：*/</span></div><div class="line"><span class="comment">/* Status LT(RedType a, RedType b);   比较："&lt;"        */</span></div><div class="line"><span class="comment">/* Status GT(RedType a, RedType b);   比较："&gt;"        */</span></div><div class="line"><span class="comment">/* void Swap(RedType &amp;a, RedType &amp;b); 交换             */</span></div><div class="line">&#123;</div><div class="line">   int i,change,j,k;                                                  </div><div class="line">   for(i=L.length,change = <span class="number">0</span>;i&gt;<span class="number">1</span>;i--)&#123;</div><div class="line">       change = i;</div><div class="line">      for(j=<span class="number">1</span>;j&lt;i;++j)&#123;</div><div class="line">         if(GT(L.rcd[j],L.rcd[j+<span class="number">1</span>]))&#123;</div><div class="line">            Swap(L.rcd[j],L.rcd[j+<span class="number">1</span>]);</div><div class="line">            k++;</div><div class="line">            change = j+<span class="number">1</span>;</div><div class="line">         &#125;            </div><div class="line">      &#125;</div><div class="line">      while(L.rcd[change].<span class="type">key</span> == L.rcd[change<span class="number">-1</span>].<span class="type">key</span>) <span class="comment">//用while来跳过那些相同关键字</span></div><div class="line">             change=change - <span class="number">1</span>;</div><div class="line">      i=change;</div><div class="line">      if(k==<span class="number">0</span>)    <span class="comment">//当有一次比较没有交换时使i= 1结束操作</span></div><div class="line">         i=<span class="number">1</span>;</div><div class="line">     k=<span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知记录序列L.rcd[1..L.length]中的关键<br>字各不相同，可按如下所述实现计数排序：另设数组<br>c[1..n]，对每个记录a[i]， 统计序列中关键字比它<br>小的记录个数存于c[i]，则c[i]=0的记录必为关键字<br>最小的记录，然后依c[i]值的大小对序列中记录进行<br>重新排列。试编写算法实现上述排序方法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int     length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void CountSort(RcdSqList &amp;L)</div><div class="line"><span class="comment">/* 采用顺序表存储结构，在函数内自行定义计数数组c */</span></div><div class="line">&#123;</div><div class="line">   int k=L.<span class="built_in">length</span> ;</div><div class="line">   RcdSqList L1;</div><div class="line">   int c[<span class="number">27</span>];</div><div class="line">   int i,j;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span> ;i++)</div><div class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.<span class="built_in">length</span>;j++)&#123;</div><div class="line">         <span class="keyword">if</span>(L.rcd[i].<span class="built_in">key</span>&lt;L.rcd[j].<span class="built_in">key</span>)</div><div class="line">            c[i]++;</div><div class="line">      &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span>;i++)</div><div class="line">         L1.rcd[c[i]+<span class="number">1</span>].<span class="built_in">key</span>=L.rcd[i].<span class="built_in">key</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span>;i++)       </div><div class="line">         L.rcd[L.<span class="built_in">length</span>-i+<span class="number">1</span>].<span class="built_in">key</span> = L1.rcd[i].<span class="built_in">key</span>;</div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-2]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-2<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的判空操作<br>StackEmpty_Sq(SqStack S)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq(SqStack S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的取栈顶元素操作<br>GetTop_Sq(SqStack S, ElemType &amp;e)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem;  // 存储空间的基址<br>  int top;         // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;        // 当前分配的存储容量<br>  int increment;   // 扩容时，增加的存储容量<br>} SqStack;         // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status GetTop_Sq(SqStack S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 取顺序栈S的栈顶元素到e，并返回OK； */</span> </div><div class="line"><span class="comment">/* 若失败，则返回ERROR。              */</span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(S.top==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">     e=S.elem[--S.top];</div><div class="line">     <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>构建初始容量和扩容增量分别为size和inc的空顺序栈S。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Status InitStack_Sq2(SqStack2 &amp;S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> inc)</div><div class="line"><span class="comment">/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/</span> </div><div class="line"><span class="comment">/* 若成功，则返回OK；否则返回ERROR。                 */</span></div><div class="line">&#123;</div><div class="line">    S.elem=(ElemType*)malloc(S.<span class="built_in">size</span>*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="built_in">if</span>(S.elem==NULL)   <span class="comment">//构建失败 </span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    <span class="built_in">if</span>(<span class="built_in">size</span>&lt;<span class="number">0</span>||inc&lt;<span class="number">0</span>)     <span class="comment">//参数错误</span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    S.<span class="built_in">size</span>=<span class="built_in">size</span>;</div><div class="line">    S.increment=inc;</div><div class="line">    S.top=S.elem;</div><div class="line">    <span class="built_in">return</span> OK;           </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的判空操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq2(SqStack2 S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==S.elem)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的入栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Status Push_Sq2(SqStack2 &amp;S, ElemType e)</div><div class="line"><span class="comment">/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*/</span></div><div class="line"><span class="comment">/* 将e压入S，返回OK。                          */</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">if</span>(S.<span class="built_in">size</span>==S.increment)  <span class="comment">//顺序栈已满</span></div><div class="line">        S.elem=(ElemType*)realloc(S.elem,(S.<span class="built_in">size</span>+S.increment)*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="built_in">if</span>(S.elem==NULL)    <span class="comment">//顺序栈扩容失败</span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    *S.top++=e;</div><div class="line">    S.<span class="built_in">size</span>=S.<span class="built_in">size</span>+S.increment;</div><div class="line">    <span class="built_in">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的出栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status Pop_Sq2(SqStack2 &amp;S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 若顺序栈S是空的，则返回ERROR；    */</span> </div><div class="line"><span class="comment">/* 否则将S的栈顶元素出栈到e，返回OK。*/</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==S.elem)   <span class="comment">//顺序栈为空  </span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    e=*(--S.top);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br>可调用顺序栈接口中下列函数：<br>Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈S<br>Status DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈S<br>Status StackEmpty_Sq(SqStack S);    // 栈S判空，若空则返回TRUE，否则FALSE<br>Status Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈S<br>Status Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e<br><strong><strong>**</strong></strong></em>/<br><strong>解题思路</strong>：栈是先进后出的，因此借用S3，需要用来两次倒序，第一次倒序插入S3，再将S3倒序插入S2，即所有元素正序，即完成复制顺序栈操作。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> CopyStack_Sq(SqStack <span class="built_in">S1</span>, SqStack &amp;<span class="built_in">S2</span>) </div><div class="line"><span class="comment">/* 借助辅助栈，复制顺序栈S1得到S2。    */</span> </div><div class="line"><span class="comment">/* 若复制成功，则返回TRUE；否则FALSE。 */</span></div><div class="line">&#123;</div><div class="line">     SqStack <span class="built_in">S3</span><span class="comment">;</span></div><div class="line">     int e<span class="comment">;</span></div><div class="line">     InitStack_Sq(<span class="built_in">S2</span>,<span class="built_in">S1</span>.size,<span class="built_in">S1</span>.increment)<span class="comment">;</span></div><div class="line">     InitStack_Sq(<span class="built_in">S3</span>,<span class="built_in">S1</span>.size,<span class="built_in">S1</span>.increment)<span class="comment">;</span></div><div class="line">     <span class="meta">while</span>(StackEmpty_Sq(<span class="built_in">S1</span>)!<span class="symbol">=TRUE</span>)&#123; //先将<span class="built_in">S1</span>元素倒序插入<span class="built_in">S3</span></div><div class="line">       <span class="keyword">Pop_Sq(S1,e);</span></div><div class="line"><span class="keyword"> </span>      <span class="keyword">Push_Sq(S3,e);</span></div><div class="line"><span class="keyword"> </span>      &#125;</div><div class="line">     <span class="meta">if</span>(<span class="built_in">S3</span>.elem=<span class="symbol">=NULL</span>)    //<span class="built_in">S1</span>倒序插入<span class="built_in">S3</span>失败</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">     <span class="meta">while</span>(StackEmpty_Sq(<span class="built_in">S3</span>)!<span class="symbol">=TRUE</span>)&#123; //再将<span class="built_in">S3</span>元素倒序插入<span class="built_in">S2</span></div><div class="line">       <span class="keyword">Pop_Sq(S3,e);</span></div><div class="line"><span class="keyword"> </span>      <span class="keyword">Push_Sq(S2,e);</span></div><div class="line"><span class="keyword"> </span>      &#125;</div><div class="line">     <span class="meta">if</span>(<span class="built_in">S2</span>.elem=<span class="symbol">=NULL</span>)   //<span class="built_in">S3</span>倒序插入<span class="built_in">S2</span>失败</div><div class="line">        return FALSE<span class="comment">;</span></div><div class="line">     return OK<span class="comment">;       </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，求循环队列的长度。<br>循环队列的类型定义为：<br>typedef struct {<br>  ElemType <em>base;  // 存储空间的基址<br>  int front;       // 队头位标<br>  int rear;        // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;     // 最大长度<br>} SqQueue;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> QueueLength_S<span class="string">q(SqQueue Q)</span></div><div class="line">/* 返回队列Q中元素个数，即队列的长度。 *<span class="regexp">/ </span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp">   return (Q.rear-Q.front+Q.maxSize)%Q.maxSize;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如果希望循环队列中的元素都能得到利用，<br>则可设置一个标志域tag，并以tag值为0或1来区分尾<br>指针和头指针值相同时的队列状态是”空”还是”满”。<br>试编写与此结构相应的入队列和出队列的算法。<br>本题的循环队列CTagQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int tag;<br>  int front;<br>  int rear;<br>} CTagQueue;<br><strong><strong>**</strong></strong>/<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CTagQueue &amp;Q,ElemType x)</div><div class="line"><span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></div><div class="line"><span class="comment">/* 若失败，则返回ERROR。       */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(Q.<span class="attr">tag==1&amp;&amp;Q.front==Q.rear)</span></div><div class="line">        return ERROR;</div><div class="line">   Q.elem[Q.rear]=x;</div><div class="line">   Q.<span class="attr">rear=(Q.rear+1)%MAXQSIZE;</span></div><div class="line">   <span class="keyword">if</span>(Q.<span class="attr">front==Q.rear)</span></div><div class="line">   Q.<span class="attr">tag=1;</span></div><div class="line">   return OK ;</div><div class="line">&#125; </div><div class="line"></div><div class="line">Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)</div><div class="line"><span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></div><div class="line"><span class="comment">/* 若失败，则返回ERROR。               */</span></div><div class="line">&#123; </div><div class="line">     <span class="keyword">if</span>(Q.<span class="attr">tag==0&amp;&amp;Q.front==Q.rear)</span></div><div class="line">       return ERROR;</div><div class="line">      <span class="attr">x=Q.elem[Q.front];</span></div><div class="line">      Q.<span class="attr">front=(Q.front+1)%MAXQSIZE;</span></div><div class="line">      <span class="keyword">if</span>(Q.<span class="attr">front==Q.rear)</span></div><div class="line">         Q.<span class="attr">tag=0;</span></div><div class="line">      return OK; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】假设将循环队列定义为：以域变量rear<br>和length分别指示循环队列中队尾元素的位置和内<br>含元素的个数。试给出此循环队列的队满条件，并<br>写出相应的入队列和出队列的算法（在出队列的算<br>法中要返回队头元素）。<br>本题的循环队列CLenQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int length;<br>  int rear;<br>} CLenQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CLenQueue &amp;Q, ElemType x)</div><div class="line">  <span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></div><div class="line">  <span class="comment">/* 若失败，则返回ERROR。       */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.<span class="built_in">length</span>==MAXQSIZE)  <span class="comment">//队列满</span></div><div class="line">      <span class="keyword">return</span> ERROR;</div><div class="line">    Q.elem[Q.rear]=x;</div><div class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE; </div><div class="line">    Q.<span class="built_in">length</span>++;</div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line">Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x)</div><div class="line">  <span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></div><div class="line">  <span class="comment">/* 若失败，则返回ERROR。               */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.<span class="built_in">length</span>==<span class="number">0</span>)     <span class="comment">//队列空</span></div><div class="line">        <span class="keyword">return</span> ERROR;   </div><div class="line">    <span class="type">int</span> front;         </div><div class="line">    front=MAXQSIZE-Q.<span class="built_in">length</span>+Q.rear;</div><div class="line">    x=Q.elem[front%MAXQSIZE];</div><div class="line">    front=(front+<span class="number">1</span>)%MAXQSIZE;</div><div class="line">    Q.<span class="built_in">length</span>--;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶斐波那契序列的定义为:<br>    f0=0,  f1=0,  …,  fk-2=0,  fk-1=1;<br>    fn=fn-1+fn-2+…+fn-k,  n=k,k+1,…<br>试利用循环队列编写求k阶斐波那契序列中第<br>n+1项fn的算法。</p>
<p>本题的循环队列的类型定义如下：<br>typedef struct {<br>  ElemType <em>base; // 存储空间的基址<br>  int front;      // 队头位标<br>  int rear;       // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;    // 最大长度<br>} SqQueue;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">long Fib(int k, int n)</div><div class="line"><span class="comment">/* 求k阶斐波那契序列的第n+1项fn */</span></div><div class="line">&#123;</div><div class="line">    int i,j ;</div><div class="line">   <span class="keyword">if</span>(<span class="number">1</span> &gt;=k|| <span class="number">0</span> &gt; n) <span class="built_in">return</span> ERROR;</div><div class="line">   SqQueue <span class="built_in">fib</span>;</div><div class="line">   <span class="built_in">fib</span>.base = (ElemType*)malloc(<span class="number">30</span>*sizeof(ElemType));</div><div class="line">   <span class="built_in">fib</span>.maxSize = <span class="number">30</span>;</div><div class="line">   <span class="built_in">fib</span>.front = <span class="built_in">fib</span>.rear = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span>(;<span class="built_in">fib</span>.rear &lt; k;<span class="built_in">fib</span>.rear++)</div><div class="line">   &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">fib</span>.rear&lt;k-<span class="number">1</span>) </div><div class="line">            <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] = <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="keyword">while</span>(<span class="built_in">fib</span>.rear &lt;= n)</div><div class="line">   &#123;</div><div class="line">        j = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt;= k)</div><div class="line">        &#123;</div><div class="line">             <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] +=<span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear-j];</div><div class="line">             j++;</div><div class="line">         &#125;</div><div class="line">        <span class="built_in">fib</span>.rear++;</div><div class="line">  &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">fib</span>.base[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】设A=(a1,…,am)和B=(b1,…,bn)均为有序顺序表，<br>A’和B’分别为A和B中除去最大共同前缀后的子表（例如，<br>A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大<br>的共同前缀为(x,y,y,z)， 在两表中除去最大共同前缀后<br>的子表分别为A’=(x,z)和B’=(y,x,x,z)）。若A’=B’=空表，<br>则A=B；若A’=空表，而B’≠ 空表，或者两者均不为空表，<br>且A’的首元小于B’的首元，则A<b；否则a>B。试写一个比<br>较A和B大小的算法。（注意：在算法中，不要破坏原表A<br>和B，也不一定先求得A’和B’才进行比较）。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</b；否则a></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">char Compare(SqList A, SqList B)</div><div class="line"><span class="comment">/* 比较顺序表A和B,      */</span></div><div class="line"><span class="comment">/*   返回'&lt;', 若A&lt;B;    */</span></div><div class="line"><span class="comment">/*       '=', 若A=B;    */</span></div><div class="line"><span class="comment">/*       '&gt;', 若A&gt;B     */</span></div><div class="line">&#123;     </div><div class="line">    int i=<span class="number">0</span>;  //计数器    </div><div class="line">    <span class="keyword">while</span>(A.<span class="built_in">elem</span>[i]==B.<span class="built_in">elem</span>[i]&amp;&amp;i&lt;A.<span class="built_in">length</span>&amp;&amp;i&lt;B.<span class="built_in">length</span>)         </div><div class="line">        i++;      </div><div class="line">    <span class="keyword">if</span>(A.<span class="built_in">length</span>==B.<span class="built_in">length</span>)</div><div class="line">        <span class="built_in">return</span> '=';      </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.<span class="built_in">elem</span>[i]&lt;B.<span class="built_in">elem</span>[i]||i==A.<span class="built_in">length</span>)         </div><div class="line">        <span class="built_in">return</span> '&lt;';      </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.<span class="built_in">elem</span>[i]&gt;B.<span class="built_in">elem</span>[i]||i==B.<span class="built_in">length</span>) </div><div class="line">        <span class="built_in">return</span> '&gt;';</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序表的就地逆置，<br>即利用原表的存储空间将线性表(a1,a2,…,an)<br>逆置为(an,an-1,…,a1)。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Inverse(SqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i;</div><div class="line">   int temp;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.<span class="built_in">length</span>/<span class="number">2</span>;i++) &#123;</div><div class="line">       temp=L.<span class="built_in">elem</span>[i];</div><div class="line">       L.<span class="built_in">elem</span>[i]=L.<span class="built_in">elem</span>[L.<span class="built_in">length</span>-i-<span class="number">1</span>];</div><div class="line">       L.<span class="built_in">elem</span>[L.<span class="built_in">length</span>-i-<span class="number">1</span>]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式<br>项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0<br>为给定值）。<br>一元稀疏多项式的顺序存储结构:<br>typedef struct {<br>  int  coef;  // 系数<br>  int   exp;  // 指数<br>} Term;<br>typedef struct {<br>  Term  <em>elem;   // 存储空间基址<br>  int    length; // 长度（项数）<br>} Poly;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">float</span> Evaluate(Poly P, <span class="built_in">float</span> x)</div><div class="line"><span class="comment">/* P.elem[i].coef 存放ai，                        */</span></div><div class="line"><span class="comment">/* P.elem[i].exp存放ei (i=1,2,...,m)              */</span></div><div class="line"><span class="comment">/* 本算法计算并返回多项式的值。不判别溢出。       */</span></div><div class="line"><span class="comment">/* 入口时要求0≤e1&lt;e2&lt;...&lt;em，算法内不对此再作验证 */</span></div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    <span class="built_in">float</span> <span class="built_in">sum</span>=<span class="number">0</span>,sum1;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;P.<span class="built_in">length</span>;i++)</div><div class="line">    &#123;</div><div class="line">        sum1=P.<span class="built_in">elem</span>[i].coef ;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;P.<span class="built_in">elem</span>[i].<span class="built_in">exp</span>;j++)</div><div class="line">          sum1=sum1*x;</div><div class="line">        <span class="built_in">sum</span>+=sum1;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">sum</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有两个集合A和B分别用两个线性表LA和LB<br>表示(即：线性表中的数据元素即为集合中的成员），<br>试写一算法，求并集A＝A∪B。<br>顺序表类型定义如下<br>typedef struct {<br>  ElemType <em>elem;     // 存储空间的基址<br>  int length;    // 当前长度<br>  int size;      // 存储容量<br>  int increment; // 空间不够增加空间大小<br>} SqList;  // 顺序表<br>可调用顺序表的以下接口函数：<br>Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表L<br>int ListLength_Sq(SqList L);  // 返回顺序表L中元素个数<br>Status GetElem_Sq(SqList L, int i, ElemType &amp;e);<br>// 用e返回顺序表L中第i个元素的值<br>int Search_Sq(SqList L, ElemType e);<br>// 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1<br>Status Append_Sq(SqList &amp;L, ElemType e);  // 在顺序表L表尾添加元素e<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Union(SqList &amp;La, SqList Lb)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    ElemType e;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Lb.length;i++)&#123;     </div><div class="line">         GetElem_S<span class="string">q(Lb,i+1,e)</span>;</div><div class="line">         <span class="keyword">if</span>(-<span class="number">1</span>==Search_S<span class="string">q(La,e)</span>)</div><div class="line">            Append_S<span class="string">q(La,e)</span>;</div><div class="line">    &#125;</div><div class="line">    La.length = ListLength_S<span class="string">q(La)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的判空操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_L(LStack S)</div><div class="line">/* 对链栈S判空。若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">   <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的取栈顶元素操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status GetTop_L(LStack S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 取链栈S的栈顶元素到e，并返回OK; */</span></div><div class="line"><span class="comment">/* 若S是空栈，则失败，返回ERROR。  */</span></div><div class="line">&#123;</div><div class="line">    LSNode *p;</div><div class="line">    <span class="keyword">if</span>(S==NULL)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        e=S-&gt;<span class="keyword">data</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的判空操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status QueueEmpty_LQ(LQueue Q)</div><div class="line"><span class="comment">/* 判定链队列Q是否为空队列。           */</span></div><div class="line"><span class="comment">/* 若Q是空队列，则返回TRUE，否则FALSE。*/</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.rear==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的求队列长度操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_LQ</span><span class="params">(LQueue Q)</span></span></div><div class="line"><span class="function"><span class="comment">/* 求链队列Q的长度并返回其值 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   LQNode *p=Q.front;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(Q.rear==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">   <span class="keyword">while</span>(p!=Q.rear)&#123;</div><div class="line">       p = p-&gt;next;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设以带头结点的循环链表表示队列，并且<br>只设一个指针指向队尾元素结点(注意不设头指针)，<br>试编写相应的队列初始化、入队列和出队列的算法。<br>带头结点循环链队列CLQueue的类型定义为：<br>typedef struct LQNode {<br>  ElemType data;<br>  struct LQNode <em>next;<br>} LQNode, </em>CLQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Status InitCLQueue(CLQueue &amp;rear) <span class="comment">// 初始化空队列</span></div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status EnCLQueue(CLQueue &amp;rear, ElemType x) <span class="comment">// 入队</span></div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=rear-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">rear</span>-&gt;</span>next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeCLQueue(CLQueue &amp;rear, ElemType &amp;x) <span class="comment">// 出队</span></div><div class="line">&#123; </div><div class="line">   <span class="function"><span class="title">if</span>(rear==rear-&gt;</span>next)</div><div class="line">       return ERROR;</div><div class="line">   <span class="keyword">else</span>&#123;</div><div class="line">       <span class="function"><span class="title">x</span>=rear-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="keyword">data</span>;</div><div class="line">       <span class="function"><span class="title">rear</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>=rear-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</div><div class="line">    &#125;    </div><div class="line">  return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的判空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status ListEmpty_L(LinkList L)</div><div class="line"><span class="comment">/* 判定带头结点单链表L是否为空链表。   */</span></div><div class="line"><span class="comment">/* 若L是空链表，则返回TRUE，否则FALSE。*/</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(<span class="keyword">NULL</span> == L-&gt;<span class="keyword">next</span>) </div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    <span class="keyword">return</span>  <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的销毁操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span></div><div class="line"><span class="function"><span class="comment">/* 销毁带头结点单链表L，并返回OK。*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">free</span>(L);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的清空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status ClearList_L(LinkList &amp;L)</div><div class="line"><span class="comment">/* 将带头结点单链表L置为空表，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若L不是带头结点单链表，则返回ERROR。 */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(L==<span class="keyword">NULL</span>) </div><div class="line">      <span class="keyword">return</span> ERROR;</div><div class="line">   <span class="keyword">if</span>(L-&gt;<span class="keyword">next</span>==<span class="keyword">NULL</span>) </div><div class="line">      <span class="keyword">return</span> OK;</div><div class="line">   L-&gt;<span class="keyword">next</span>=<span class="keyword">NULL</span>;</div><div class="line">   <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的求表长度操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ListLength_L(LinkList L)</div><div class="line"><span class="comment">/* 求带头结点单链表L的长度，并返回长度值。*/</span></div><div class="line"><span class="comment">/* 若L不是带头结点单链表，则返回-1。      */</span></div><div class="line">&#123;  </div><div class="line">   LNode *p;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(<span class="keyword">NULL</span>==L)</div><div class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">   p = L-&gt;<span class="keyword">next</span>;</div><div class="line">   <span class="keyword">while</span>(p != <span class="keyword">NULL</span>)&#123;</div><div class="line">      p = p-&gt;<span class="keyword">next</span>;</div><div class="line">      i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表L插入第i元素e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Status <span class="keyword">Insert_L(LinkList </span>L, int i, ElemType e)</div><div class="line"><span class="comment">/* 在带头结点单链表L插入第i元素e，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若参数不合理，则返回ERROR。              */</span> </div><div class="line">&#123;</div><div class="line">    if(i==<span class="number">0</span>)</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    LinkList p,q,p1,<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>   int <span class="keyword">j=0,k=0;</span></div><div class="line"><span class="keyword"> </span>   q=(LNode*)malloc(sizeof(LNode))<span class="comment">;</span></div><div class="line">    q-&gt;data=e<span class="comment">;</span></div><div class="line">    q-&gt;next=NULL<span class="comment">;</span></div><div class="line">    p1=L<span class="comment">;</span></div><div class="line">    <span class="keyword">b=L;</span></div><div class="line"><span class="keyword"> </span>   while(<span class="keyword">b!=NULL)&#123; </span>       </div><div class="line">        <span class="keyword">b=b-&gt;next;</span></div><div class="line"><span class="keyword"> </span>       k++<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    if(k&lt;i)</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    while(<span class="keyword">j&lt;i)&#123;</span></div><div class="line"><span class="keyword"> </span>       p=p1<span class="comment">;</span></div><div class="line">        p1=p-&gt;next<span class="comment">;</span></div><div class="line">        <span class="keyword">j++; </span>   </div><div class="line">    &#125;</div><div class="line">    q-&gt;next=p-&gt;next<span class="comment">;</span></div><div class="line">    p-&gt;next=q<span class="comment">;</span></div><div class="line">    return OK<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表的第i元素起的<br>所有元素从链表移除，并构成一个带头结点的新链表。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Status Split_L(LinkList L, LinkList &amp;Li, <span class="keyword">int</span> i)</div><div class="line"><span class="comment">/* 在带头结点单链表L的第i元素起的所有元素 */</span></div><div class="line"><span class="comment">/* 移除，并构成带头结点链表Li，返回OK。   */</span></div><div class="line"><span class="comment">/* 若参数不合理，则Li为NULL，返回ERROR。  */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||L==<span class="keyword">null</span>) &#123;</div><div class="line">     Li==<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">return</span> ERROR;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   LinkList a,b,c;</div><div class="line">   <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">   Li=(LNode*)malloc(sizeof(LNode));</div><div class="line">   Li-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">   a=L;</div><div class="line">   b=L;</div><div class="line">   <span class="keyword">while</span>(a-&gt;<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</div><div class="line">     j++;</div><div class="line">     a=a-&gt;<span class="keyword">next</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(j&lt;i) &#123;</div><div class="line">   Li=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">return</span> ERROR;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">while</span>(k&lt;i-<span class="number">1</span>)&#123;</div><div class="line">   b=b-&gt;<span class="keyword">next</span>;</div><div class="line">   k++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   c=b-&gt;<span class="keyword">next</span>;</div><div class="line">   Li-&gt;<span class="keyword">next</span>=c;</div><div class="line">   b-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素<br>起的所有元素。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Status Cut_L(LinkList L, <span class="keyword">int</span> i)</div><div class="line"><span class="comment">/* 在带头结点单链表L删除第i元素起的所有元素，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若参数不合理，则返回ERROR。                         */</span></div><div class="line">&#123;</div><div class="line">    LinkList p1,p2,p3;</div><div class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">    p2=L;</div><div class="line">    p1=L;</div><div class="line">    p3=L;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">NULL</span>==L||L-&gt;<span class="keyword">next</span>==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">        </div><div class="line">    <span class="keyword">while</span>(p1-&gt;<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</div><div class="line">       p1=p1-&gt;<span class="keyword">next</span>;</div><div class="line">       j++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(j&lt;i||i==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line"> </div><div class="line">    <span class="keyword">while</span>(k&lt;i)&#123;</div><div class="line">       p2=p3;</div><div class="line">       p3=p2-&gt;<span class="keyword">next</span>;</div><div class="line">       k++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    p2-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>为x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> DeleteX_L(LinkList L, ElemType x)</div><div class="line"><span class="comment">/* 删除带头结点单链表L中所有值为x的元素，      */</span></div><div class="line"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></div><div class="line">&#123;</div><div class="line">    LinkList <span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span><span class="comment">;</span></div><div class="line">    int j<span class="number">=0</span><span class="comment">;</span></div><div class="line">    <span class="meta">if</span>(NULL=<span class="symbol">=L</span>) </div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    <span class="built_in">p1</span><span class="symbol">=p2</span><span class="symbol">=L</span><span class="comment">;</span></div><div class="line">    <span class="meta">while</span>(<span class="built_in">p2</span>!<span class="symbol">=NULL</span>)&#123;</div><div class="line">      <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">      <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>=<span class="symbol">=x</span>)&#123;</div><div class="line">        <span class="built_in">p3</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        <span class="built_in">p2</span><span class="symbol">=p3</span>-&gt;next<span class="comment">;</span></div><div class="line">        <span class="built_in">p1</span>-&gt;next<span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        free(<span class="built_in">p3</span>)<span class="comment">;</span></div><div class="line">        j++<span class="comment">;</span></div><div class="line">      &#125;</div><div class="line">      <span class="meta">else</span> <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>!<span class="symbol">=x</span>)&#123;</div><div class="line">          <span class="built_in">p1</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">          <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>小于x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> DeleteSome_L(LinkList L, ElemType x)</div><div class="line"><span class="comment">/* 删除带头结点单链表L中所有值小于x的元素，    */</span></div><div class="line"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></div><div class="line">&#123;</div><div class="line">    LinkList <span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span><span class="comment">;</span></div><div class="line">    int j<span class="number">=0</span><span class="comment">;</span></div><div class="line">    <span class="meta">if</span>(NULL=<span class="symbol">=L</span>) </div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    <span class="built_in">p1</span><span class="symbol">=p2</span><span class="symbol">=L</span><span class="comment">;</span></div><div class="line">    <span class="meta">while</span>(<span class="built_in">p2</span>!<span class="symbol">=NULL</span>)&#123;</div><div class="line">      <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">      <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>&lt;x&amp;&amp;<span class="built_in">p2</span>!<span class="symbol">=null</span>)&#123;</div><div class="line">        <span class="built_in">p3</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        <span class="built_in">p2</span><span class="symbol">=p3</span>-&gt;next<span class="comment">;</span></div><div class="line">        <span class="built_in">p1</span>-&gt;next<span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        free(<span class="built_in">p3</span>)<span class="comment">;</span></div><div class="line">        j++<span class="comment">;</span></div><div class="line">      &#125;</div><div class="line">      <span class="meta">else</span> <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>&gt;<span class="symbol">=x</span>)&#123;</div><div class="line">          <span class="built_in">p1</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">          <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-1]]></title>
      <url>/2017/10/24/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-1<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，如果三个整数a，b和c的值<br>不是依次非递增的，则通过交换，令其为非递增。<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void Descend(int &amp;a, int &amp;<span class="keyword">b, </span>int &amp;c)</div><div class="line"><span class="comment">/* 通过交换，令 a &gt;= b &gt;= c */</span></div><div class="line">&#123;</div><div class="line">    int temp<span class="comment">;</span></div><div class="line">    if(c&gt;=<span class="keyword">b)</span></div><div class="line"><span class="keyword"> </span>   &#123;</div><div class="line">        temp=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=c;</span></div><div class="line"><span class="keyword"> </span>       c=temp<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">b&gt;=a)</span></div><div class="line"><span class="keyword"> </span>   &#123;</div><div class="line">        temp=a<span class="comment">;</span></div><div class="line">        a=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=temp;</span></div><div class="line"><span class="keyword"> </span>   &#125;</div><div class="line">    if(c&gt;=<span class="keyword">b)&#123;</span></div><div class="line"><span class="keyword"> </span>       temp=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=c;</span></div><div class="line"><span class="keyword"> </span>       c=temp<span class="comment">;</span></div><div class="line">    &#125;            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法求一元多项式<br>    P(x) = a0 + a1x + a2x^2 + … + anx^n<br>的值P(x0)，并确定算法中每一语句的执行次数和整个算法<br>的时间复杂度。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Polynomial</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[], <span class="keyword">float</span> x)</span></span></div><div class="line"><span class="function"><span class="comment">/* 求一元多项式的值P(x)。                  */</span></span></div><div class="line"><span class="function"><span class="comment">/* 数组a的元素a[i]为i次项的系数，i=0,...,n */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">double</span> px;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</div><div class="line">        px+=a[i]*<span class="built_in">pow</span>(x,i);</div><div class="line">    <span class="keyword">return</span> px;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶裴波那契序列的定义为<br>    f(0)=0, f(1)=0, …, f(k-2)=0, f(k-1)=1;<br>    f(n)=f(n-1)+f(n-2)+…+f(n-k), n=k,k+1,…<br>试编写求k阶裴波那契序列的第m项值的函数算法，<br>k和m均以值调用的形式在函数参数表中出现。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status Fibonacci(<span class="keyword">int</span> k, <span class="keyword">int</span> m, <span class="keyword">int</span> &amp;f) </div><div class="line"><span class="comment">/* 求k阶斐波那契序列的第m项的值f */</span></div><div class="line">&#123;    </div><div class="line">    <span class="keyword">int</span> t[<span class="number">60</span>],<span class="keyword">sum</span>,i,j;</div><div class="line">    <span class="keyword">if</span>(k&lt;<span class="number">2</span>||m&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(m&lt;k<span class="number">-1</span>) </div><div class="line">        f=<span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==k<span class="number">-1</span>) </div><div class="line">        f=<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k<span class="number">-2</span>;i++)&#123;</div><div class="line">        t[i]=<span class="number">0</span>;</div><div class="line">        t[k<span class="number">-1</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(i=k;i&lt;=m;i++)&#123;</div><div class="line">            <span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(j=i-k;j&lt;i;j++)</div><div class="line">                <span class="keyword">sum</span>+=t[j];</div><div class="line">            t[i]=<span class="keyword">sum</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    f=t[m];</div><div class="line">    &#125;                                                                                </div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法，计算i!×2^i的值并存入数组<br>a[0..n-1]的第i-1个分量中 (i=1,2,…,n)。假设计<br>算机中允许的整数最大值为MAXINT，则当对某个k<br>(1≤k≤n)使k!×2^k&gt;MAXINT时，应按出错处理。注意<br>选择你认为较好的出错处理方法。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status Series(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) </div><div class="line"><span class="comment">/* 求i!*2^i序列的值并依次存入长度为n的数组a；     */</span></div><div class="line"><span class="comment">/* 若所有值均不超过MAXINT，则返回OK，否则OVERFLOW */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> sum1=<span class="number">1</span>,sum2=<span class="number">1</span>;</div><div class="line">   <span class="keyword">int</span> j;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">            sum1=sum1*j;</div><div class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">            sum2=sum2*<span class="number">2</span>;    </div><div class="line">    <span class="keyword">sum</span>=sum1*sum2;</div><div class="line">        </div><div class="line">    <span class="keyword">if</span>(sum1&gt;MAXINT||sum2&gt;MAXINT||<span class="keyword">sum</span>&gt;MAXINT)</div><div class="line">        <span class="keyword">return</span> OVERFLOW;             </div><div class="line">        </div><div class="line">    a[i<span class="number">-1</span>]=<span class="keyword">sum</span>;</div><div class="line">    </div><div class="line">    sum1=<span class="number">1</span>;<span class="comment">//归位</span></div><div class="line">    sum2=<span class="number">1</span>;<span class="comment">//归位</span></div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span>  OK;            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有A、B、C、D、E五个高等院校进行田径对抗赛，<br>各院校的单项成绩均以存入计算机并构成一张表，表中每一行<br>的形式为：<br>        项目名称   性别   校名   成绩   得分<br>编写算法，处理上述表格，以统计各院校的男、女总分和团体<br>总分，并输出。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">void Scores(ResultType *result, ScoreType *<span class="built_in">score</span>)</div><div class="line"><span class="comment">/* 求各校的男、女总分和团体总分, 并依次存入数组score */</span></div><div class="line"><span class="comment">/* 假设比赛结果已经储存在result[ ]数组中,            */</span></div><div class="line"><span class="comment">/* 并以特殊记录 &#123;"", male, ' ', "", 0 &#125;（域scorce=0）*/</span></div><div class="line"><span class="comment">/* 表示结束                                          */</span></div><div class="line">&#123;</div><div class="line">typedef enum &#123;female,male&#125; Sex;</div><div class="line">typedef struct&#123;</div><div class="line">  char *sport;     <span class="comment">// 项目名称</span></div><div class="line">  Sex  gender;     <span class="comment">// 性别（女：female；男：male）</span></div><div class="line">  char schoolname; <span class="comment">// 校名为'A','B','C','D'或'E'</span></div><div class="line">  char *result;    <span class="comment">// 成绩</span></div><div class="line">  int <span class="built_in">score</span>;       <span class="comment">// 得分（7,5,4,3,2或1）</span></div><div class="line">&#125; ResultType; </div><div class="line">typedef struct&#123;</div><div class="line">  int malescore;   <span class="comment">// 男子总分</span></div><div class="line">  int femalescore; <span class="comment">// 女子总分</span></div><div class="line">  int totalscore;  <span class="comment">// 男女团体总分</span></div><div class="line">&#125; ScoreType;</div><div class="line"></div><div class="line">int i=<span class="number">0</span>;</div><div class="line"> <span class="keyword">while</span>(result[i].sport!=NULL)  </div><div class="line"> &#123;  </div><div class="line"> <span class="keyword">switch</span>(result[i].schoolname)     <span class="comment">/*使用switch语句记录各院校的成绩*/</span></div><div class="line"> &#123;  </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'A'</span>:  </div><div class="line"> <span class="built_in">score</span>[<span class="number">0</span>].totalscore+=result[i].<span class="built_in">score</span>;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">0</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">0</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'B'</span>:  </div><div class="line"> <span class="built_in">score</span>[<span class="number">1</span>].totalscore+=result[i].<span class="built_in">score</span>;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">1</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">1</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'C'</span>:  </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">2</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">2</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">2</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'D'</span>:  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">3</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">3</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">3</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'E'</span>: </div><div class="line">  </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">4</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">4</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">4</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> i++;  </div><div class="line"></div><div class="line"> &#125;  </div><div class="line"></div><div class="line">    int j;  </div><div class="line"></div><div class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)  &#123;</div><div class="line"></div><div class="line">        printf(<span class="string">"the school %s: "</span>, result[i].schoolname) ;   <span class="comment">/*输出各院校的男女总分和团体总分*/</span></div><div class="line"></div><div class="line">        printf(<span class="string">"total: %f"</span>,&amp;<span class="built_in">score</span>[i].totalscore);  </div><div class="line"></div><div class="line">        printf(<span class="string">"male: %f"</span>,&amp;<span class="built_in">score</span>[i].malescore);  </div><div class="line"></div><div class="line">        printf(<span class="string">"female: %f"</span>,&amp;<span class="built_in">score</span>[i].femalescore);  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，对序列S的第i个元素赋以值e。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(Sequence &amp;S, <span class="keyword">int</span> i, ElemType e)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 对序列S的第i个元素赋以值e，并返回OK。 */</span></span></div><div class="line"><span class="function"><span class="comment">/* 若S或i不合法，则赋值失败，返回ERROR   */</span></span></div><div class="line"><span class="function"></span>&#123;    </div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;=S.length||S.elem==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    S.elem[i]=e;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，由长度为n的一维数组a构建一个序列S。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">CreateSequence</span><span class="params">(Sequence &amp;S, <span class="keyword">int</span> n, ElemType *a)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 由长度为n的一维数组a构建一个序列S，并返回OK。 */</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回ERROR                       */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   <span class="keyword">int</span> i;</div><div class="line">   <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">   S.elem=(ElemType*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        S.elem[i]=a[i];</div><div class="line">   S.length=n;     </div><div class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建一个值为x的结点。<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">LinkList <span class="title">MakeNode</span><span class="params">(ElemType x)</span></span></div><div class="line"><span class="function"><span class="comment">/* 构建一个值为x的结点，并返回其指针。*/</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回NULL。           */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     LNode *p;</div><div class="line">     p=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">     <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">     p-&gt;next=<span class="literal">NULL</span>;</div><div class="line">     p-&gt;data=x;</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2且两个结点的值依次为x和y的链表。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">LinkList <span class="title">CreateLinkList</span><span class="params">(ElemType x, ElemType y)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 构建其两个结点的值依次为x和y的链表。*/</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回NULL。            */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      LNode *p;</div><div class="line">      LNode *q;</div><div class="line">      p=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">      <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;        </div><div class="line">      q=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">      <span class="keyword">if</span>(q==<span class="literal">NULL</span>)  <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">      p-&gt;next=q;</div><div class="line">      q-&gt;next=<span class="literal">NULL</span>;</div><div class="line">      p-&gt;data=x;</div><div class="line">      q-&gt;data=y;</div><div class="line">      <span class="keyword">return</span> p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2的升序链表，两个结点的值<br>分别为x和y，但应小的在前，大的在后。<br><strong><strong>**</strong></strong>/<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">LinkList CreateOrdLList(ElemType x, ElemType y)</div><div class="line"><span class="comment">/* 构建长度为2的升序链表。  */</span></div><div class="line"><span class="comment">/* 若构建失败，则返回NULL。 */</span></div><div class="line">&#123;</div><div class="line">    LNode *p;</div><div class="line">    LNode *q;</div><div class="line">    </div><div class="line">    p=(LNode*)malloc(sizeof(LNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return NULL;</div><div class="line">        </div><div class="line">    q=(LNode*)malloc(sizeof(LNode));</div><div class="line">    <span class="keyword">if</span>(q==NULL)</div><div class="line">        return NULL;</div><div class="line">                </div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=q;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    <span class="keyword">if</span>(x&lt;y)&#123;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=y;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">    &#125;</div><div class="line">    return p;                            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代数系统]]></title>
      <url>/2017/10/24/%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>-代数系统概念与性质</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>如果“*”是AXA到A的二元运算，则称运算“*”对集合A是<strong>封闭</strong>的，或者称“*”是A上的二元运算</p>
<hr>
<p>设A是非空集合,<em>1,</em>2,…,<em>m分别是定义在A上的k1,k2,…,km元封闭运算，ki是正整数，i=1,2,…,m。集合A和</em>1,<em>2,…,</em>m所组成的系统称为<strong>代数系统</strong>，简称<strong>代数</strong></p>
<hr>
<p><strong>代数系统的基本运算规律</strong><br>1.结合律<br>2.交换律<br>3.消去律<br>4.幂等律<br>5.分配律<br>6.吸收律</p>
<hr>
<p><strong>代数系统的性质</strong><br><strong>幺元</strong>：单位元(英文常写作Identity Element，即IE)是集合里的一种特别的元，与该集合里的运算（可理解为实数里的*，但并不局限于）有关。当它和其他元素结合时，并不会改变那些元素。也叫幺元（么元）。若a<em>e=a，e称为右单位元；若e</em>a=a，e称为左单位元，若a<em>e=e</em>a=a，则e称为单位元。若该演算左右的元素能互换，左、右单位元相同，可称为双边单位元。<br><strong>零元</strong><br>设*是定义在集合A上的一个二元运算，如果有一个元素a1属于A，对于任意的元素x属于A，都有a1<em>x=a1，则称a为A中关于运算</em>的左零元；如果有一个元素a2属于A,a1不等于a2，对于任意的元素x属于A都有x<em>a2=a2，则称a2为A中关于运算</em>的右零元；如果A中的一个元素a，它既是左零元又是右零元，则称a为A中关于运算<em>的零元。<br><strong>逆元</strong><br>设S为一有二元运算 </em> 的集合。若e为(S,<em>)的单位元且a</em>b=e，则a称为b的左逆元素且b称为a的右逆元素。若一元素x同时是y的左逆元素和右逆元素时，x称为y的两面逆元素或简称为逆元素。S内的一有两面逆元素的元素被称为在S内为可逆的。</p>
<hr>
<p><strong>单射</strong>：设f是由集合A到集合B的映射，如果所有x,y∈A,且x≠y，都有f(x)≠f(y),则称f为由A到B的单射。</p>
<p><strong>同态</strong>：假设M，M′是两个乘集，也就是说M和M′是两个各具有一个封闭的具有结合律的运算<em>与</em>‘的代数系统。σ是M射到M′的映射，并且任意两个元的乘积的像是这两个元的像的乘积，即对于M中任意两个元a,b,满足<br>σ(a<em>b)=σ(a)</em>’σ(b)；<br>也就是说，当a→σ(a)，b→σ(b)时，a<em>b→σ(a)</em>’σ(b)，<br>那么这映射σ就叫做M到M′上的同态。<br>如果 σ 是单射， 则称为单同态；如果 σ 是满射，则称为满同态。如果σ是双射， 则称为同构。<br>如果M, M’都是群， 那么同态也叫做群同态。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九度OJ-1001]]></title>
      <url>/2017/10/23/%E4%B9%9D%E5%BA%A6OJ-1001/</url>
      <content type="html"><![CDATA[<p>-好久没有刷过OJ<br>-三次才AC<br><a id="more"></a></p>
<p>题目描述：<br>    This time, you are supposed to find A+B where A and B are two matrices, and then count the number of zero rows and columns.<br>输入：<br>    The input consists of several test cases, each starts with a pair of positive integers M and N (≤10) which are the number of rows and columns of the matrices, respectively. Then 2*M lines follow, each contains N integers in [-100, 100], separated by a space. The first M lines correspond to the elements of A and the second M lines to that of B.<br>    The input is terminated by a zero M and that case must NOT be processed.<br>输出：<br>    For each test case you should output in one line the total number of zero rows and columns of A+B.<br>样例输入：<br>2 2<br>1 1<br>1 1<br>-1 -1<br>10 9<br>2 3<br>1 2 3<br>4 5 6<br>-1 -2 -3<br>-4 -5 -6<br>0<br>样例输出：<br>1<br>5<br>来源：<br>2011年浙江大学计算机及软件工程研究生机试真题</p>
<hr>
<p>题目的意思大概是输入两个数作为数组的行数和列数，然后读入两个这样的数组，执行加法操作，算出元素均为0的行数列数的和。</p>
<hr>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> m,n; <span class="comment">//读入数组的行列数 </span></div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="keyword">int</span> count1,count2=<span class="number">0</span>; <span class="comment">//计数器 </span></div><div class="line">	</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&amp;&amp;m)&#123;</div><div class="line">		<span class="keyword">int</span> a[m][n];</div><div class="line">		<span class="keyword">int</span> b[m][n];</div><div class="line">		count2=<span class="number">0</span>; <span class="comment">//归零操作 </span></div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  <span class="comment">//读入第一个数组</span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">				<span class="built_in">cin</span>&gt;&gt;a[i][j];</div><div class="line">				</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  <span class="comment">//读入第二个数组 </span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; </div><div class="line">				<span class="built_in">cin</span>&gt;&gt;b[i][j];</div><div class="line">				a[i][j]+=b[i][j]; <span class="comment">//执行数组的加法</span></div><div class="line">			&#125; </div><div class="line">					</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;  <span class="comment">//算出有多少行是元素均为0的 </span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)		</div><div class="line">				<span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</div><div class="line">					count1++;</div><div class="line">				<span class="keyword">if</span>(count1==n)</div><div class="line">					count2++;</div><div class="line">				count1=<span class="number">0</span>;  <span class="comment">//归零操作 </span></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//算出有多少列是元素均为0的 </span></div><div class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">				<span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</div><div class="line">					count1++;</div><div class="line">				<span class="keyword">if</span>(count1==m)</div><div class="line">					count2++;</div><div class="line">				count1=<span class="number">0</span>; <span class="comment">//归零操作 </span></div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;count2&lt;&lt;<span class="built_in">endl</span>;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;			 </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 九度OJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[证明技术]]></title>
      <url>/2017/10/23/%E8%AF%81%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>-基本证明技术<br>-典型证明技术</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">基本证明技术</font></strong><br>1.<strong>直接证明</strong><br>通过直接证明：若前提P为真，则结论Q也必然为真来证明蕴涵式P→Q成立，这样就证明了P真Q假的组合不可能存在，这种证明称为直接证明<br>2.<strong>间接证明</strong><br>因为蕴涵式P→Q等价于它的逆否命题¬Q→¬P，所以可以通过证明它的逆否命题¬Q→¬P为真来证明蕴涵式P→Q成立，这种类型的论证为间接证明</p>
<hr>
<p><strong><font size="5">典型证明技术</font></strong><br>1.<strong>空证明</strong><br>在蕴涵式P→Q中，当前件P为假时，无论其后件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明P为假，来证明P→Q，这称为空证明<br>2.<strong>平凡证明</strong><br>在蕴涵式P→Q中，当后件为真时，无论其前件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明Q为真，来证明P→Q，这称为平凡证明<br>3.<strong>归谬证明</strong><br>在蕴涵式P→Q中，当后件Q为假时，只有前件P也为假，蕴涵式P→Q才为真。因此，针对蕴涵式¬P→Q，假定可以找到矛盾式Q使得¬P→Q成立，即¬P为假，P为真。这种类型的论证称为归谬证明</p>
<hr>
<p><strong><font size="5">抽屉原理（鸽巢原理）</font></strong><br>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。 抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” </p>
<hr>
<p><strong><font size="5">数学归纳法</font></strong><br>最简单和常见的数学归纳法是证明当n等于任意一个自然数时某命题成立。证明分下面两步：<br>证明当n= 1时命题成立。<br>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谓词逻辑]]></title>
      <url>/2017/10/22/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-推理规则</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>个体词</strong>：在原子命题中，可以存在的客体（句子中的主语、宾语等）<br><strong>谓词</strong>：用以刻画客体性质或客体之间的关系的词<br><strong>个体常量</strong>：表示具体或特定的个体词<br><strong>个体变量</strong>：表示抽象或泛指的个体词<br><strong>个体域</strong>：个体词的取值范围<br><strong>全总个体域</strong>：宇宙间所有的个体域聚集在一起所构成的个体域<br><strong>存在量词</strong>：∃x（其中x称为作用变量）<br><strong>全称量词</strong>：∀x（其中x称为作用变量）<br><strong>辖域</strong>：一般将其量词加在其谓词之前，记为（∀x）F（x）， （∃x）F（x），此时，F（x）称为全称量词和存在量词的辖域<br><strong>约束出现</strong>：给定一个合适的公式G，若变元x出现在使用变元的量词的辖域之内，则称x的出现为约束出现，此时的变元x称为<strong>约束变元</strong><br><strong>自由出现</strong>：若x的出现不是约束出现，则为自由出现，此时的x称为<strong>自由变元</strong><br><strong>Skolem标准型</strong>：如果消去G中所有的存在量词和全称量词，所得到的公式称为Skolem标准型</p>
<hr>
<p><strong>谓词合式公式基本等价关系</strong><br>定义：如果公式G↔H是有效公式，则公式G，H称为<strong>等价</strong>的，记为G=H<br><strong>改名规则</strong>：<br>·（∃x）G（x）=（∃y）G（y）<br>·（∀x）G（x）=（∀y）G（y）<br><strong>量词转换律</strong><br>·¬（∃x）G（x）=（∀x）¬G（x）<br>·¬（∀x）G（x）=（∃x）¬G（x）<br><strong>量词辖域的扩张与收律</strong><br>·（∀x）G（x∨s）=（∀x）G（x）∨s<br>·（∀x）G（x∧s）=（∀x）G（x）∧s<br>·（∃x）G（x∨s）=（∃x）G（x）∨s<br>·（∃x）G（x∧s）=（∃x）G（x）∧s<br><strong>量词分配律</strong><br>·（∀x）（G（x）∧H（x））=（∀x）G（x）∧（∀x）H（x）<br>·（∃x）（G（x）∨H（x））=（∃x）G（x）∨（∃x）H（x）<br>·（∀x）G（x）∨（∀x）H（x）=（∀x）（∀y）（G（x）∨H（y））<br>·（∃x）G（x）∧（∃x）H（x）=（∃x）（∃y）（G（x）∨H（y））</p>
<hr>
<p><strong>推理规则</strong>：<br>1.<strong>US（全称特指规则）</strong>：（∀x）G（x）=&gt;G（y），其中y关于G（x）是自由的变元，不是约束的变元<br>2.<strong>ES（存在特指规则）</strong>：（∃x）G（x）=&gt;G（c），其中c为使G（c）为真的个体变量<br>3.<strong>UG（全程推广规则）</strong>：G（y）=&gt;（∀x）G（x），其中G（y）中无自由变元x<br>4.<strong>EG（存在推广原则）</strong>：G（c）=&gt;（∃x）G（x），其中c为特定个体变量</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-2]]></title>
      <url>/2017/10/19/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-2/</url>
      <content type="html"><![CDATA[<p>-主析取范式与主合取范式<br>-逻辑推理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>文字</strong>：命题变元或命题变元的否定<br><strong>析取式</strong>：有限个文字的析取称为析取式，也称子句<br><strong>合取式</strong>：有限个文字的合取称为合取式，也称短语<br><strong>互补对</strong>：P与¬P称为互补对<br><strong>析取范式</strong>：有限个短语的析取式为析取范式<br><strong>合取范式</strong>：有限个子句的合取式为合取范式<br><strong>极小项与极大项</strong>：在含有n个命题变元P1,P2,…,Pn的短语或子句中，若每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅出现一次，并且出现的次序与P1,P2,…,Pn一致，则称此短语或子句为关于P1,P2,…,Pn的一个极小项或极大项<br><strong>主析取范式</strong>：在给定的析取范式中，若每一个短语都是极小项，则称该范式为主析取范式<br><strong>主合取范式</strong>：在给定的合取范式中，若每一个子句都是极大项，则称该范式为主合取范式</p>
<hr>
<p>推理定律：<br>基于真值表技术，由如下关系：<br><strong>简化规则</strong>：<br>G∧H=&gt;G<br>G∧H=&gt;H<br><strong>添加规则</strong>：<br>G=&gt;G∨H<br>H=&gt;G∨H<br>¬G=&gt;G→H<br>H=&gt;H→G<br>G,H=&gt;G∧H<br><strong>选言三段论</strong>：<br>¬G,G→H=&gt;H<br>¬G,G⊕（异或）H=&gt;H<br><strong>肯定前件式</strong>：<br>G,G→H=&gt;H<br><strong>否定后件式</strong>：<br>¬H,G→H=&gt;¬G<br><strong>假言三段论</strong>:<br>G→H,H→I=&gt;G→I<br><strong>二难推论</strong>：<br>G∨H,G→I,H→I=&gt;I</p>
<hr>
<p><strong>规则P</strong>：前提引用规则。在推导的过程中，可随时引入前提集合中的任意一个前提<br><strong>规则T</strong>：逻辑结果引用规则。在推导的过程中，可随时引入公式S，该公式S是由其前的一个或多个公式推导出来的逻辑结果<br><strong>规则CP</strong>：附加前提规则。如果能从给定的前提的集合T与公式P推导出S，则能从此前提集合T推导出P→S</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-1]]></title>
      <url>/2017/10/18/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-基本等价关系</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>真值</strong>：命题可以取一个值，称为真值。真值只有“真”和“假”两种，分别用“1”(“T”)和“0”(“F”)表示。<br><strong>命题</strong>：具有确切真值的陈述句。</p>
<hr>
<p>一切没有判断内容的句子，都不能作为命题。</p>
<hr>
<p><strong>原子命题</strong>：不能再分解为更简单的命题。<br><strong>复合命题</strong>：可以分解为成简单的命题，与原子命题相对。<br><strong>联结词</strong>：否定联结词（非），合取联结词（并且），析取联结词（或），蕴涵联结词（推理），等价联结词。</p>
<hr>
<p>否定：真值结果取反<br>合取：P，Q同真才真，有假则假<br>析取：P，Q同假才假，有真则真<br>蕴涵：P真Q假时为假，否则为真<br>等价：PQ真值相同为真，否则为假</p>
<hr>
<p><strong>常值命题</strong>：真值不是“真”就是“假”，真值是确定的<br><strong>命题变量</strong>：没有具体的真值，与常值命题相对<br><strong>命题公式</strong>：其中的原子命题是命题变元，复合命题即为命题变元的”函数“，且该函数的真值仍为”真“或”假“<br><strong>解释</strong>：设P1,P2,…,Pn时出现在公式G中的所有命题变元，指定P1，P2，…，Pn一组真值，则这组真值称为G的一个解释<br><strong>真值表</strong>：由公式G在其所有可能的解释下所取的真值构成的表<br><strong>永真公式</strong>：在所有的解释下真值都为”真“<br><strong>永假公式（矛盾式）</strong>：在所有的解释下真值都为”假“<br><strong>可满足公式</strong>：非永假公式<br><strong>等价</strong>：设G,H是两个命题公式，P1，P2，…，Pn是出现在G，H中所有的命题变元，如果对于P1,P2，…，Pn的2的n次方个真值组合的每一个解释，G与H的真值结果都相同，则称G，H等价，记作<strong>G=H</strong></p>
<hr>
<p>命题公式的基本等价关系：<br>1.<strong>幂等律</strong>：<br>G∨G=G<br>G∧G=G<br>2.<strong>交换律</strong> ：<br>G∨H=H∨G<br>G∧H=H∧G<br>3.<strong>结合律</strong>：<br>G∨(H∨S)=(G∨H)∨S<br>G∧(H∧S)=(G∧H)∧S<br>4.<strong>同一律</strong>：<br>G∨0=G<br>G∧1=G<br>5.<strong>零律</strong>：<br>G∨1=1<br>G∧0=0<br>6.<strong>分配律</strong>：<br>G∨(H∧S)=(G∨H)∧(G∨S)<br>G∧(H∨S)=(G∧H)∨(G∧S)<br>7.<strong>吸收律</strong>：<br>G∨(G∧H)=G<br>G∧(G∨H)=G<br>8.<strong>矛盾律</strong>：<br>G∧¬G=0<br>9.<strong>排中律</strong>：<br>G∨¬G=1<br>10.<strong>双重否定律</strong>：<br>¬（¬G）=G<br>11.<strong>德摩根律</strong>：<br>¬(G∨H)=¬G∧¬H<br>¬(G∧H)=¬G∨¬H<br>12.<strong>蕴含式</strong>：<br>G→H=¬G∨H<br>13.<strong>假言易位</strong>：<br> G→H=¬H→¬G<br> 14.<strong>等价式</strong>：<br> G↔H=(G→H)∧(H→G)=(¬G∨H)∧(¬H∨G)<br> 15.<strong>等价否定等式</strong>：<br> G↔H=¬G↔¬H<br> 16.<strong>归谬论</strong>：</p>
<h2 id="G→H-∧-G→¬H-¬G"><a href="#G→H-∧-G→¬H-¬G" class="headerlink" title=" (G→H)∧(G→¬H)=¬G"></a> (G→H)∧(G→¬H)=¬G</h2><p> 更多查看我的blog:<a href="https://beatjerome.github.io" target="_blank" rel="external">https://beatjerome.github.io</a></p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-2]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-2/</url>
      <content type="html"><![CDATA[<p>-处理冲突的方法<br>-散列表查找及性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">处理冲突的方法<font></font></font></strong><br>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。<br>假设已经选定散列函数H(key)，下面用Hi表示发生冲突后第i次探测的散列地址。<br><strong><font size="4">一.开放定址法<font></font></font></strong><br>所谓开放定址法，指的是可存放新表项的空闲地址既指向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式<strong>Hi=（H（key）+di）%m</strong>，其中，i=1,2,…,k（k&lt;=m-1）；m表示散列表表长；di为增量序列。<br>当增量序列即di确定后，则对应的处理方法是确定的。通常有以下四种取法：<br><strong>1）线性探测法</strong><br>当di=1，2，…，m-1，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中的下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出下一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<br><strong>2）平方探测法</strong><br>当di=1²，-1²，2²，-2²，…，k²，-k²，其中k≤m/2，m必须是一个可以表示成4k+3的质数，又称二次探测法。<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一般单元。<br><strong>3）再散列法</strong><br>当di=Hash2（Key），又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H（Key）得到的地址发生冲突时，则利用第二个散列函数Hash2（Key）计算该关键字的地址增量。再散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置。<br><strong>4）伪随机序列法</strong><br>当di=伪随机数序列，称为伪随机序列法。</p>
<p><strong>注意：在开放地址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他<br>具有相同散列地址的元素的查找地址。所以，若想删除一个元素时，给它做一个删除标记，进<br>行逻辑删除。但这样做的副作用是：在执行多次删除后，表面看上去散列表是满的，实际上有<br>许多位置没有利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</strong></p>
<p><strong><font size="4">二.拉链法</font></strong><br>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表中的第i个单元中，因而查找，插入，删除操作主要在同义词链中进行。拉链法适合于经常进行插入删除操作的情况。</p>
<hr>
<p><strong><font size="6">散列表查找及性能分析</font></strong><br>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：<br><strong>初始化：Addr=Hash（key）；</strong><br>①检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败；若有记录，比较它与key值，若相等，返回查找成功标志，否则执行下一步。<br>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置wei此地址，转入步骤①</p>
<pre><code>散列表的查找效率取决与三个因素：散列函数，处理冲突的方法和装填因子
</code></pre><p><strong>装填因子</strong>：散列表的装填因子一般记为α，定义为一个表的装满程度，即<strong>α=表中记录数n/散列表长度m</strong><br>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观上看，α越大，装填程度越满，发生冲突的可能性就越大，反之发生冲突的可能性越小。</p>
<hr>
<p>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的发生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表的查找效率的度量。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-1]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-1/</url>
      <content type="html"><![CDATA[<p>-散列表的基本内容<br>-散列函数的构造方法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">散列表的基本概念<font></font></font></strong><br><strong>散列函数</strong><br>一个把查找表中关键字映射成该关键字对应的地址的函数，记为<strong>Hash(key)=Addr</strong>。（这里的地址可以是数组下标，索引，或内存地址等）<br>散列函数可能会把两个或者两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的办法。<br><strong><font size="5">散列表<font></font></font></strong><br><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。<br><strong>散列函数的构造方法</strong><br>在构造散列函数时，必须注意以下几点：<br>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。<br>2）散列函数计算出来的地址应该能等概率，均匀地分布在整个地址空间，从而减少冲突的发生。<br>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</p>
<hr>
<p><strong><font size="6">常用的散列函数<font></font></font></strong><br><strong>1.直接定址法</strong><br>    直接取关键字的某个线性函数值为散列地址，散列函数为<strong>H(key)=a*key+b</strong>。在这个函数式中，a和b是常数。这种方法计算最简单，并且不会产生冲突。它适合关键字的分布基本连续的情况，如果关键字分布不连续，空位较多，将造成存储空间的浪费。<br><strong>2.除留余数法</strong><br>    这是一种最简单，最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用下列公式把关键字转换成散列地址。散列函数为<strong>H(key)=key%p</strong>。<br>    除留余数法的关键在于选好p，使得每一个关键字在通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减小冲突的可能性。<br><strong>3.数字分析法</strong><br>    设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合。如果更换了关键字，就需要重新构造新的散列函数。<br><strong>4.平方取中法</strong><br>    顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。适合于关键字的每一位取值都不够均匀或均小于散列地址所需的位数的情况。<br><strong>5.折叠法</strong><br>    将关键字分割位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</p>
<hr>
<p>在不同的情况下，不同的散列函数会发挥出不同的性能，因此不能笼统地说哪种散列函数最好。实际选择中，采用何种散列函数的方法取决于关键字集合的情况，但目标是为了使散列产生冲突的可能性尽量地降低。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
