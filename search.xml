<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[证明技术]]></title>
      <url>/2017/10/23/%E8%AF%81%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>-基本证明技术<br>-典型证明技术</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">基本证明技术</font></strong><br>1.<strong>直接证明</strong><br>通过直接证明：若前提P为真，则结论Q也必然为真来证明蕴涵式P→Q成立，这样就证明了P真Q假的组合不可能存在，这种证明称为直接证明<br>2.<strong>间接证明</strong><br>因为蕴涵式P→Q等价于它的逆否命题¬Q→¬P，所以可以通过证明它的逆否命题¬Q→¬P为真来证明蕴涵式P→Q成立，这种类型的论证为间接证明</p>
<hr>
<p><strong><font size="5">典型证明技术</font></strong><br>1.<strong>空证明</strong><br>在蕴涵式P→Q中，当前件P为假时，无论其后件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明P为假，来证明P→Q，这称为空证明<br>2.<strong>平凡证明</strong><br>在蕴涵式P→Q中，当后件为真时，无论其前件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明Q为真，来证明P→Q，这称为平凡证明<br>3.<strong>归谬证明</strong><br>在蕴涵式P→Q中，当后件Q为假时，只有前件P也为假，蕴涵式P→Q才为真。因此，针对蕴涵式¬P→Q，假定可以找到矛盾式Q使得¬P→Q成立，即¬P为假，P为真。这种类型的论证称为归谬证明</p>
<hr>
<p><strong><font size="5">抽屉原理（鸽巢原理）</font></strong><br>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。 抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” </p>
<hr>
<p><strong><font size="5">数学归纳法</font></strong><br>最简单和常见的数学归纳法是证明当n等于任意一个自然数时某命题成立。证明分下面两步：<br>证明当n= 1时命题成立。<br>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谓词逻辑]]></title>
      <url>/2017/10/22/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-推理规则</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>个体词</strong>：在原子命题中，可以存在的客体（句子中的主语、宾语等）<br><strong>谓词</strong>：用以刻画客体性质或客体之间的关系的词<br><strong>个体常量</strong>：表示具体或特定的个体词<br><strong>个体变量</strong>：表示抽象或泛指的个体词<br><strong>个体域</strong>：个体词的取值范围<br><strong>全总个体域</strong>：宇宙间所有的个体域聚集在一起所构成的个体域<br><strong>存在量词</strong>：∃x（其中x称为作用变量）<br><strong>全称量词</strong>：∀x（其中x称为作用变量）<br><strong>辖域</strong>：一般将其量词加在其谓词之前，记为（∀x）F（x）， （∃x）F（x），此时，F（x）称为全称量词和存在量词的辖域<br><strong>约束出现</strong>：给定一个合适的公式G，若变元x出现在使用变元的量词的辖域之内，则称x的出现为约束出现，此时的变元x称为<strong>约束变元</strong><br><strong>自由出现</strong>：若x的出现不是约束出现，则为自由出现，此时的x称为<strong>自由变元</strong><br><strong>Skolem标准型</strong>：如果消去G中所有的存在量词和全称量词，所得到的公式称为Skolem标准型</p>
<hr>
<p><strong>谓词合式公式基本等价关系</strong><br>定义：如果公式G↔H是有效公式，则公式G，H称为<strong>等价</strong>的，记为G=H<br><strong>改名规则</strong>：<br>·（∃x）G（x）=（∃y）G（y）<br>·（∀x）G（x）=（∀y）G（y）<br><strong>量词转换律</strong><br>·¬（∃x）G（x）=（∀x）¬G（x）<br>·¬（∀x）G（x）=（∃x）¬G（x）<br><strong>量词辖域的扩张与收律</strong><br>·（∀x）G（x∨s）=（∀x）G（x）∨s<br>·（∀x）G（x∧s）=（∀x）G（x）∧s<br>·（∃x）G（x∨s）=（∃x）G（x）∨s<br>·（∃x）G（x∧s）=（∃x）G（x）∧s<br><strong>量词分配律</strong><br>·（∀x）（G（x）∧H（x））=（∀x）G（x）∧（∀x）H（x）<br>·（∃x）（G（x）∨H（x））=（∃x）G（x）∨（∃x）H（x）<br>·（∀x）G（x）∨（∀x）H（x）=（∀x）（∀y）（G（x）∨H（y））<br>·（∃x）G（x）∧（∃x）H（x）=（∃x）（∃y）（G（x）∨H（y））</p>
<hr>
<p><strong>推理规则</strong>：<br>1.<strong>US（全称特指规则）</strong>：（∀x）G（x）=&gt;G（y），其中y关于G（x）是自由的变元，不是约束的变元<br>2.<strong>ES（存在特指规则）</strong>：（∃x）G（x）=&gt;G（c），其中c为使G（c）为真的个体变量<br>3.<strong>UG（全程推广规则）</strong>：G（y）=&gt;（∀x）G（x），其中G（y）中无自由变元x<br>4.<strong>EG（存在推广原则）</strong>：G（c）=&gt;（∃x）G（x），其中c为特定个体变量</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-2]]></title>
      <url>/2017/10/19/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-2/</url>
      <content type="html"><![CDATA[<p>-主析取范式与主合取范式<br>-逻辑推理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>文字</strong>：命题变元或命题变元的否定<br><strong>析取式</strong>：有限个文字的析取称为析取式，也称子句<br><strong>合取式</strong>：有限个文字的合取称为合取式，也称短语<br><strong>互补对</strong>：P与¬P称为互补对<br><strong>析取范式</strong>：有限个短语的析取式为析取范式<br><strong>合取范式</strong>：有限个子句的合取式为合取范式<br><strong>极小项与极大项</strong>：在含有n个命题变元P1,P2,…,Pn的短语或子句中，若每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅出现一次，并且出现的次序与P1,P2,…,Pn一致，则称此短语或子句为关于P1,P2,…,Pn的一个极小项或极大项<br><strong>主析取范式</strong>：在给定的析取范式中，若每一个短语都是极小项，则称该范式为主析取范式<br><strong>主合取范式</strong>：在给定的合取范式中，若每一个子句都是极大项，则称该范式为主合取范式</p>
<hr>
<p>推理定律：<br>基于真值表技术，由如下关系：<br><strong>简化规则</strong>：<br>G∧H=&gt;G<br>G∧H=&gt;H<br><strong>添加规则</strong>：<br>G=&gt;G∨H<br>H=&gt;G∨H<br>¬G=&gt;G→H<br>H=&gt;H→G<br>G,H=&gt;G∧H<br><strong>选言三段论</strong>：<br>¬G,G→H=&gt;H<br>¬G,G⊕（异或）H=&gt;H<br><strong>肯定前件式</strong>：<br>G,G→H=&gt;H<br><strong>否定后件式</strong>：<br>¬H,G→H=&gt;¬G<br><strong>假言三段论</strong>:<br>G→H,H→I=&gt;G→I<br><strong>二难推论</strong>：<br>G∨H,G→I,H→I=&gt;I</p>
<hr>
<p><strong>规则P</strong>：前提引用规则。在推导的过程中，可随时引入前提集合中的任意一个前提<br><strong>规则T</strong>：逻辑结果引用规则。在推导的过程中，可随时引入公式S，该公式S是由其前的一个或多个公式推导出来的逻辑结果<br><strong>规则CP</strong>：附加前提规则。如果能从给定的前提的集合T与公式P推导出S，则能从此前提集合T推导出P→S</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九度OJ-1001题解]]></title>
      <url>/2017/10/19/%E4%B9%9D%E5%BA%A6OJ-1001/</url>
      <content type="html"><![CDATA[<p>好久没写过Online judge了<br>结果三次才AC</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>题目描述：<br>    This time, you are supposed to find A+B where A and B are two matrices, and then count the number of zero rows and columns.<br>输入：<br>    The input consists of several test cases, each starts with a pair of positive integers M and N (≤10) which are the number of rows and columns of the matrices, respectively. Then 2*M lines follow, each contains N integers in [-100, 100], separated by a space. The first M lines correspond to the elements of A and the second M lines to that of B.<br>    The input is terminated by a zero M and that case must NOT be processed.<br>输出：<br>    For each test case you should output in one line the total number of zero rows and columns of A+B.<br>样例输入：<br>2 2<br>1 1<br>1 1<br>-1 -1<br>10 9<br>2 3<br>1 2 3<br>4 5 6<br>-1 -2 -3<br>-4 -5 -6<br>0<br>样例输出：<br>1<br>5<br>来源：<br>2011年浙江大学计算机及软件工程研究生机试真题</p>
<hr>
<p>题目的意思大概是输入两个数作为数组的行数和列数，然后读入两个这样的数组，执行加法操作，算出元素均为0的行数列数的和。</p>
<hr>
<p><strong>AC代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()&#123;</div><div class="line">	int m,n; //读入数组的行列数 </div><div class="line">	int i,j;</div><div class="line">	int count1,count2=0; //计数器 </div><div class="line">	</div><div class="line">	while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)&#123;</div><div class="line">		int a[m][n];</div><div class="line">		int b[m][n];</div><div class="line">		count2=0; //归零操作 </div><div class="line">		</div><div class="line">		for(i=0;i&lt;m;i++)  //读入第一个数组</div><div class="line">			for(j=0;j&lt;n;j++)</div><div class="line">				cin&gt;&gt;a[i][j];</div><div class="line">				</div><div class="line"></div><div class="line">		for(i=0;i&lt;m;i++)  //读入第二个数组 </div><div class="line">			for(j=0;j&lt;n;j++)&#123; </div><div class="line">				cin&gt;&gt;b[i][j];</div><div class="line">				a[i][j]+=b[i][j]; //执行数组的加法</div><div class="line">			&#125; </div><div class="line">					</div><div class="line">		for(i=0;i&lt;m;i++)&#123;  //算出有多少行是元素均为0的 </div><div class="line">			for(j=0;j&lt;n;j++)		</div><div class="line">				if(a[i][j]==0)</div><div class="line">					count1++;</div><div class="line">				if(count1==n)</div><div class="line">					count2++;</div><div class="line">				count1=0;  //归零操作 </div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		for(j=0;j&lt;n;j++)&#123; //算出有多少列是元素均为0的 </div><div class="line">			for(i=0;i&lt;m;i++)</div><div class="line">				if(a[i][j]==0)</div><div class="line">					count1++;</div><div class="line">				if(count1==m)</div><div class="line">					count2++;</div><div class="line">				count1=0; //归零操作 </div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		cout&lt;&lt;count2&lt;&lt;endl;	</div><div class="line">	&#125;</div><div class="line">	return 0;			 </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 九度OJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-1]]></title>
      <url>/2017/10/18/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-基本等价关系</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>真值</strong>：命题可以取一个值，称为真值。真值只有“真”和“假”两种，分别用“1”(“T”)和“0”(“F”)表示。<br><strong>命题</strong>：具有确切真值的陈述句。</p>
<hr>
<p>一切没有判断内容的句子，都不能作为命题。</p>
<hr>
<p><strong>原子命题</strong>：不能再分解为更简单的命题。<br><strong>复合命题</strong>：可以分解为成简单的命题，与原子命题相对。<br><strong>联结词</strong>：否定联结词（非），合取联结词（并且），析取联结词（或），蕴涵联结词（推理），等价联结词。</p>
<hr>
<p>否定：真值结果取反<br>合取：P，Q同真才真，有假则假<br>析取：P，Q同假才假，有真则真<br>蕴涵：P真Q假时为假，否则为真<br>等价：PQ真值相同为真，否则为假</p>
<hr>
<p><strong>常值命题</strong>：真值不是“真”就是“假”，真值是确定的<br><strong>命题变量</strong>：没有具体的真值，与常值命题相对<br><strong>命题公式</strong>：其中的原子命题是命题变元，复合命题即为命题变元的”函数“，且该函数的真值仍为”真“或”假“<br><strong>解释</strong>：设P1,P2,…,Pn时出现在公式G中的所有命题变元，指定P1，P2，…，Pn一组真值，则这组真值称为G的一个解释<br><strong>真值表</strong>：由公式G在其所有可能的解释下所取的真值构成的表<br><strong>永真公式</strong>：在所有的解释下真值都为”真“<br><strong>永假公式（矛盾式）</strong>：在所有的解释下真值都为”假“<br><strong>可满足公式</strong>：非永假公式<br><strong>等价</strong>：设G,H是两个命题公式，P1，P2，…，Pn是出现在G，H中所有的命题变元，如果对于P1,P2，…，Pn的2的n次方个真值组合的每一个解释，G与H的真值结果都相同，则称G，H等价，记作<strong>G=H</strong></p>
<hr>
<p>命题公式的基本等价关系：<br>1.<strong>幂等律</strong>：<br>G∨G=G<br>G∧G=G<br>2.<strong>交换律</strong> ：<br>G∨H=H∨G<br>G∧H=H∧G<br>3.<strong>结合律</strong>：<br>G∨(H∨S)=(G∨H)∨S<br>G∧(H∧S)=(G∧H)∧S<br>4.<strong>同一律</strong>：<br>G∨0=G<br>G∧1=G<br>5.<strong>零律</strong>：<br>G∨1=1<br>G∧0=0<br>6.<strong>分配律</strong>：<br>G∨(H∧S)=(G∨H)∧(G∨S)<br>G∧(H∨S)=(G∧H)∨(G∧S)<br>7.<strong>吸收律</strong>：<br>G∨(G∧H)=G<br>G∧(G∨H)=G<br>8.<strong>矛盾律</strong>：<br>G∧¬G=0<br>9.<strong>排中律</strong>：<br>G∨¬G=1<br>10.<strong>双重否定律</strong>：<br>¬（¬G）=G<br>11.<strong>德摩根律</strong>：<br>¬(G∨H)=¬G∧¬H<br>¬(G∧H)=¬G∨¬H<br>12.<strong>蕴含式</strong>：<br>G→H=¬G∨H<br>13.<strong>假言易位</strong>：<br> G→H=¬H→¬G<br> 14.<strong>等价式</strong>：<br> G↔H=(G→H)∧(H→G)=(¬G∨H)∧(¬H∨G)<br> 15.<strong>等价否定等式</strong>：<br> G↔H=¬G↔¬H<br> 16.<strong>归谬论</strong>：</p>
<h2 id="G→H-∧-G→¬H-¬G"><a href="#G→H-∧-G→¬H-¬G" class="headerlink" title=" (G→H)∧(G→¬H)=¬G"></a> (G→H)∧(G→¬H)=¬G</h2><p> 更多查看我的blog:<a href="https://beatjerome.github.io" target="_blank" rel="external">https://beatjerome.github.io</a></p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-2]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-2/</url>
      <content type="html"><![CDATA[<p>-处理冲突的方法<br>-散列表查找及性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">处理冲突的方法<font></font></font></strong><br>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。<br>假设已经选定散列函数H(key)，下面用Hi表示发生冲突后第i次探测的散列地址。<br><strong><font size="4">一.开放定址法<font></font></font></strong><br>所谓开放定址法，指的是可存放新表项的空闲地址既指向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式<strong>Hi=（H（key）+di）%m</strong>，其中，i=1,2,…,k（k&lt;=m-1）；m表示散列表表长；di为增量序列。<br>当增量序列即di确定后，则对应的处理方法是确定的。通常有以下四种取法：<br><strong>1）线性探测法</strong><br>当di=1，2，…，m-1，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中的下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出下一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<br><strong>2）平方探测法</strong><br>当di=1²，-1²，2²，-2²，…，k²，-k²，其中k≤m/2，m必须是一个可以表示成4k+3的质数，又称二次探测法。<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一般单元。<br><strong>3）再散列法</strong><br>当di=Hash2（Key），又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H（Key）得到的地址发生冲突时，则利用第二个散列函数Hash2（Key）计算该关键字的地址增量。再散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置。<br><strong>4）伪随机序列法</strong><br>当di=伪随机数序列，称为伪随机序列法。</p>
<p><strong>注意：在开放地址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他<br>具有相同散列地址的元素的查找地址。所以，若想删除一个元素时，给它做一个删除标记，进<br>行逻辑删除。但这样做的副作用是：在执行多次删除后，表面看上去散列表是满的，实际上有<br>许多位置没有利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</strong></p>
<p><strong><font size="4">二.拉链法</font></strong><br>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表中的第i个单元中，因而查找，插入，删除操作主要在同义词链中进行。拉链法适合于经常进行插入删除操作的情况。</p>
<hr>
<p><strong><font size="6">散列表查找及性能分析</font></strong><br>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：<br><strong>初始化：Addr=Hash（key）；</strong><br>①检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败；若有记录，比较它与key值，若相等，返回查找成功标志，否则执行下一步。<br>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置wei此地址，转入步骤①</p>
<pre><code>散列表的查找效率取决与三个因素：散列函数，处理冲突的方法和装填因子
</code></pre><p><strong>装填因子</strong>：散列表的装填因子一般记为α，定义为一个表的装满程度，即<strong>α=表中记录数n/散列表长度m</strong><br>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观上看，α越大，装填程度越满，发生冲突的可能性就越大，反之发生冲突的可能性越小。</p>
<hr>
<p>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的发生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表的查找效率的度量。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-1]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-1/</url>
      <content type="html"><![CDATA[<p>-散列表的基本内容<br>-散列函数的构造方法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">散列表的基本概念<font></font></font></strong><br><strong>散列函数</strong><br>一个把查找表中关键字映射成该关键字对应的地址的函数，记为<strong>Hash(key)=Addr</strong>。（这里的地址可以是数组下标，索引，或内存地址等）<br>散列函数可能会把两个或者两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的办法。<br><strong><font size="5">散列表<font></font></font></strong><br><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。<br><strong>散列函数的构造方法</strong><br>在构造散列函数时，必须注意以下几点：<br>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。<br>2）散列函数计算出来的地址应该能等概率，均匀地分布在整个地址空间，从而减少冲突的发生。<br>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</p>
<hr>
<p><strong><font size="6">常用的散列函数<font></font></font></strong><br><strong>1.直接定址法</strong><br>    直接取关键字的某个线性函数值为散列地址，散列函数为<strong>H(key)=a*key+b</strong>。在这个函数式中，a和b是常数。这种方法计算最简单，并且不会产生冲突。它适合关键字的分布基本连续的情况，如果关键字分布不连续，空位较多，将造成存储空间的浪费。<br><strong>2.除留余数法</strong><br>    这是一种最简单，最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用下列公式把关键字转换成散列地址。散列函数为<strong>H(key)=key%p</strong>。<br>    除留余数法的关键在于选好p，使得每一个关键字在通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减小冲突的可能性。<br><strong>3.数字分析法</strong><br>    设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合。如果更换了关键字，就需要重新构造新的散列函数。<br><strong>4.平方取中法</strong><br>    顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。适合于关键字的每一位取值都不够均匀或均小于散列地址所需的位数的情况。<br><strong>5.折叠法</strong><br>    将关键字分割位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</p>
<hr>
<p>在不同的情况下，不同的散列函数会发挥出不同的性能，因此不能笼统地说哪种散列函数最好。实际选择中，采用何种散列函数的方法取决于关键字集合的情况，但目标是为了使散列产生冲突的可能性尽量地降低。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
