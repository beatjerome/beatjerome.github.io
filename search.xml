<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[散列表-2]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-2/</url>
      <content type="html"><![CDATA[<p>-处理冲突的方法<br>-散列表查找及性能分析<br><a id="more"></a><br><strong><font size="6">处理冲突的方法<font></font></font></strong><br>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。<br>假设已经选定散列函数H(key)，下面用Hi表示发生冲突后第i次探测的散列地址。<br><strong><font size="4">一.开放定址法<font></font></font></strong><br>所谓开放定址法，指的是可存放新表项的空闲地址既指向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式<strong>Hi=（H（key）+di）%m</strong>，其中，i=1,2,…,k（k&lt;=m-1）；m表示散列表表长；di为增量序列。<br>当增量序列即di确定后，则对应的处理方法是确定的。通常有以下四种取法：<br><strong>1）线性探测法</strong><br>当di=1，2，…，m-1，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中的下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出下一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<br><strong>2）平方探测法</strong><br>当di=1²，-1²，2²，-2²，…，k²，-k²，其中k≤m/2，m必须是一个可以表示成4k+3的质数，又称二次探测法。<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一般单元。<br><strong>3）再散列法</strong><br>当di=Hash2（Key），又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H（Key）得到的地址发生冲突时，则利用第二个散列函数Hash2（Key）计算该关键字的地址增量。再散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置。<br><strong>4）伪随机序列法</strong><br>当di=伪随机数序列，称为伪随机序列法。</p>
<p><strong>注意：在开放地址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他<br>具有相同散列地址的元素的查找地址。所以，若想删除一个元素时，给它做一个删除标记，进<br>行逻辑删除。但这样做的副作用是：在执行多次删除后，表面看上去散列表是满的，实际上有<br>许多位置没有利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</strong></p>
<p><strong><font size="4">二.拉链法</font></strong><br>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表中的第i个单元中，因而查找，插入，删除操作主要在同义词链中进行。拉链法适合于经常进行插入删除操作的情况。</p>
<hr>
<p><strong><font size="6">散列表查找及性能分析</font></strong><br>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：<br><strong>初始化：Addr=Hash（key）；</strong><br>①检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败；若有记录，比较它与key值，若相等，返回查找成功标志，否则执行下一步。<br>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置wei此地址，转入步骤①</p>
<pre><code>散列表的查找效率取决与三个因素：散列函数，处理冲突的方法和装填因子
</code></pre><p><strong>装填因子</strong>：散列表的装填因子一般记为α，定义为一个表的装满程度，即<strong>α=表中记录数n/散列表长度m</strong><br>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观上看，α越大，装填程度越满，发生冲突的可能性就越大，反之发生冲突的可能性越小。</p>
<hr>
<p>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的发生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表的查找效率的度量。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-1]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-1/</url>
      <content type="html"><![CDATA[<p>-散列表的基本内容<br>-散列函数的构造方法<br><a id="more"></a><br><strong><font size="6">散列表的基本概念<font></font></font></strong><br><strong>散列函数</strong><br>一个把查找表中关键字映射成该关键字对应的地址的函数，记为<strong>Hash(key)=Addr</strong>。（这里的地址可以是数组下标，索引，或内存地址等）<br>散列函数可能会把两个或者两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的办法。<br><strong><font size="5">散列表<font></font></font></strong><br><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。<br><strong>散列函数的构造方法</strong><br>在构造散列函数时，必须注意以下几点：<br>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。<br>2）散列函数计算出来的地址应该能等概率，均匀地分布在整个地址空间，从而减少冲突的发生。<br>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</p>
<hr>
<p><strong><font size="6">常用的散列函数<font></font></font></strong><br><strong>1.直接定址法</strong><br>    直接取关键字的某个线性函数值为散列地址，散列函数为<strong>H(key)=a*key+b</strong>。在这个函数式中，a和b是常数。这种方法计算最简单，并且不会产生冲突。它适合关键字的分布基本连续的情况，如果关键字分布不连续，空位较多，将造成存储空间的浪费。<br><strong>2.除留余数法</strong><br>    这是一种最简单，最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用下列公式把关键字转换成散列地址。散列函数为<strong>H(key)=key%p</strong>。<br>    除留余数法的关键在于选好p，使得每一个关键字在通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减小冲突的可能性。<br><strong>3.数字分析法</strong><br>    设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合。如果更换了关键字，就需要重新构造新的散列函数。<br><strong>4.平方取中法</strong><br>    顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。适合于关键字的每一位取值都不够均匀或均小于散列地址所需的位数的情况。<br><strong>5.折叠法</strong><br>    将关键字分割位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</p>
<hr>
<p>在不同的情况下，不同的散列函数会发挥出不同的性能，因此不能笼统地说哪种散列函数最好。实际选择中，采用何种散列函数的方法取决于关键字集合的情况，但目标是为了使散列产生冲突的可能性尽量地降低。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
