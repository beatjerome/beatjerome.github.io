<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[算法笔记-note1]]></title>
      <url>/2018/01/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-note1/</url>
      <content type="html"><![CDATA[<p>-简单介绍OJ的做题技巧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>小写字母的ASCII码值比大写字母的大32</p>
<p>字符常量必须用单引号来标注</p>
<p>使用scanf，数组不需要加&amp;运算符，因为数组名称本身就代表这个数组第一个元素的地址。</p>
<p>scanf的%c格式是可以读取空格和换行的</p>
<p>典型输出格式：<br>1.%md可以使不足m位以m位进行右对齐输出，其中高位用空格补齐；<br>如果变量本身超过m位，则保持原样。</p>
<ol>
<li>%.mf可以使让浮点数保留m位小数输出，保留使用的是“四舍六入五成双”规则.</li>
</ol>
<p>typedef用来给复杂的数据类型起别名.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给long long类型起别名L</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> L;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>常用math函数</strong>：<br>1.fabs（double x）函数<br>此函数用于对double型变量取绝对值<br>2.floor（double x）函数<br>此函数用于double型变量的向下取整<br>3.ceil（double x）函数<br>此函数用于double型变量的向上取整<br>4.pow（double r，double p）函数<br>此函数用于返回$r^p$<br>5.sqrt（double x）<br>此函数用于返回double型变量的算数平方根<br>6.log（double x）<br>此函数用于返回double型变量的以自然对数为底的对数<br>7.sin（double x）、cos（double x）、tan（double x）<br>返回double型变量的sin，cos，tan值<br>8.round（double x）<br>该函数用于将double型变量x四舍五入，返回类型也是double型</p>
<hr>
<p><strong>memset函数</strong><br>使用memset函数需要加头文件string.h头文件<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">memset<span class="comment">( a , 0 ,sizeof(a)</span>);<span class="comment">//将数组a的元素全部赋值为0</span></div><div class="line">memset<span class="comment">( a , 1 ,sizeof(a)</span>);<span class="comment">//将数组a的元素全部赋值为1</span></div></pre></td></tr></table></figure></p>
<hr>
<p>gets函数用于输入一行字符串（gets识别换行符\n作为输入结束）<br>puts函数用于输出一行字符串并换行</p>
<hr>
<p><strong>string.h头文件</strong><br>1.strlen函数<br>strlen函数可以得到字符数组中第一个\0前的字符的个数<br>2.strcmp函数<br>strcmp函数返回两个字符串大小的比较结果，按照字典序进行比较，如果字符数组1&lt;字符数组2，返回一个负整数；<font color="#DC143C">如果字符数组1==字符数组2，则返回0</font>;如果字符数组1&gt;字符数组2，则返回一个正整数。<br>3.strcpy函数<br>strcpy函数可以把一个字符串复制给另一个字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcpy</span>(str1,str2);</div><div class="line"><span class="comment">//把字符数组2复制字符数组1</span></div></pre></td></tr></table></figure></p>
<p>4.strcat函数<br>strcat函数可以把一个字符串接到另一个字符串<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">strcat</span>(str1,str2);</div><div class="line"><span class="comment">//把字符数组2接到字符数组1后面</span></div></pre></td></tr></table></figure></p>
<p>5.sscanf函数<br>sscanf函数的作用是把字符数组str中的内容合并以%d的形式写到n中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sscanf(<span class="name">str</span>,<span class="string">"%d"</span>,<span class="symbol">&amp;n</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>6.sprintf函数<br>sprintf函数的作用是把整数n的每一位拆分写入字符数组中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sprintf(<span class="name">str</span>,<span class="string">"%d"</span>,n)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>典型输入方式</strong><br>1.while…EOF型<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">while</span><span class="params">(scanf(<span class="string">"%d"</span>, &amp;n)</span></span>!=EOF)&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.while(T–)型<br>在给定测试数据组数的情况下，使用这种类型的输入</p>
<hr>
<p><strong>典型输出类型</strong><br>1.正常输出<br>2.每组数据输出之后都额外加一个空格<br>直接加printf(“\n”);<br>3.两组输出数据之间有一个空格，最后一局数据后面没有空格<br>只需对是否是最后一行进行判断即可</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Learning notes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[电梯模拟]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%94%B5%E6%A2%AF%E6%A8%A1%E6%8B%9F/</url>
      <content type="html"><![CDATA[<p>-严蔚敏数据结构<br>-电梯模拟系统的实现<br><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"HEAD.h"</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintClientInfo</span><span class="params">(Client p,ClientStatus s)</span></span>&#123;</div><div class="line"><span class="comment">//输出乘客信息</span></div><div class="line">	<span class="keyword">switch</span>(s) &#123;</div><div class="line">		<span class="keyword">case</span> New:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客进入第"</span>&lt;&lt;p.Infloor&lt;&lt;<span class="string">"层"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GiveUp:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t"</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客放弃等待, 等待了"</span>&lt;&lt;Time-p.InTime&lt;&lt;<span class="string">"/0.1s"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Out:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客走出电梯"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> In:<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">'\t'</span>&lt;&lt;p.ClientID&lt;&lt;<span class="string">"号乘客走进电梯，要去第"</span>&lt;&lt;p.Outfloor&lt;&lt;<span class="string">"层"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">CreatClient</span><span class="params">(Client *&amp;p)</span></span>&#123;</div><div class="line">	<span class="comment">//生成新的乘客</span></div><div class="line">	p=<span class="keyword">new</span> Client;							<span class="comment">//新建乘客类型	 </span></div><div class="line">	<span class="keyword">if</span>(!p) 									<span class="comment">//新建乘客失败 </span></div><div class="line">		<span class="keyword">return</span> OVERFLOW;</div><div class="line">	p-&gt;ClientID=ID++;						<span class="comment">//产生乘客编号 </span></div><div class="line">	p-&gt;GiveUpTime=rand()%<span class="number">120</span>+<span class="number">30</span>;			<span class="comment">//产生乘客所能容忍的等待时间</span></div><div class="line">	p-&gt;InTime=Time;							<span class="comment">//产生乘客进入电梯系统的时间 </span></div><div class="line">	InterTime=rand()%<span class="number">300</span>;					<span class="comment">//产生下一乘客要到达的时间</span></div><div class="line">	p-&gt;Outfloor=rand()%(Maxfloor+<span class="number">1</span>);		<span class="comment">//产生乘客所要到达的楼层</span></div><div class="line">	<span class="comment">//该乘客出现的楼层</span></div><div class="line">	<span class="keyword">while</span>((p-&gt;Infloor=rand()%(Maxfloor+<span class="number">1</span>))==p-&gt;Outfloor);</div><div class="line">	<span class="comment">//cin&gt;&gt;p-&gt;Infloor&gt;&gt;p-&gt;Outfloor&gt;&gt;InterTime;</span></div><div class="line">	PrintClientInfo(*p,New);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">DestoryClient</span><span class="params">(Client *&amp;p)</span> </span>&#123;</div><div class="line">	<span class="comment">//该乘客离开系统</span></div><div class="line">	<span class="keyword">delete</span> p;</div><div class="line">	p=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">GoAbove</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断该乘客是否去往高层</span></div><div class="line">	<span class="keyword">if</span>(e.Outfloor&gt;e.Infloor) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CInfloor</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入的楼层</span></div><div class="line">	<span class="keyword">return</span> e.Infloor;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CInTime</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入时间</span></div><div class="line">	<span class="keyword">return</span> e.InTime;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">COutfloor</span><span class="params">(Client <span class="keyword">const</span> &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回乘客进入时间</span></div><div class="line">	<span class="keyword">return</span> e.Outfloor;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(Queue &amp;Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//构造一个空队列Q</span></div><div class="line">	Q.front=Q.rear=<span class="keyword">new</span> QNode;</div><div class="line">	<span class="keyword">if</span>(!Q.front) <span class="keyword">return</span> OVERFLOW;<span class="comment">//分配存储失败</span></div><div class="line">	Q.front-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	Q.front-&gt;data=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(Queue &amp;Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁队列Q</span></div><div class="line">	<span class="keyword">while</span>(Q.front) &#123;</div><div class="line">		Q.rear=Q.front-&gt;next;</div><div class="line">		<span class="keyword">if</span>(Q.front-&gt;data) DestoryClient(Q.front-&gt;data);</div><div class="line">		<span class="keyword">delete</span> Q.front;</div><div class="line">		Q.front=Q.rear;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(Queue &amp;Q,QElemType e)</span> </span>&#123;</div><div class="line">	<span class="comment">//插入元素e为Q的新的队尾元素</span></div><div class="line">	QueuePtr p;</div><div class="line">	p=<span class="keyword">new</span> QNode;</div><div class="line">	<span class="keyword">if</span>(!p) <span class="keyword">return</span> OVERFLOW;</div><div class="line">	p-&gt;data=e;p-&gt;next=<span class="literal">NULL</span>;</div><div class="line">	Q.rear-&gt;next=p;</div><div class="line">	Q.rear=p;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(Queue &amp;Q,QElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//若队列不空,则删除Q的队头元素,用e返回其值,并返回OK;</span></div><div class="line">	<span class="comment">//否则返回ERROR</span></div><div class="line">	QueuePtr p;</div><div class="line">	<span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> ERROR;</div><div class="line">	p=Q.front-&gt;next;</div><div class="line">	e=p-&gt;data;</div><div class="line">	Q.front-&gt;next=p-&gt;next;</div><div class="line">	<span class="keyword">if</span>(Q.rear==p) Q.rear=Q.front;</div><div class="line">	<span class="keyword">delete</span> p;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(Queue Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断队列是否为空</span></div><div class="line">	<span class="keyword">if</span>(Q.front==Q.rear) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span>	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">QDelNode</span><span class="params">(Queue &amp;Q,QueuePtr p)</span> </span>&#123;</div><div class="line">	<span class="comment">//删除队列中p指向的结点的下一个结点</span></div><div class="line">	QueuePtr q;</div><div class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</div><div class="line">	q=p-&gt;next;</div><div class="line">	p-&gt;next=q-&gt;next;</div><div class="line">	<span class="keyword">if</span>(p-&gt;next==<span class="literal">NULL</span>) Q.rear=p;</div><div class="line">	DestoryClient(q-&gt;data);</div><div class="line">	<span class="keyword">delete</span> q;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">CGiveUp</span><span class="params">(Queue &amp;Q,<span class="keyword">int</span> <span class="built_in">floor</span>)</span> </span>&#123;</div><div class="line">	<span class="comment">//删除放弃等待的乘客</span></div><div class="line">	QueuePtr p;</div><div class="line">	p=Q.front;</div><div class="line">	<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>) </div><div class="line">		<span class="keyword">if</span>(p-&gt;next-&gt;data-&gt;GiveUpTime==<span class="number">0</span>&amp;&amp;<span class="built_in">floor</span>!=p-&gt;next-&gt;data-&gt;Infloor) &#123;</div><div class="line">			PrintClientInfo(*(p-&gt;next-&gt;data),GiveUp);</div><div class="line">			TotalTime+=Time-CInTime(*(p-&gt;next-&gt;data));</div><div class="line">			QDelNode(Q,p);<span class="comment">//将放弃等待的人删除</span></div><div class="line">			GiveUpNumber++;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>	p-&gt;next-&gt;data-&gt;GiveUpTime--;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintQueue</span><span class="params">(Queue Q)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出队列</span></div><div class="line">	QueuePtr q;</div><div class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">	<span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>) <span class="keyword">goto</span> end;</div><div class="line">	q=Q.front-&gt;next;</div><div class="line">	<span class="keyword">while</span>(q!=<span class="literal">NULL</span>) &#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;setw(<span class="number">3</span>)&lt;&lt;q-&gt;data-&gt;ClientID&lt;&lt;<span class="string">' '</span>;</div><div class="line">		q=q-&gt;next;</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">end:</div><div class="line">	<span class="keyword">while</span>(count++&lt;=<span class="number">4</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"    "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//构造一个空栈</span></div><div class="line">	S.base=(SElemType *)<span class="built_in">malloc</span>(STACK_INIT_SIZE*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> OVERFLOW;</div><div class="line">	S.top=S.base;</div><div class="line">	S.stacksize=STACK_INIT_SIZE;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//InitStack</span></div><div class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁栈S</span></div><div class="line">	SElemType	*p;</div><div class="line">	<span class="keyword">if</span>(S.base) &#123;</div><div class="line">		<span class="keyword">for</span>(p=S.base;p&lt;S.top;p++)</div><div class="line">			DestoryClient(*p);</div><div class="line">		<span class="built_in">free</span>(S.base);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//把S置为空</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR; </div><div class="line">	S.top=S.base;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(ClientStack S)</span> </span>&#123;</div><div class="line">	<span class="comment">//若栈S为空，则返回TRUE，否则返回FALSE</span></div><div class="line">	<span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">else</span>			  <span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackLength</span><span class="params">(ClientStack S)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回栈S的长度</span></div><div class="line">	<span class="keyword">return</span> S.top-S.base;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(ClientStack S,SElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回栈顶元素</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	e=*(S.top<span class="number">-1</span>);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//GetTop</span></div><div class="line"><span class="function">Status <span class="title">Push</span><span class="params">(ClientStack &amp;S,SElemType e)</span> </span>&#123;</div><div class="line">	<span class="comment">//入栈</span></div><div class="line">	<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	<span class="keyword">if</span>(S.top-S.base&gt;=S.stacksize) &#123;</div><div class="line">		S.base=(SElemType *)<span class="built_in">realloc</span>(S.base,(S.stacksize+STACKINCREMENT)*<span class="keyword">sizeof</span>(SElemType));</div><div class="line">		<span class="keyword">if</span>(!S.base) <span class="keyword">return</span> OVERFLOW;</div><div class="line">		S.top=S.base+S.stacksize;</div><div class="line">		S.stacksize+=STACKINCREMENT;</div><div class="line">	&#125;</div><div class="line">	*S.top++=e;</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//Push</span></div><div class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(ClientStack &amp;S,SElemType &amp;e)</span> </span>&#123;</div><div class="line">	<span class="comment">//出栈</span></div><div class="line">	<span class="keyword">if</span>(S.top==S.base) <span class="keyword">return</span> ERROR;</div><div class="line">	e=*(--S.top);</div><div class="line">	<span class="keyword">return</span> OK;</div><div class="line">&#125;<span class="comment">//Pop</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStack</span><span class="params">(ClientStack &amp;S)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出栈</span></div><div class="line">	SElemType *i;</div><div class="line">	i=S.base;</div><div class="line">	<span class="keyword">while</span>(i&lt;S.top)</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;(*i++)-&gt;ClientID&lt;&lt;<span class="string">' '</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitEle</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//初始化电梯类型</span></div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	E.<span class="built_in">floor</span>=<span class="number">1</span>;<span class="comment">//电梯初始停在第一层</span></div><div class="line">	E.status=Idle;E.Count=OverTime;</div><div class="line">	E.Stage=Down;</div><div class="line">	E.ClientNumber=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		E.CallUp[i]=<span class="number">0</span>;E.CallDown[i]=<span class="number">0</span>;E.CallCar[i]=<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) InitStack(E.S[i]);</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">CountOver</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯计时是否完成</span></div><div class="line">	<span class="keyword">if</span>(E.Count) &#123;</div><div class="line">		E.Count--;<span class="keyword">return</span> FALSE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestoryEle</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//销毁电梯类型</span></div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=Maxfloor;i++) DestroyStack(E.S[i]);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">EleFloor</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回电梯所在的层</span></div><div class="line">	<span class="keyword">return</span> E.<span class="built_in">floor</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">ElevatorStatus <span class="title">EleStatus</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//返回电梯状态</span></div><div class="line">	<span class="keyword">return</span> E.status;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">RequireAbove</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断是否有高层请求</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=E.<span class="built_in">floor</span>+<span class="number">1</span>;i&lt;=Maxfloor;i++)</div><div class="line">		<span class="keyword">if</span>(E.CallCar[i]||E.CallDown[i]||E.CallUp[i]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">RequireBelow</span><span class="params">(Elevator <span class="keyword">const</span> &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断是否有低层请求</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=E.<span class="built_in">floor</span><span class="number">-1</span>;i&gt;=Minfloor;i--)</div><div class="line">		<span class="keyword">if</span>(E.CallCar[i]||E.CallDown[i]||E.CallUp[i]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">EleAchieved</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯是否要停于当前层</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]) <span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Up&amp;&amp;E.CallUp[E.<span class="built_in">floor</span>]||E.Stage==Down&amp;&amp;E.CallDown[E.<span class="built_in">floor</span>])</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Up&amp;&amp;E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;!RequireAbove(E)) &#123;</div><div class="line">		E.Stage=Down;<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(E.Stage==Down&amp;&amp;E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;!RequireBelow(E)) &#123;</div><div class="line">		E.Stage=Up;<span class="keyword">return</span> TRUE;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="function">Status <span class="title">EleOpenDoor</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯是否要开门</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]||E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;E.Stage==Down||E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;E.Stage==Up)</div><div class="line">		<span class="keyword">return</span> TRUE;</div><div class="line">	<span class="keyword">if</span>(E.status==Idle) &#123;</div><div class="line">		<span class="keyword">if</span>(E.CallDown[E.<span class="built_in">floor</span>]) &#123;E.Stage=Down;<span class="keyword">return</span> TRUE;&#125;</div><div class="line">		<span class="keyword">if</span>(E.CallUp[E.<span class="built_in">floor</span>]) &#123;E.Stage=Up;<span class="keyword">return</span> TRUE;&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> FALSE;</div><div class="line">&#125;</div><div class="line"><span class="comment">//*******************************************************************</span></div><div class="line"><span class="function">ElevatorStage <span class="title">EleDecide</span><span class="params">(Elevator &amp;E)</span> </span>&#123;</div><div class="line">	<span class="comment">//判断电梯动作</span></div><div class="line">	<span class="keyword">int</span> Above,Below;</div><div class="line">	Above=RequireAbove(E);</div><div class="line">	Below=RequireBelow(E);</div><div class="line">	<span class="comment">//无请求则停止</span></div><div class="line">	<span class="keyword">if</span>(Above==<span class="number">0</span>&amp;&amp;Below==<span class="number">0</span>) <span class="keyword">return</span> Stop;</div><div class="line">	<span class="comment">//有请求则按请求移动</span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span>(E.Stage==Up) &#123;</div><div class="line">			<span class="keyword">if</span>(Above!=<span class="number">0</span>) <span class="keyword">return</span> Up;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				E.Stage=Down;<span class="keyword">return</span> Down;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">if</span>(Below!=<span class="number">0</span>) <span class="keyword">return</span> Down;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				E.Stage=Up;<span class="keyword">return</span> Up;</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function">Action <span class="title">ElevatorRun</span><span class="params">(Elevator &amp;E)</span></span>&#123;</div><div class="line">	<span class="comment">//电梯状态转换</span></div><div class="line">	<span class="keyword">switch</span>(E.status) &#123;</div><div class="line">		<span class="keyword">case</span> Opening:</div><div class="line">			<span class="comment">//完成开门则转入Opened状态</span></div><div class="line">			E.status=Opened;E.Count=CloseTestTime;</div><div class="line">			<span class="keyword">return</span> DoorOpened;</div><div class="line">		<span class="keyword">case</span> Opened:</div><div class="line">			<span class="comment">//进行关门测试</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Down&amp;&amp;!E.CallCar[E.<span class="built_in">floor</span>]&amp;&amp;!E.CallDown[E.<span class="built_in">floor</span>]||</div><div class="line">				E.Stage==Up&amp;&amp;!E.CallCar[E.<span class="built_in">floor</span>]&amp;&amp;!E.CallUp[E.<span class="built_in">floor</span>]) &#123;<span class="comment">//无人进出，关门</span></div><div class="line">				E.status=Closing;E.Count=DoorTime;</div><div class="line">			&#125;<span class="comment">//if</span></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Closing:</div><div class="line">			<span class="comment">//完成关门则转入Closed状态</span></div><div class="line">			E.status=Closed;</div><div class="line">			<span class="keyword">return</span> DoorClosed;</div><div class="line">		<span class="keyword">case</span> Idle:</div><div class="line">			<span class="comment">//不在第一层且超出所规定的停候时间,电梯向第一层移动</span></div><div class="line">			<span class="keyword">if</span>(E.Count==<span class="number">0</span>) &#123;</div><div class="line">				<span class="keyword">if</span>(E.<span class="built_in">floor</span>!=<span class="number">1</span>) E.CallCar[<span class="number">1</span>]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> E.Count--;</div><div class="line">			<span class="comment">//如果有人可以进入，则开门</span></div><div class="line">			<span class="keyword">if</span>(EleOpenDoor(E)) &#123;</div><div class="line">				E.status=Opening;E.Count=DoorTime;<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		<span class="keyword">case</span> Closed:</div><div class="line">			<span class="comment">//根据EleDecide的返回值设定电梯状态</span></div><div class="line">			<span class="keyword">switch</span>(EleDecide(E)) &#123;</div><div class="line">				<span class="keyword">case</span> Up: E.status=Moving;E.Count=UpTime+Accelerate;<span class="keyword">return</span> GoingUp;</div><div class="line">				<span class="keyword">case</span> Down: E.status=Moving;E.Count=DownTime+Accelerate;<span class="keyword">return</span> GoingDown;</div><div class="line">				<span class="keyword">case</span> Stop:<span class="keyword">if</span>(E.status!=Idle) &#123;E.status=Idle;E.Count=OverTime;&#125;</div><div class="line">			&#125;;<span class="comment">//switch</span></div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Moving:</div><div class="line">			<span class="comment">//完成移动</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Up) E.<span class="built_in">floor</span>++;</div><div class="line">			<span class="keyword">else</span>			E.<span class="built_in">floor</span>--;</div><div class="line">			<span class="keyword">if</span>(EleAchieved(E)) &#123;<span class="comment">//到达目标层，转入减速状态</span></div><div class="line">				E.status=Decelerate;</div><div class="line">				E.Count=DownDecelerate;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> E.Count+=DownTime;<span class="comment">//未到达目标层，继续下降</span></div><div class="line">			<span class="keyword">return</span> Achieved;</div><div class="line">		<span class="keyword">case</span> Decelerate:</div><div class="line">			<span class="comment">//完成减速</span></div><div class="line">			<span class="comment">//确定正确的电梯时期</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Up&amp;&amp;!E.CallUp[E.<span class="built_in">floor</span>]&amp;&amp;!RequireAbove(E)) E.Stage=Down;</div><div class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(E.Stage==Down&amp;&amp;!E.CallDown[E.<span class="built_in">floor</span>]&amp;&amp;!RequireBelow(E)) E.Stage=Up;</div><div class="line">			<span class="comment">//转到开门状态</span></div><div class="line">			E.status=Opening;E.Count=DoorTime;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">	&#125;;<span class="comment">//switch</span></div><div class="line">	<span class="keyword">return</span> None;</div><div class="line">&#125;<span class="comment">//ElevatorRun</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOut</span><span class="params">(Elevator &amp;E,Queue w[Maxfloor+<span class="number">1</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//进行乘客的进出电梯活动</span></div><div class="line">	<span class="comment">//注意：电梯时期要正确，否则乘客无法进入。</span></div><div class="line">	Client *p;</div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]) <span class="comment">//人要从电梯中走出</span></div><div class="line">		<span class="keyword">if</span>(StackEmpty(E.S[E.<span class="built_in">floor</span>])) E.CallCar[E.<span class="built_in">floor</span>]=<span class="number">0</span>;</div><div class="line">		<span class="keyword">else</span> &#123;<span class="comment">//当前层的乘客栈非空，出电梯</span></div><div class="line">			Pop(E.S[E.<span class="built_in">floor</span>],p);E.ClientNumber--;</div><div class="line">			InOutCount=InOutTime;</div><div class="line">			PrintClientInfo(*p,Out);</div><div class="line">			TotalTime+=Time-CInTime(*p);</div><div class="line">			DestoryClient(p);</div><div class="line">		&#125;<span class="comment">//else</span></div><div class="line">	<span class="keyword">if</span>(E.CallCar[E.<span class="built_in">floor</span>]==<span class="number">0</span>) <span class="comment">//有人要走入电梯</span></div><div class="line">		<span class="keyword">if</span>(!QueueEmpty(w[E.<span class="built_in">floor</span>][E.Stage])) &#123;<span class="comment">//若队列不空，继续进电梯</span></div><div class="line">			DeQueue(w[E.<span class="built_in">floor</span>][E.Stage],p);</div><div class="line">			Push(E.S[COutfloor(*p)],p);</div><div class="line">			<span class="keyword">if</span>(E.CallCar[COutfloor(*p)]!=<span class="number">1</span>) &#123;</div><div class="line">				<span class="comment">//按下要去楼层的按钮</span></div><div class="line">				E.CallCar[COutfloor(*p)]=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			E.ClientNumber++;</div><div class="line">			InOutCount=InOutTime;</div><div class="line">			PrintClientInfo(*p,In);</div><div class="line">		&#125;<span class="comment">//if</span></div><div class="line">		<span class="keyword">else</span> &#123;<span class="comment">//乘客的进出活动已完成</span></div><div class="line">			<span class="keyword">if</span>(E.Stage==Down) E.CallDown[E.<span class="built_in">floor</span>]=<span class="number">0</span>;<span class="comment">//将相应的下降按钮取消</span></div><div class="line">			<span class="keyword">else</span> E.CallUp[E.<span class="built_in">floor</span>]=<span class="number">0</span>;<span class="comment">//将相应的上升按钮取消</span></div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewClient</span><span class="params">(Elevator &amp;E,Queue w[<span class="number">5</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//进入新乘客</span></div><div class="line">	Client *p;</div><div class="line">	CreatClient(p);<span class="comment">//新的乘客</span></div><div class="line">	<span class="comment">//将该乘客插入相应队列并按下相应按钮(Up/Down)</span></div><div class="line">	<span class="keyword">if</span>(GoAbove(*p)) &#123;</div><div class="line">		EnQueue(w[CInfloor(*p)][Up],p);E.CallUp[CInfloor(*p)]=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		EnQueue(w[CInfloor(*p)][Down],p);E.CallDown[CInfloor(*p)]=<span class="number">1</span>;</div><div class="line">	&#125;<span class="comment">//else</span></div><div class="line">&#125;</div><div class="line"><span class="comment">/**********************************************************/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintStatus</span><span class="params">(Elevator &amp;E,Queue w[<span class="number">5</span>][<span class="number">2</span>])</span> </span>&#123;</div><div class="line">	<span class="comment">//输出当前状态</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=Maxfloor;i&gt;=<span class="number">0</span>;i--)&#123;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;setw(<span class="number">2</span>)&lt;&lt;i&lt;&lt;<span class="string">"层"</span>;</div><div class="line">		<span class="keyword">if</span>(i==Maxfloor) <span class="built_in">cout</span>&lt;&lt;<span class="string">"↓"</span>;</div><div class="line">		<span class="keyword">else</span>	<span class="built_in">cout</span>&lt;&lt;<span class="string">"↑"</span>;</div><div class="line">		<span class="keyword">if</span>(i==Maxfloor) &#123;</div><div class="line">			PrintQueue(w[i][Down]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i==<span class="number">0</span>) &#123;</div><div class="line">			PrintQueue(w[i][Up]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span>(i!=Maxfloor&amp;&amp;i!=<span class="number">0</span>) &#123;</div><div class="line">			PrintQueue(w[i][Up]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			PrintStack(E.S[i]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"      ↓"</span>;</div><div class="line">			PrintQueue(w[i][Down]);</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"‖"</span>;</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Elevator &amp;E,Action a)</span> </span>&#123;</div><div class="line">	<span class="comment">//输出电梯动作信息</span></div><div class="line">	<span class="keyword">switch</span>(a) &#123;</div><div class="line">		<span class="keyword">case</span> DoorOpened:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯门已打开"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> DoorClosed:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯门已关闭"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> Achieved:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯已到达第"</span>&lt;&lt;E.<span class="built_in">floor</span>&lt;&lt;<span class="string">"层。"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GoingUp:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯上升中..."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> GoingDown:</div><div class="line">			<span class="built_in">cout</span>&lt;&lt;Time&lt;&lt;<span class="string">"\t电梯下降中..."</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">default</span>:<span class="keyword">break</span>;</div><div class="line">	&#125;;<span class="comment">//switch</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	Elevator E;<span class="comment">//电梯</span></div><div class="line">	Queue	w[Maxfloor+<span class="number">1</span>][<span class="number">2</span>];<span class="comment">//每层都有两个等待队列：上楼队列和下楼队列</span></div><div class="line">	<span class="comment">//初始化</span></div><div class="line">	InitEle(E);</div><div class="line">	srand( (<span class="keyword">unsigned</span>)time( <span class="literal">NULL</span> ));</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		InitQueue(w[i][Up]);</div><div class="line">		InitQueue(w[i][Down]);</div><div class="line">	&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> test</span></div><div class="line">	MaxTime=<span class="number">10000</span>;<span class="comment">//12099999</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入电梯的运行时间："</span>;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;MaxTime;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">	<span class="keyword">while</span>(Time++&lt;MaxTime) &#123;</div><div class="line">		<span class="comment">//---------------乘客事件----------------</span></div><div class="line">		<span class="comment">//新乘客进入事件</span></div><div class="line">		<span class="keyword">if</span>(InterTime==<span class="number">0</span>) NewClient(E,w);</div><div class="line">		<span class="keyword">else</span> InterTime--;</div><div class="line">		<span class="comment">//乘客放弃事件放弃</span></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++)</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++) &#123;</div><div class="line">				CGiveUp(w[i][j],EleFloor(E));</div><div class="line">			&#125;</div><div class="line">		<span class="comment">//乘客进出事件</span></div><div class="line">		<span class="keyword">if</span>(InOutCount==<span class="number">0</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(EleStatus(E)==Opened) InOut(E,w);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> InOutCount--;</div><div class="line">		<span class="comment">//---------------电梯事件----------------</span></div><div class="line">		<span class="keyword">if</span>(CountOver(E)||EleStatus(E)==Closed||EleStatus(E)==Idle) &#123;</div><div class="line">			Action a;</div><div class="line">			a=ElevatorRun(E);</div><div class="line"></div><div class="line">			Print(E,a);</div><div class="line">			<span class="keyword">if</span>(EleStatus(E)==Decelerate) PrintStatus(E,w);</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Sleep(<span class="number">100</span>);<span class="comment">//延迟0.1s</span></div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"共"</span>&lt;&lt;ID&lt;&lt;<span class="string">"人进入系统，"</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"共"</span>&lt;&lt;GiveUpNumber&lt;&lt;<span class="string">"人放弃。"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"平均等待时间为："</span>&lt;&lt;TotalTime/(ID)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	DestoryEle(E);</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=Maxfloor;i++) &#123;</div><div class="line">		DestroyQueue(w[i][Up]);</div><div class="line">		DestroyQueue(w[i][Down]);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[银行业务模拟系统]]></title>
      <url>/2018/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%B6%E8%A1%8C%E4%B8%9A%E5%8A%A1%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>-严蔚敏数据结构-银行业务模拟系统的实现<br><a id="more"></a><br>1.需求分析<br>1.1输入的形式<br>输入的元素为整型类型；<br>输入的银行初始存款必须大于0；<br>输入的银行营业时间必须大于0且必须小于1440（一天）；<br>输入的最大到达时间间隔必须大于0且必须小于银行营业时间；<br>输入的最小到达时间间隔必须大于0且必须小于最大到达时间间隔；<br>输入的最大处理时间必须大于0且必须小于银行营业时间；<br>输入的最小处理时间必须大于0且必须小于最大处理时间；<br>输入的交易额的最大上线必须大于0且必须小于银行初始存款且必须小于50000；<br>1.2输出的形式<br>输出的形式为以列表的形式输出事件处理序列；<br>并在列表输出完后输出需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。<br>1.3程序功能<br>实现银行业务的事件驱动模拟系统，通过模拟方法求出客户在银行内逗留的平均时间。<br>1.4测试<br>测试数据由程序用户手动输入，此处对于正确输入和错误输入给出样例。<br>(1)错误的输入<br><img src="http://img.blog.csdn.net/20180114155033297?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155050944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155058083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114155106109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(2)正确的输入<br><img src="http://img.blog.csdn.net/20180114155125026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>(3)对应的输出结果<br><img src="http://img.blog.csdn.net/20180114155138754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>2.概要设计<br>2.1数据类型<br>本设计中用到的数据结构ADT定义如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">ADT <span class="built_in">Queue</span>&#123;</div><div class="line">    数据对象：D＝&#123; ai | ai∈ElemSet, i=<span class="number">1</span>,<span class="number">2</span>,<span class="params">...</span>,n,  n≥<span class="number">0</span> &#125;</div><div class="line">    数据关系：R1＝&#123; &lt;ai<span class="number">-1</span>, ai&gt;|ai<span class="number">-1</span>, ai∈D, i=<span class="number">2</span>,<span class="params">...</span>,n &#125;</div><div class="line">    基本操作：</div><div class="line"><span class="literal">void</span> InitQueue(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">操作结果：构造空队列Q</div><div class="line">CustNode *Queuefront(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：返回队首元素</div><div class="line">CustNode *Queuerear(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：返回队尾元素</div><div class="line"><span class="literal">void</span> EnQueue(<span class="built_in">Queue</span> &amp;Q,int e);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：插入元素e为Q的新的队尾元素。</div><div class="line"><span class="literal">void</span> DeQueue(<span class="built_in">Queue</span> &amp;Q);</div><div class="line">初始条件：队列Q存在</div><div class="line">操作结果：删除Q的队头元素。</div><div class="line">&#125;ADT <span class="built_in">Queue</span></div></pre></td></tr></table></figure></p>
<p>2.2主程序的流程<br>主程序先是让外部进行测试数据输入，待测试数据输入完后，执行银行业务模拟系统，产生需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</p>
<p>2.3程序模块说明<br><img src="http://img.blog.csdn.net/20180114155223988?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>3.详细设计<br>3.1头文件声明<br>为了增强代码可读性，使用头文件来记录各类结构体的声明以及常用变量的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Bank_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _Bank_H_</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*客户结点类型*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustNode</span>&#123;</span>  						</div><div class="line">    <span class="keyword">int</span> num; 							<span class="comment">//客户号  </span></div><div class="line">    <span class="built_in">string</span> Type; 						<span class="comment">//到达或离开  </span></div><div class="line">    <span class="keyword">int</span> BeginTime;						<span class="comment">//到达时间  </span></div><div class="line">    <span class="keyword">int</span> EndTime;						<span class="comment">//离开时间  </span></div><div class="line">    <span class="keyword">int</span> Amount; 						<span class="comment">//正数为存款，负数为取款  </span></div><div class="line">    CustNode *next;					<span class="comment">//指针域  </span></div><div class="line">&#125;;  </div><div class="line"></div><div class="line">Struct Client&#123;</div><div class="line">Int arrivertime;					<span class="comment">//到达时间</span></div><div class="line">Int durtime;						<span class="comment">//逗留时间</span></div><div class="line">Int amount;						<span class="comment">//办理业务金额</span></div><div class="line">Client *next;						<span class="comment">//指针域</span></div><div class="line">&#125;;</div><div class="line">Client pool[MaxNumber];</div><div class="line"></div><div class="line"><span class="comment">/*等待队列类型*/</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span> 						  </div><div class="line">    CustNode *front;					<span class="comment">//队列头指针  </span></div><div class="line">    CustNode *rear;					<span class="comment">//队列尾指针  </span></div><div class="line">&#125;Queue;  </div><div class="line"></div><div class="line"><span class="comment">/*常用变量定义*/</span></div><div class="line"><span class="keyword">int</span> BankAmount; 						<span class="comment">//初始时银行现存资金总额  </span></div><div class="line"><span class="keyword">int</span> CloseTime; 						<span class="comment">//营业结束时间  </span></div><div class="line"><span class="keyword">int</span> ClientArriveMaxTime; 				<span class="comment">//两个到达事件之间的间隔上限  </span></div><div class="line"><span class="keyword">int</span> ClientArriveMinTime; 				<span class="comment">//两个到达事件之间的间隔下限  </span></div><div class="line"><span class="keyword">int</span> DealMaxTime; 						<span class="comment">//客户之间交易的时间上限  </span></div><div class="line"><span class="keyword">int</span> DealMinTime; 						<span class="comment">//客户之间交易的时间下限  </span></div><div class="line"><span class="keyword">int</span> MaxAmount; 						<span class="comment">//交易额上限  </span></div><div class="line"><span class="keyword">int</span> NeedIn=<span class="number">0</span>;							<span class="comment">//需要存款的人数  </span></div><div class="line"><span class="keyword">int</span> NeedOut=<span class="number">0</span>;						<span class="comment">//需要取款的人数  </span></div><div class="line"><span class="keyword">int</span> SuccessIn=<span class="number">0</span>;						<span class="comment">//成功存款的人数  </span></div><div class="line"><span class="keyword">int</span> SuccessOut=<span class="number">0</span>;						<span class="comment">//成功取款的人数  </span></div><div class="line"><span class="keyword">int</span> CurrentTime=<span class="number">0</span>; 					<span class="comment">//当前时间  </span></div><div class="line"><span class="keyword">int</span> BankAmountTime=<span class="number">0</span>; 				<span class="comment">//客户逗留总时间  </span></div><div class="line"><span class="keyword">int</span> counter=<span class="number">0</span>; 						<span class="comment">//客户总数  </span></div><div class="line"><span class="keyword">int</span> number=<span class="number">1</span>; 						<span class="comment">//初始客户序列号  </span></div><div class="line"><span class="keyword">bool</span> state=<span class="number">1</span>; 							<span class="comment">//用于判断是否有窗口在处理  </span></div><div class="line"><span class="keyword">int</span> DealTime=<span class="number">0</span>;						<span class="comment">//交易时间  </span></div><div class="line"><span class="keyword">int</span> MaxTime=<span class="number">0</span>;						<span class="comment">//最大到达时间  </span></div><div class="line">Queue Event; 							<span class="comment">//事件队列  </span></div><div class="line">Queue Q1; 							<span class="comment">//队列一  </span></div><div class="line">Queue Q2; 							<span class="comment">//队列二 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div><div class="line">573</div><div class="line">574</div><div class="line">575</div><div class="line">576</div><div class="line">577</div><div class="line">578</div><div class="line">579</div><div class="line">580</div><div class="line">581</div><div class="line">582</div><div class="line">583</div><div class="line">584</div><div class="line">585</div><div class="line">586</div><div class="line">587</div><div class="line">588</div><div class="line">589</div><div class="line">590</div><div class="line">591</div><div class="line">592</div><div class="line">593</div><div class="line">594</div><div class="line">595</div><div class="line">596</div><div class="line">597</div><div class="line">598</div><div class="line">599</div><div class="line">600</div><div class="line">601</div><div class="line">602</div><div class="line">603</div><div class="line">604</div><div class="line">605</div><div class="line">606</div><div class="line">607</div><div class="line">608</div><div class="line">609</div><div class="line">610</div><div class="line">611</div><div class="line">612</div><div class="line">613</div><div class="line">614</div><div class="line">615</div><div class="line">616</div><div class="line">617</div><div class="line">618</div><div class="line">619</div><div class="line">620</div><div class="line">621</div><div class="line">622</div><div class="line">623</div><div class="line">624</div><div class="line">625</div><div class="line">626</div><div class="line">627</div><div class="line">628</div><div class="line">629</div><div class="line">630</div><div class="line">631</div><div class="line">632</div><div class="line">633</div><div class="line">634</div><div class="line">635</div><div class="line">636</div><div class="line">637</div><div class="line">638</div><div class="line">639</div><div class="line">640</div><div class="line">641</div><div class="line">642</div><div class="line">643</div><div class="line">644</div><div class="line">645</div><div class="line">646</div><div class="line">647</div><div class="line">648</div><div class="line">649</div><div class="line">650</div><div class="line">651</div><div class="line">652</div><div class="line">653</div><div class="line">654</div><div class="line">655</div><div class="line">656</div><div class="line">657</div><div class="line">658</div><div class="line">659</div><div class="line">660</div><div class="line">661</div><div class="line">662</div><div class="line">663</div><div class="line">664</div><div class="line">665</div><div class="line">666</div><div class="line">667</div><div class="line">668</div><div class="line">669</div><div class="line">670</div><div class="line">671</div><div class="line">672</div><div class="line">673</div><div class="line">674</div><div class="line">675</div><div class="line">676</div><div class="line">677</div><div class="line">678</div><div class="line">679</div><div class="line">680</div><div class="line">681</div><div class="line">682</div><div class="line">683</div><div class="line">684</div><div class="line">685</div><div class="line">686</div><div class="line">687</div><div class="line">688</div><div class="line">689</div><div class="line">690</div><div class="line">691</div><div class="line">692</div><div class="line">693</div><div class="line">694</div><div class="line">695</div><div class="line">696</div><div class="line">697</div><div class="line">698</div><div class="line">699</div><div class="line">700</div><div class="line">701</div><div class="line">702</div><div class="line">703</div><div class="line">704</div><div class="line">705</div><div class="line">706</div><div class="line">707</div><div class="line">708</div><div class="line">709</div><div class="line">710</div><div class="line">711</div><div class="line">712</div><div class="line">713</div><div class="line">714</div><div class="line">715</div><div class="line">716</div><div class="line">717</div><div class="line">718</div><div class="line">719</div><div class="line">720</div><div class="line">721</div><div class="line">722</div><div class="line">723</div><div class="line">724</div><div class="line">725</div><div class="line">726</div><div class="line">727</div><div class="line">728</div><div class="line">729</div><div class="line">730</div><div class="line">731</div><div class="line">732</div><div class="line">733</div><div class="line">734</div><div class="line">735</div><div class="line">736</div><div class="line">737</div><div class="line">738</div><div class="line">739</div><div class="line">740</div><div class="line">741</div><div class="line">742</div><div class="line">743</div><div class="line">744</div><div class="line">745</div><div class="line">746</div><div class="line">747</div><div class="line">748</div><div class="line">749</div><div class="line">750</div><div class="line">751</div><div class="line">752</div><div class="line">753</div><div class="line">754</div><div class="line">755</div><div class="line">756</div><div class="line">757</div><div class="line">758</div><div class="line">759</div><div class="line">760</div><div class="line">761</div><div class="line">762</div><div class="line">763</div><div class="line">764</div><div class="line">765</div><div class="line">766</div><div class="line">767</div><div class="line">768</div><div class="line">769</div><div class="line">770</div><div class="line">771</div><div class="line">772</div><div class="line">773</div><div class="line">774</div><div class="line">775</div><div class="line">776</div><div class="line">777</div><div class="line">778</div><div class="line">779</div><div class="line">780</div><div class="line">781</div><div class="line">782</div><div class="line">783</div><div class="line">784</div><div class="line">785</div><div class="line">786</div><div class="line">787</div><div class="line">788</div><div class="line">789</div><div class="line">790</div><div class="line">791</div><div class="line">792</div><div class="line">793</div><div class="line">794</div><div class="line">795</div><div class="line">796</div><div class="line">797</div><div class="line">798</div><div class="line">799</div><div class="line">800</div><div class="line">801</div><div class="line">802</div><div class="line">803</div><div class="line">804</div><div class="line">805</div><div class="line">806</div><div class="line">807</div><div class="line">808</div><div class="line">809</div></pre></td><td class="code"><pre><div class="line"><span class="number">3.2</span>选做算法</div><div class="line"><span class="number">3.2</span>.<span class="number">1</span>动态分配函数</div><div class="line"><span class="comment">/*出栈，将栈顶元素的下标返回*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Client *p&lt;-栈顶指针</div><div class="line">e的arrivetime&lt;-栈顶元素的arrivertime</div><div class="line">e的durtime&lt;-栈顶元素的durtime</div><div class="line">e的amount&lt;-栈顶元素的amount</div><div class="line">栈顶指针指向下一元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> myMalloc(Stack &amp;S,Client &amp;e)&#123;</div><div class="line">Client *p=S.top;</div><div class="line">e.arrivetime=(*S.top).arrivetime;</div><div class="line">e.durtime=(*S.top).durtime;</div><div class="line">e.amount=(*S.top).amount;</div><div class="line">p-&gt;next=p-&gt;next-&gt;next;</div><div class="line">S.top++;</div><div class="line">p=p-&gt;next；</div><div class="line">&#125;</div><div class="line"><span class="number">3.2</span>.<span class="number">2</span>归还函数</div><div class="line"><span class="comment">/*把该分量入栈*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Client *p&lt;-栈顶指针</div><div class="line">栈底元素的arrivertimee&lt;-e的arrivetime</div><div class="line">栈底元素的durtime&lt;-e的durtime</div><div class="line">栈底元素的amount&lt;-e的amount</div><div class="line">栈底指针指向下一元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> myFree(Stack &amp;S,Client e)&#123;</div><div class="line">Client *p=S.rear;</div><div class="line">(*S.rear).arrivertime=e.arrivetime;</div><div class="line">(*S.rear).durtime=e.durtime;</div><div class="line">(*S.rear).amount=e.amount;</div><div class="line">p-&gt;next=p-&gt;next-&gt;next;</div><div class="line">S.rear++;</div><div class="line">p=p-&gt;next；</div><div class="line">&#125;</div><div class="line"><span class="number">3.3</span>函数算法</div><div class="line"><span class="number">3.3</span>.<span class="number">1</span>创建队列</div><div class="line"><span class="comment">/*初始化操作，建立一个空队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin </div><div class="line">分配存储空间给头结点和尾结点</div><div class="line">IF头结点内存分配失败  </div><div class="line">EXIT</div><div class="line">头结点的指针域&lt;-空 </div><div class="line">End </div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> InitQueue(Queue &amp;Q)&#123;  </div><div class="line">    Q.front=Q.rear=(CustNode*)malloc(sizeof(CustNode));  </div><div class="line">    <span class="keyword">if</span>(!(Q.front))  </div><div class="line">         exit(<span class="number">1</span>);  </div><div class="line">    Q.front-&gt;next=<span class="number">0</span>;  </div><div class="line"> &#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">2</span>入队列</div><div class="line"><span class="comment">/*插入元素e为队列Q的新的队尾元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">分配存储空间给结点p</div><div class="line">结点p的金额置&lt;-e</div><div class="line">结点p的指针域&lt;-空</div><div class="line">IF队列&lt;-空</div><div class="line">Begin</div><div class="line">头指针&lt;-p</div><div class="line">尾指针&lt;-p</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">头指针next域&lt;-p</div><div class="line">尾指针&lt;-尾指针next域</div><div class="line">End</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> EnQueue(Queue &amp;Q,int e)&#123;  </div><div class="line">    CustNode* p=<span class="keyword">new</span> CustNode;  </div><div class="line">    p-&gt;Amount=e;  </div><div class="line">    p-&gt;next=NULL; </div><div class="line">    <span class="keyword">if</span>(Q.front==NULL)&#123;		</div><div class="line">    <span class="regexp">//队列为空，初始化    </span></div><div class="line"><span class="regexp">		Q.front=p;  </span></div><div class="line"><span class="regexp">        Q.rear=p;  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    else&#123; 					  </span></div><div class="line"><span class="regexp">    //</span>队列不为空，插入结点p    </div><div class="line">		Q.rear-&gt;next=p;  </div><div class="line">        Q.rear=Q.rear-&gt;next;  </div><div class="line">    &#125;  </div><div class="line">&#125; </div><div class="line"><span class="number">3.3</span>.<span class="number">3</span>出队列</div><div class="line"><span class="comment">/*使p中的第一个元素出队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">p&lt;-头指针</div><div class="line">IF p的next域&lt;-空</div><div class="line">Begin</div><div class="line">头指针&lt;-空</div><div class="line">尾指针&lt;-空</div><div class="line">End</div><div class="line">ELSE</div><div class="line">头指针&lt;-头指针的next域</div><div class="line">DELETE p</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> DeQueue(Queue &amp;Q)&#123;  </div><div class="line">    CustNode *p;  </div><div class="line">    p=Q.front;  </div><div class="line">    <span class="keyword">if</span>(Q.front-&gt;next==NULL)		<span class="regexp">//队列只有一个元素  </span></div><div class="line"><span class="regexp">        Q.front=Q.rear=NULL;  </span></div><div class="line"><span class="regexp">    else  						//</span>调整队列头指针 </div><div class="line">        Q.front=Q.front-&gt;next;  </div><div class="line">    <span class="keyword">delete</span> p;  </div><div class="line">&#125;</div><div class="line"><span class="number">3.3</span>.<span class="number">4</span>取队首</div><div class="line"><span class="comment">/*返回队首元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin	</div><div class="line">Return 队首元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *Queuefront(Queue &amp;Q)&#123;  </div><div class="line">    <span class="keyword">return</span> Q.front;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="number">3.3</span>.<span class="number">5</span>取队尾  </div><div class="line"><span class="comment">/*返回队尾元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">Return 队尾元素</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *Queuerear(Queue &amp;Q)&#123;  </div><div class="line">    <span class="keyword">return</span> Q.rear;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">6</span>处理客户到达事件</div><div class="line"><span class="comment">/*随机产生顾客，进入队列一产生到达事件 进入事件队列*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">调用EnQueue(Q1,随机数）</div><div class="line">Q1尾结点的BeginTime&lt;-CurrentTime</div><div class="line">Q1尾结点的num&lt;-number</div><div class="line">EnQueue(Event,尾结点的金额)</div><div class="line">Event尾结点的BeginTime&lt;-CurrentTime</div><div class="line">Event尾结点的Type&lt;-到达</div><div class="line">Event尾结点的num&lt;-number</div><div class="line">number&lt;-number+<span class="number">1</span></div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> ClientArrive()&#123;  </div><div class="line">    EnQueue(Q1,(rand()%(<span class="number">2</span>*MaxAmount)-MaxAmount));  	<span class="regexp">//随机产生顾客加入第一队列  </span></div><div class="line"><span class="regexp">    Queuerear(Q1)-&gt;BeginTime=CurrentTime;				//</span>当前时间为客户的到达时间  </div><div class="line">    Queuerear<span class="function"><span class="params">(Q1)</span>-&gt;</span>num=number;						<span class="regexp">//客户号为客户序列号  </span></div><div class="line"><span class="regexp">    EnQueue(Event,(Queuerear(Q1)-&gt;Amount)); 			//</span>将产生事件加入事件队列  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>BeginTime=CurrentTime;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"到达"</span>;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=number;  </div><div class="line">    number++;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">7</span>存款</div><div class="line"><span class="comment">/*对客户存款事件进行处理*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">BankAmount&lt;-BankAmount+Q1头结点的Amount</div><div class="line">调用EnQueue(Event,Q1头结点的Amount)</div><div class="line">Event尾结点的Type&lt;-离开</div><div class="line">Event尾结点的num&lt;-Q1头结点的num</div><div class="line">Event尾结点的EndTime&lt;-Q1头结点的BeginTime+随机处理时间</div><div class="line">counter&lt;-counter+<span class="number">1</span></div><div class="line">BankAmountTime&lt;-BankAmountTime+Event尾结点的EndTime-Q1头结点的BeginTime</div><div class="line">调用DeQueue(Q1)</div><div class="line">DealTime&lt;-Event尾结点的EndTime</div><div class="line">state&lt;-<span class="number">0</span></div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> InAmount()&#123;</div><div class="line">    BankAmount+=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>Amount; 			<span class="regexp">//更新资金总额  </span></div><div class="line"><span class="regexp">    EnQueue(Event,Queuefront(Q1)-&gt;Amount); 		//</span>加入事件队列   </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">    Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>num;  </div><div class="line">    <span class="regexp">//离开时间为到达时间加上随机产生的介于最大处理时间和最小处理时间的处理时间 Queuerear(Event)-&gt;EndTime=(Queuefront(Q1)-&gt;BeginTime+rand()%(DealMaxTime-DealMinTime +1)+DealMinTime);  </span></div><div class="line"><span class="regexp">    counter++; 									//</span>更新客户总数  </div><div class="line">BankAmountTime+=<span class="function"><span class="params">(Queuerear(Event)-&gt;EndTime-Queuefront(Q1)-&gt;BeginTime)</span>; 	</span></div><div class="line"><span class="function">//更新逗留时间  </span></div><div class="line"><span class="function">    <span class="title">DeQueue</span><span class="params">(Q1)</span>; 								//删除第一队列第一个业务  </span></div><div class="line"><span class="function">    <span class="title">DealTime</span>=<span class="title">Queuerear</span><span class="params">(Event)</span>-&gt;</span>EndTime;			<span class="regexp">//交易时间为客户的离开时间  </span></div><div class="line"><span class="regexp">    state=0;										//</span>窗口没有交易需要处理  </div><div class="line">&#125; </div><div class="line"><span class="number">3.3</span>.<span class="number">8</span>取款或借款</div><div class="line"><span class="comment">/*对客户取款或借款事件进行处理*/</span></div><div class="line">伪码表示：</div><div class="line">Begin</div><div class="line">IF -Q1头结点的Amount&gt;BankAmount</div><div class="line">Begin</div><div class="line">调用EnQueue(Q2,Q1头结点的Amount)</div><div class="line">Q2尾结点的BeginTime&lt;-Q1头结点的BeginTime</div><div class="line">Q2尾结点的num&lt;-Q1头结点的num</div><div class="line">调用DeQueue(Q1)</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">BankAmount&lt;-BankAmount+Q1尾结点的Amount</div><div class="line">调用EnQueue(Event,Q1头结点的Amount)</div><div class="line">Event尾结点的Type&lt;-离开</div><div class="line">Event尾结点的num&lt;-Q1头结点的num</div><div class="line">Event尾结点的EndTime&lt;-Q1头结点的BeginTime+随机处理时间</div><div class="line">DealTime&lt;-Event尾结点的EndTime</div><div class="line">counter&lt;-counter+<span class="number">1</span></div><div class="line">BankAmountTime&lt;-Event尾结点的EndTime-Q1尾结点的BeginTime</div><div class="line">调用DeQueue(Q1)</div><div class="line">State&lt;-<span class="number">0</span></div><div class="line">End</div><div class="line">End</div><div class="line">代码表示：</div><div class="line"><span class="literal">void</span> OutAmount()&#123;   </div><div class="line">    <span class="keyword">if</span>((-Q1.front-&gt;Amount)&gt;BankAmount)&#123;		   </div><div class="line">    <span class="regexp">//资金短缺 加入第二队列  </span></div><div class="line"><span class="regexp">        EnQueue(Q2,Queuefront(Q1)-&gt;Amount);  </span></div><div class="line"><span class="regexp">        Queuerear(Q2)-&gt;BeginTime=Queuefront(Q1)-&gt;BeginTime;  </span></div><div class="line"><span class="regexp">        Queuerear(Q2)-&gt;num=Queuefront(Q1)-&gt;num;  </span></div><div class="line"><span class="regexp">        DeQueue(Q1);  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    else&#123;  </span></div><div class="line"><span class="regexp">        BankAmount+=Queuerear(Q1)-&gt;Amount;			//</span>更新资金总额  </div><div class="line">        EnQueue<span class="function"><span class="params">(Event,Queuefront(Q1)-&gt;Amount)</span>; 		//加入事件队列   </span></div><div class="line"><span class="function">        <span class="title">Queuerear</span><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=Queuefront<span class="function"><span class="params">(Q1)</span>-&gt;</span>num;  </div><div class="line">        <span class="regexp">//客户的离开时间为客户的到达时间加上随机产生的介于最大处理时间和最小处理时间的处理时间</span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;EndTime=(Queuefront(Q1)-&gt;BeginTime +rand()%(DealMaxTime-DealMinTime +1)+DealMinTime);  </span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;BeginTime=0;  </span></div><div class="line"><span class="regexp">        DealTime=Queuerear(Event)-&gt;EndTime;			//</span>交易时间为客户的离开时间  </div><div class="line">        counter++; 									<span class="regexp">//更新客户总数   </span></div><div class="line"><span class="regexp">        BankAmountTime+=(Queuerear(Event)-&gt;EndTime-Queuerear(Q1)-&gt;BeginTime); 	</span></div><div class="line"><span class="regexp">//</span>更新逗留时间  </div><div class="line">        DeQueue(Q1); 								<span class="regexp">//删除第一队列第一个业务  </span></div><div class="line"><span class="regexp">        state=0;										//</span>窗口没有交易需要处理  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="number">3.3</span>.<span class="number">9</span>检查队列Q2</div><div class="line"><span class="comment">/*顺序检查队列Q2中是否有可以处理的事件元素*/</span></div><div class="line">伪码表示：</div><div class="line">Begin </div><div class="line">sign&lt;-Q头结点</div><div class="line">CustNode *temp</div><div class="line">While Q头结点为空</div><div class="line">Begin</div><div class="line">IF -Q头结点的Amount&lt;m</div><div class="line">Begin</div><div class="line">IF Q为空</div><div class="line">Begin</div><div class="line">temp&lt;-Q头结点</div><div class="line">Q头结点&lt;-空</div><div class="line">Q尾结点&lt;-空</div><div class="line">Return temp</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">temp&lt;-Q头结点</div><div class="line">Q头结点&lt;-Q头结点的next域</div><div class="line">Return temp</div><div class="line">End</div><div class="line">End</div><div class="line">ELSE</div><div class="line">Begin</div><div class="line">IF Q不为空</div><div class="line">Begin</div><div class="line">Q尾结点的next域&lt;-Q头结点</div><div class="line">Q尾结点&lt;-Q尾结点的next域</div><div class="line">Q头结点&lt;-Q头结点的next域</div><div class="line">Q尾结点的next域&lt;-空</div><div class="line">End</div><div class="line">End</div><div class="line">IF Q头结点等于sign</div><div class="line">Return 空</div><div class="line">End</div><div class="line">Return 空</div><div class="line">End</div><div class="line">代码表示：</div><div class="line">CustNode *SearchQ2(Queue &amp;Q,int m)&#123;   </div><div class="line">    CustNode *sign=Q.front; 				<span class="regexp">//标记头节点  </span></div><div class="line"><span class="regexp">    CustNode *temp;  </span></div><div class="line"><span class="regexp">    while(Q.front!=NULL)&#123;  </span></div><div class="line"><span class="regexp">        if((-(Q.front-&gt;Amount))&lt;m)&#123;			//</span>队首元素可以处理  </div><div class="line">            <span class="keyword">if</span>(Q.front==Q.rear)&#123;  </div><div class="line">                temp=Q.front;  </div><div class="line">                Q.front=Q.rear=NULL;  </div><div class="line">                <span class="keyword">return</span> temp;  </div><div class="line">            &#125;  </div><div class="line">        	<span class="keyword">else</span>&#123;							<span class="regexp">//队首元素出列  </span></div><div class="line"><span class="regexp">            	temp=Q.front;   </span></div><div class="line"><span class="regexp">            	Q.front=Q.front-&gt;next; 		//</span> 首节点后移一位,返回原首节点  </div><div class="line">            	<span class="keyword">return</span> temp;  </div><div class="line">        	&#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span>&#123;								<span class="regexp">//队首元首不能被处理  </span></div><div class="line"><span class="regexp">            if(Q.front==Q.rear)&#123;</span></div><div class="line"><span class="regexp">			&#125;  </span></div><div class="line"><span class="regexp">            else&#123;							//</span>首节点移到队列尾部  </div><div class="line">              </div><div class="line">            	Q.rear-&gt;next=Q.front;   </div><div class="line">                Q.rear=Q.rear-&gt;next;  </div><div class="line">                Q.front=Q.front-&gt;next;  </div><div class="line">                Q.rear-&gt;next=NULL;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(Q.front==sign)					<span class="regexp">//队列循环一周时停止  </span></div><div class="line"><span class="regexp">            return NULL;  </span></div><div class="line"><span class="regexp">    &#125;  </span></div><div class="line"><span class="regexp">    return NULL;  </span></div><div class="line"><span class="regexp">&#125;  </span></div><div class="line"><span class="regexp">3.3.10处理队列Q2</span></div><div class="line"><span class="regexp">/*对于队列Q2中可以处理的事件元素进行处理*/</span></div><div class="line"><span class="regexp">伪码表示：</span></div><div class="line"><span class="regexp">Begin</span></div><div class="line"><span class="regexp">CustNode* temped  </span></div><div class="line"><span class="regexp">	int RandomTemp</span></div><div class="line"><span class="regexp">While temped&lt;-调用SearchQ2(Q2,BankAmount)并且temped不为空</span></div><div class="line"><span class="regexp">Begin</span></div><div class="line"><span class="regexp">BankAmount&lt;-temped的Amount+BankAmount</span></div><div class="line"><span class="regexp">EnQueue(Event,temped的Amount</span></div><div class="line"><span class="regexp">Event尾结点的Type&lt;-离开</span></div><div class="line"><span class="regexp">Event尾结点的num&lt;-temped的num</span></div><div class="line"><span class="regexp">RandomTemp&lt;-随机处理时间</span></div><div class="line"><span class="regexp">Event尾结点的EndTime&lt;-CurrentTime+RandomTemp</span></div><div class="line"><span class="regexp">DealTime&lt;-DealTime+RandomTemp</span></div><div class="line"><span class="regexp">counter&lt;-counter+1</span></div><div class="line"><span class="regexp">BankAmountTime&lt;-Event尾结点的EndTime-temped的BeginTime+BankAmount</span></div><div class="line"><span class="regexp">删除 temped</span></div><div class="line"><span class="regexp">temped&lt;-空</span></div><div class="line"><span class="regexp">End</span></div><div class="line"><span class="regexp">state&lt;-0</span></div><div class="line"><span class="regexp">End</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">代码表示：</span></div><div class="line"><span class="regexp">void DealQ2()&#123; </span></div><div class="line"><span class="regexp">   	CustNode* temped;  </span></div><div class="line"><span class="regexp">	int randomTemp;</span></div><div class="line"><span class="regexp">    while((temped=SearchQ2(Q2,BankAmount))&amp;&amp;temped!=NULL)&#123; 	//</span>查找可处理取款  </div><div class="line">      </div><div class="line">        BankAmount+=temped-&gt;Amount; 						<span class="regexp">//更新资金总额  </span></div><div class="line"><span class="regexp">        EnQueue(Event,temped-&gt;Amount); 						//</span>加入事件队列   </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>Type=<span class="string">"离开"</span>;  </div><div class="line">        Queuerear<span class="function"><span class="params">(Event)</span>-&gt;</span>num=temped-&gt;num;  </div><div class="line">        RandomTemp=rand()%(DealMaxTime-DealMinTime +<span class="number">1</span>)+DealMinTime;		</div><div class="line"><span class="regexp">//处理时间为随机产生的介于最大处理时间和最小处理时间之间的处理时间  </span></div><div class="line"><span class="regexp">        Queuerear(Event)-&gt;EndTime=CurrentTime+randomTemp ;					</span></div><div class="line"><span class="regexp">//</span>客户离开时间为当前时间加上处理时间  </div><div class="line">        DealTime+=randomTemp;								<span class="regexp">//更新交易时间  </span></div><div class="line"><span class="regexp">        counter++; 											//</span>更新客户总数  </div><div class="line">        BankAmountTime+=<span class="function"><span class="params">(Queuerear(Event)-&gt;EndTime-temped-&gt;BeginTime)</span>; 		</span></div><div class="line"><span class="function">//更新逗留时间   </span></div><div class="line"><span class="function">        <span class="title">delete</span> <span class="title">temped</span>; 										//删除节点  </span></div><div class="line"><span class="function">        <span class="title">temped</span> = <span class="title">NULL</span>;  </span></div><div class="line"><span class="function">    &#125;  </span></div><div class="line"><span class="function">    <span class="title">state</span> = 0;  </span></div><div class="line"><span class="function">&#125;  </span></div><div class="line"><span class="function">3.3.11银行业务模拟系统界面</span></div><div class="line"><span class="function">/*银行业务模拟程序的界面*/</span></div><div class="line"><span class="function">伪码表示：</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出   =========================================================================	  	换行	</span></div><div class="line"><span class="function">输出   =========================================================================		换行	</span></div><div class="line"><span class="function">输出                		<span class="title">Simulation</span> <span class="title">of</span> <span class="title">The</span> <span class="title">Bank</span> <span class="title">business</span>				</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出   				-------------------------------------------------------------------------	    	</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出  						   ---------------------------------                        	</span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出                  				<span class="title">Number</span>: 3116004979                               </span></div><div class="line"><span class="function">输出	              			     <span class="title">CLASS</span> ：16网络二班                          	</span></div><div class="line"><span class="function">输出                          		 <span class="title">NAME</span>  ： 詹泽霖                        	</span></div><div class="line"><span class="function">输出   =========================================================================		换行</span></div><div class="line"><span class="function">输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行  </span></div><div class="line"><span class="function">    	输出   *************************************************************************		换行  </span></div><div class="line"><span class="function">    	输出   *******************                               ***********************		换行</span></div><div class="line"><span class="function">	输出   *******************    0.退出   1.进入模拟系统    ***********************		</span></div><div class="line"><span class="function">换行   </span></div><div class="line"><span class="function">    	输出   *******************                               ***********************		换行 </span></div><div class="line"><span class="function"> 	输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行   </span></div><div class="line"><span class="function">    	输出  *************************************************************************	      </span></div><div class="line"><span class="function">换行  </span></div><div class="line"><span class="function">    	输出   ************************      请选择服务      ***************************		换行</span></div><div class="line"><span class="function">输出   =========================================================================		换行</span></div><div class="line"><span class="function">  <span class="title">End</span>  		</span></div><div class="line"><span class="function">代码表示：</span></div><div class="line"><span class="function"><span class="title">void</span> <span class="title">BankOutLook</span><span class="params">()</span>&#123;       </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================		\n"</span>)</span>;</span></div><div class="line"><span class="function"><span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================		\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"                       	Simulation of The Bank business							\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   			-------------------------------------------------------------------------	   				    \n\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                              ---------------------------------                        				\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                    	          Number: 3116004979                               			\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"                    	         CLASS ：16网络二班                               			\n"</span>)</span>;</span></div><div class="line"><span class="function">   	<span class="title">printf</span><span class="params">(<span class="string">"                    	          NAME  ：  詹泽霖                                      		\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"                              ---------------------------------                         				\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   =========================================================================      	\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************	      					\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *******************                               **************							\n"</span>)</span>;</span></div><div class="line"><span class="function">	<span class="title">printf</span><span class="params">(<span class="string">"   *******************    0.退出   1.进入模拟系统    ***************							\n"</span>)</span>;   </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *******************                               **************							\n"</span>)</span>; </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   *************************************************************************							\n"</span>)</span>;  </span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   ************************      请选择服务      *********************							\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">" =========================================================================        	\n"</span>)</span>;</span></div><div class="line"><span class="function">    	<span class="title">printf</span><span class="params">(<span class="string">"   请输入选择的操作对应编号："</span>)</span>; </span></div><div class="line"><span class="function">&#125;  </span></div><div class="line"><span class="function">3.4主程序</span></div><div class="line"><span class="function">通过对以上定义过的函数接口的调用，利用主函数来构建一个银行模拟系统，以列表的形式输出事件处理序列；</span></div><div class="line"><span class="function">并在列表输出完后输出需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</span></div><div class="line"><span class="function">3.4.1伪码表示</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">调整界面为黑字白背景</span></div><div class="line"><span class="function">调用<span class="title">BankOutLook</span><span class="params">()</span></span></div><div class="line"><span class="function">输入操作编号</span></div><div class="line"><span class="function"><span class="title">While</span> 操作编号等于1</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">初始化随机函数</span></div><div class="line"><span class="function">输出 请输入银行的初始存款</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行初始存款&lt;0</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，重新输入</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行初始存款&lt;0</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，重新输入</span></div><div class="line"><span class="function">输入 银行初始存款</span></div><div class="line"><span class="function"><span class="title">IF</span>银行初始存款&lt;0</span></div><div class="line"><span class="function">输出 三次输入错误，退出</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入银行的营业时间</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 银行营业时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 银行营业时间&lt;0或者&gt;1440</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大到达时间间隔</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大到达时间间隔&gt;银行营业时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小到达时间间隔</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小到达时间间隔</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小到达时间间隔&gt;最大到达时间间隔</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大交易时间</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易时间&gt;银行营业时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小交易时间</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最小交易时间</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最小交易时间&gt;最大交易时间</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出 请输入最大交易额</span></div><div class="line"><span class="function">输入 最大交易额</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最小交易时间</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function"><span class="title">Begin</span>	</span></div><div class="line"><span class="function">输出 输入错误，请重新输入</span></div><div class="line"><span class="function">输入 最大交易额</span></div><div class="line"><span class="function"><span class="title">IF</span> 最大交易额&gt;银行初始金额</span></div><div class="line"><span class="function">输出 三次输入错误，退出程序</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">MaxTime</span>&lt;-<span class="title">MaxTime</span>+随机到达间隔</span></div><div class="line"><span class="function"><span class="title">While</span> <span class="title">CurrentTime</span>&lt;<span class="title">CloseTime</span></span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function"><span class="title">CurrentTime</span>&lt;-<span class="title">CurrentTime</span>+1 </span></div><div class="line"><span class="function"><span class="title">If</span> <span class="title">DealTime</span>&lt;<span class="title">CurrentTime</span> </span></div><div class="line"><span class="function">	<span class="title">DealTime</span>&lt;-<span class="title">CurrentTime</span>   </span></div><div class="line"><span class="function"><span class="title">If</span> <span class="title">DealTime</span>等于<span class="title">CurrentTime</span> 						</span></div><div class="line"><span class="function">	<span class="title">State</span>&lt;-1</span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">CurrentTime</span>等于<span class="title">MaxTime</span>)							</span></div><div class="line"><span class="function"><span class="title">Begin</span></span></div><div class="line"><span class="function">        调用<span class="title">ClientArrive</span><span class="params">()</span> 			</span></div><div class="line"><span class="function"><span class="title">MaxTime</span>&lt;-<span class="title">MaxTime</span>+随机到达间隔+<span class="title">ClientArriveMinTime</span>  </span></div><div class="line"><span class="function"><span class="title">End</span>  </span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">state</span>等于1&amp;&amp;<span class="title">Q1</span>头指针不等于<span class="title">NULL</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">    <span class="title">IF</span> <span class="title">Q1</span>头结点的<span class="title">Amount</span>大于等于 0</span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">        调用<span class="title">InAmount</span><span class="params">()</span>						 </span></div><div class="line"><span class="function">        调用<span class="title">DealQ2</span><span class="params">()</span>							</span></div><div class="line"><span class="function">        <span class="title">NeedIn</span>&lt;-<span class="title">NeedIn</span>+1  </span></div><div class="line"><span class="function">    <span class="title">End</span></span></div><div class="line"><span class="function">    <span class="title">ElSe</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>               </span></div><div class="line"><span class="function">调用<span class="title">InAmount</span><span class="params">()</span>					</span></div><div class="line"><span class="function"> 	<span class="title">NeedIn</span>&lt;-<span class="title">NeedIn</span>+1  </span></div><div class="line"><span class="function">   	<span class="title">End</span>  </span></div><div class="line"><span class="function"><span class="title">End</span>   </span></div><div class="line"><span class="function"><span class="title">End</span> </span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function">输出     客户序列	换列	事件类型	换列	处理金额	换行</span></div><div class="line"><span class="function"><span class="title">While</span> <span class="title">Event</span>头结点不为空</span></div><div class="line"><span class="function"><span class="title">Begin</span> 					            </span></div><div class="line"><span class="function"><span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Type</span>等于 "离开"</span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">         输出 换列	<span class="title">Event</span>头结点的<span class="title">num</span>	换列	离开	<span class="title">Event</span>头结点的<span class="title">EndTime</span>		换列	<span class="title">Event</span>头结点的<span class="title">Amount</span> 	换行 </span></div><div class="line"><span class="function">          <span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Amount</span>大于等于0     			</span></div><div class="line"><span class="function">				<span class="title">t1</span>&lt;-<span class="title">t1</span>+1			  </span></div><div class="line"><span class="function">          <span class="title">Else</span>                     	</span></div><div class="line"><span class="function">				<span class="title">t3</span>&lt;-<span class="title">t3</span>+1				  </span></div><div class="line"><span class="function">    <span class="title">End</span>  </span></div><div class="line"><span class="function">    <span class="title">Else</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>  </span></div><div class="line"><span class="function">    	输出 换列	<span class="title">Event</span>头结点的<span class="title">num</span>	换列	到达	<span class="title">Event</span>头结点的<span class="title">EndTime</span>		换列	<span class="title">Event</span>头结点的<span class="title">Amount</span> 	换行 </span></div><div class="line"><span class="function">        <span class="title">IF</span> <span class="title">Event</span>头结点的<span class="title">Amount</span>大于等于0     			</span></div><div class="line"><span class="function">			<span class="title">t2</span>&lt;-<span class="title">t2</span>+1			  </span></div><div class="line"><span class="function">        <span class="title">Else</span>                     	</span></div><div class="line"><span class="function">			<span class="title">t4</span>&lt;-<span class="title">t4</span>+1	</span></div><div class="line"><span class="function">            <span class="title">SuccessIn</span>&lt;-<span class="title">NeedIn</span>-<span class="params">(t2-t1)</span> </span></div><div class="line"><span class="function">            <span class="title">SuccessOut</span>&lt;-<span class="title">NeedOut</span>-<span class="params">(t4-t3)</span>  </span></div><div class="line"><span class="function">            调用<span class="title">DeQueue</span><span class="params">(Event)</span></span></div><div class="line"><span class="function">    <span class="title">End</span> </span></div><div class="line"><span class="function">        <span class="title">While</span> <span class="title">Q1</span>的头结点等于<span class="title">NULL</span></span></div><div class="line"><span class="function"><span class="title">Begin</span>								            				<span class="title">BankAmountTime</span>&lt;-<span class="title">BankAmountTime</span>+<span class="params">(CloseTime-Q1头结点的BeginTime)</span>  </span></div><div class="line"><span class="function">            <span class="title">counter</span>&lt;-<span class="title">counter</span>+1;  </span></div><div class="line"><span class="function">            调用<span class="title">DeQueue</span><span class="params">(Q1)</span>;  </span></div><div class="line"><span class="function">        <span class="title">End</span></span></div><div class="line"><span class="function">换行</span></div><div class="line"><span class="function">输出 需要存款的客户人数</span></div><div class="line"><span class="function">输出 需要取款的客户人数</span></div><div class="line"><span class="function">输出 成功办理存款的客户人数</span></div><div class="line"><span class="function">输出 成功办理取款的客户人数</span></div><div class="line"><span class="function">输出 存款成功办理率</span></div><div class="line"><span class="function">输出 取款成功办理率</span></div><div class="line"><span class="function">输出 客户进入系统平均时间</span></div><div class="line"><span class="function">输出 银行当前余额</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function"><span class="title">If</span> 操作数等于0</span></div><div class="line"><span class="function">退出模拟系统</span></div><div class="line"><span class="function"><span class="title">Return</span> 0</span></div><div class="line"><span class="function"><span class="title">End</span></span></div><div class="line"><span class="function">3.4.2代码表示</span></div><div class="line"><span class="function"><span class="title">int</span> <span class="title">main</span><span class="params">()</span>&#123; </span></div><div class="line"><span class="function">	<span class="title">system</span><span class="params">(<span class="string">"color 70"</span>)</span>;</span></div><div class="line"><span class="function">    <span class="title">BankOutLook</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">    <span class="title">int</span> <span class="title">n</span>,<span class="title">t1</span>=0,<span class="title">t2</span>=0,<span class="title">t3</span>=0,<span class="title">t4</span>=0,<span class="title">m</span>=0;</span></div><div class="line"><span class="function">    <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;n)</span>;  </span></div><div class="line"><span class="function">    <span class="title">while</span><span class="params">(n==<span class="number">1</span>)</span>&#123;  </span></div><div class="line"><span class="function">        <span class="title">srand</span><span class="params">(time(NULL))</span>; 							//初始化随机函数  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123;                          </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！初始存款不能小于0！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123;       </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！初始存款不能小于0！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的初始存款："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;BankAmount)</span>;   </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(BankAmount&lt;<span class="number">0</span>)</span>&#123; </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;   </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;                 </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！一天的营业时间不能超过1440分钟（24个小时）！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！一天的营业时间不能超过1440分钟（24个小时）！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入银行的营业时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;CloseTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(CloseTime&gt;=<span class="number">1440</span>)</span>&#123;   </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;    </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125; </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;         </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大到达时间间隔必须小于营业时间！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大到达时间间隔必须小于营业时间！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMaxTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(ClientArriveMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;   </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123;       </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小到达时间间隔必须介于零和最大到达时间之间！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小到达时间间隔必须介于零和最大到达时间之间！请最后一次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小到达时间间隔："</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;ClientArriveMinTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(ClientArriveMinTime&lt;=<span class="number">0</span>||ClientArriveMinTime&gt;=ClientArriveMaxTime)</span>&#123; </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   请按任意键退出!\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;   </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;   </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;           </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大处理时间必须小于营业时间！请再次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">               	<span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最大处理时间必须小于营业时间！请最后一次输入！\n"</span>)</span>;   </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最大的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMaxTime)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(DealMaxTime&gt;CloseTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;     </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span>||DealMinTime&gt;=DealMaxTime)</span>&#123;</span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小处理时间必须介于零和最大处理时间之间！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span>||DealMinTime&gt;=DealMaxTime)</span>&#123;      </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！最小处理时间必须介于零和最大处理时间之间！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入最小的处理时间："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;DealMinTime)</span>;     </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(DealMinTime&lt;=<span class="number">0</span> || DealMinTime&gt;=DealMaxTime)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;   </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">        <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！超出本银行的服务范围！最大交易额应低于银行开始营业时的资金总额且小于50000！请再次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">            <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   输入错误！超出本银行的服务范围！最大交易额应低于银行开始营业时的资金总额且小于50000！请最后一次输入！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"   请输入交易额的最大上限："</span>)</span>;  </span></div><div class="line"><span class="function">                <span class="title">scanf</span><span class="params">(<span class="string">"%d"</span>,&amp;MaxAmount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(MaxAmount&gt;=BankAmount||MaxAmount&gt;<span class="number">50000</span>)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">printf</span><span class="params">(<span class="string">"   三次输入都错误！请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">                    <span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                    <span class="title">goto</span> <span class="title">end</span>;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125; </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">MaxTime</span> +=<span class="title">rand</span><span class="params">()</span>%<span class="params">(ClientArriveMaxTime-ClientArriveMinTime+<span class="number">1</span>)</span>+<span class="title">ClientArriveMinTime</span>; </span></div><div class="line"><span class="function">		//随机生成介于最大到达时间间隔和最小到达时间间隔之间的首次到达时间  </span></div><div class="line"><span class="function">          </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(CurrentTime&lt;CloseTime)</span>&#123;					//当前时间小于营业时间  </span></div><div class="line"><span class="function">            <span class="title">CurrentTime</span>++;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealTime&lt;CurrentTime)</span> </span></div><div class="line"><span class="function">				<span class="title">DealTime</span>=<span class="title">CurrentTime</span> ;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(DealTime==CurrentTime)</span> 					//有窗口在处理交易</span></div><div class="line"><span class="function">				<span class="title">state</span>=1;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(CurrentTime==MaxTime)</span>&#123; 					//到达事件  </span></div><div class="line"><span class="function">                <span class="title">ClientArrive</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">                //随机生成介于最大到达时间间隔和最小到达时间间隔之间的到达时间</span></div><div class="line"><span class="function">                <span class="title">MaxTime</span>+=<span class="title">rand</span><span class="params">()</span>%<span class="params">(ClientArriveMaxTime-ClientArriveMinTime+<span class="number">1</span>)</span>+<span class="title">ClientArriveMinTime</span>;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(state==<span class="number">1</span>&amp;&amp;Q1.front!=NULL)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Q1.front-&gt;Amount&gt;= <span class="number">0</span>)</span>&#123;  </span></div><div class="line"><span class="function">                    <span class="title">InAmount</span><span class="params">()</span>;						//调用存款函数  </span></div><div class="line"><span class="function">                    <span class="title">DealQ2</span><span class="params">()</span>;							//调用搜索处理函数  </span></div><div class="line"><span class="function">                    <span class="title">NeedIn</span>++;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">                <span class="title">else</span>&#123;   </span></div><div class="line"><span class="function">                    <span class="title">InAmount</span><span class="params">()</span>;						//调用取款函数  </span></div><div class="line"><span class="function">                    <span class="title">NeedOut</span>++;  </span></div><div class="line"><span class="function">                &#125;  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"     客户序列\t      事件类型         时间          处理金额\n"</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(Event.front!=NULL)</span>&#123; 						//清除事件队列  </span></div><div class="line"><span class="function">            <span class="title">if</span><span class="params">(Event.front-&gt;Type==<span class="string">"离开"</span>)</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"\t%d\t\t离开\t\t%d\t\t%d\n"</span>,Event.front-&gt;num, Event.front-&gt;EndTime,Event.front-&gt;Amount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Event.front-&gt;Amount&gt;=<span class="number">0</span>)</span>     			//成功存款人数</span></div><div class="line"><span class="function">					<span class="title">t1</span>++;			  </span></div><div class="line"><span class="function">                <span class="title">else</span>                     			//成功取款人数</span></div><div class="line"><span class="function">					<span class="title">t3</span>++;				  </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">else</span>&#123;  </span></div><div class="line"><span class="function">                <span class="title">printf</span><span class="params">(<span class="string">"\t%d\t\t到达\t\t%d\t\t%d\n"</span>,Event.front-&gt;num, Event.front-&gt;BeginTime,Event.front-&gt;Amount)</span>;  </span></div><div class="line"><span class="function">                <span class="title">if</span><span class="params">(Event.front-&gt;Amount&gt;=<span class="number">0</span>)</span>     			//需要存款人数</span></div><div class="line"><span class="function">					<span class="title">t2</span>++;			  </span></div><div class="line"><span class="function">                <span class="title">else</span>                     			//需要取款人数 </span></div><div class="line"><span class="function">					<span class="title">t4</span>++;				 </span></div><div class="line"><span class="function">            &#125;  </span></div><div class="line"><span class="function">            <span class="title">SuccessIn</span>=<span class="title">NeedIn</span>-<span class="params">(t2-t1)</span>;  </span></div><div class="line"><span class="function">            <span class="title">SuccessOut</span>=<span class="title">NeedOut</span>-<span class="params">(t4-t3)</span>;  </span></div><div class="line"><span class="function">            <span class="title">DeQueue</span><span class="params">(Event)</span>;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">while</span><span class="params">(Q1.front!=NULL)</span>&#123;					</span></div><div class="line"><span class="function">//更新结束时第一队列中未处理的客户  </span></div><div class="line"><span class="function">            <span class="title">BankAmountTime</span>+=<span class="params">(CloseTime-Q1.front-&gt;BeginTime)</span>;   </span></div><div class="line"><span class="function">            <span class="title">counter</span>++;  </span></div><div class="line"><span class="function">            <span class="title">DeQueue</span><span class="params">(Q1)</span>;  </span></div><div class="line"><span class="function">        &#125;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"\n"</span>)</span>;   </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	需要存款的客户人数：%d\n"</span>,NeedIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	需要取款的客户人数：%d\n"</span>,NeedOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	成功办理存款的客户人数：%d\n"</span>,SuccessIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	成功办理取款的客户人数：%d\n"</span>,SuccessOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	存款成功办理率：%f\n"</span>,float(SuccessIn*<span class="number">100</span>)/NeedIn)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	取款成功办理率：%f\n"</span>,float(SuccessOut*<span class="number">100</span>)/NeedOut)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	客户逗留平均时间为:%f\n"</span>,float(BankAmountTime)/counter)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	银行当前余额：%d\n"</span>,BankAmount)</span>;  </span></div><div class="line"><span class="function">        <span class="title">printf</span><span class="params">(<span class="string">"	请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">        <span class="title">break</span>;  </span></div><div class="line"><span class="function">	&#125;  </span></div><div class="line"><span class="function">	<span class="title">if</span><span class="params">(n==<span class="number">0</span>)</span>   </span></div><div class="line"><span class="function">		<span class="title">printf</span><span class="params">(<span class="string">"请按任意键退出！\n"</span>)</span>;  </span></div><div class="line"><span class="function">	<span class="title">end</span>:<span class="title">getch</span><span class="params">()</span>;  </span></div><div class="line"><span class="function">    <span class="title">return</span> 0;  </span></div><div class="line"><span class="function">&#125;</span></div></pre></td></tr></table></figure>
<p>3.5函数调用关系及程序流程<br>以下为程序的大致流程图：<br><img src="http://img.blog.csdn.net/20180114155604536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>函数调用关系图如下：<br><img src="http://img.blog.csdn.net/20180114155723213?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4.调试分析<br>4.1调试中遇到的问题<br>调试中遇到的问题不是很多，但遇到的问题在一定程度上让我更加的了解整个程序的运作机理，对于理解数据结构也有很大的帮助。<br>主要的问题在于一开始的时候实现检查Q2队列的接口时，在进行检查后，未再让经过检查却不满足处理的元素重新进入Q2队列，导致最后的元素缺少。经过调试发现了这个问题，对代码进行修正，最终解决了问题。<br>4.2算法分析<br><img src="http://img.blog.csdn.net/20180114155950287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>4.3经验体会<br>通过这次的课程设计的编写，学会了在多种数据结构之间进行巧妙的结合运用。同时，对于用到的多种数据结构也有了更多的了解。<br>在测试功能的时候一定要注意选取的测试数据的正确性和实用性。<br>5.用户使用说明<br>在进入银行业务模拟界面时，选择操作编号，0-退出系统，1-进入模拟系统.<br>进入模拟系统后，输入的银行初始存款必须大于0；<br>输入的银行营业时间必须大于0且必须小于1440（一天）；<br>输入的最大到达时间间隔必须大于0且必须小于银行营业时间；<br>输入的最小到达时间间隔必须大于0且必须小于最大到达时间间隔；<br>输入的最大处理时间必须大于0且必须小于银行营业时间；<br>输入的最小处理时间必须大于0且必须小于最大处理时间；<br>输入的交易额的最大上线必须大于0且必须小于银行初始存款且必须小于50000；<br>若输入有误会进行提示，三次错误后退出模拟系统。若输入无误，则开始进行输出，输出事件处理的列表信息，以及需要存款的客户人数，需要取款的客户人数，成功办理存款的客户人数，成功办理取款的客户人数，存款成功办理率，取款成功办理率，客户逗留平均时间，银行当前余额等信息。</p>
<p>6.测试结果<br>6.1输出测试1<br>输入较大的银行初始存款，输入较大的到达时间间隔和较大的处理时间，较小的交易额上限<br><img src="http://img.blog.csdn.net/20180114160021122?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由于到达时间间隔和处理时间输入较大，测试数据会比较少，相对于来说，求得的银行业务模拟的客户平均用时等信息可能就没有那么的精确<br><img src="http://img.blog.csdn.net/20180114160101587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>6.2输出测试2</p>
<p>输入较大的银行初始存款，输入较小的到达时间间隔范围，较小的交易额上限<br><img src="http://img.blog.csdn.net/20180114160117632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在较小的到达时间间隔和处理时间的输入下，会得到比前一种情况更多的测试数据输出，在此情况下，样本的容量足够大，对于客户平均用时等信息的统计就可能会更加的精确一些</p>
<p><img src="http://img.blog.csdn.net/20180114160156400?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114160211784?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20180114160245673?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>6.3输出测试3<br>输入较小的银行初始存款，较大的处理时间和较大的时间间隔，较大的交易金额上限。<br><img src="http://img.blog.csdn.net/20180114160340916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>在这样的输出下，对于客户平均用时的影响比较大，且只能产生少量的数据。<br><img src="http://img.blog.csdn.net/20180114160354039?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>7.参考文献</p>
<p>参考文献<br>[1]    张小艳，龚尚福编著. 数据结构与算法. 徐州：中国矿业大学出版社，2007<br>[2]    严蔚敏，吴伟民编著. 数据结构(C语言版). 北京： 清华大学出版社，1997<br>[3]    谭浩强编著.  C程序设计(第三版). 北京： 清华大学出版社，2005</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[组合逻辑电路]]></title>
      <url>/2018/01/05/%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>组合电路是由各种逻辑门构成的</p>
<p>组合逻辑电路逻辑功能的表示方法：<br>1.逻辑表达式<br>2.真值表<br>3.卡诺图<br>4.逻辑图</p>
<hr>
<p>组合逻辑电路的分析方法：<br>1.根据给定的逻辑电路，写出输出函数的逻辑表达式<br>2.进行表达式的变换与化简，直接利用公式或定理对表达式进行变换，也可通过卡诺图的方法进行化简<br>3.根据表达式列出真值表。真值表能直接反映出输入变量和输出结果之间的逻辑关系，它直观地描述了电路的逻辑功能<br>4.对给定电路的功能进行逻辑描述。根据所得到的表达式和真值表，用文字输出给定电路的逻辑功能，判断功能是否满足设计要求。</p>
<hr>
<p><strong>常用的组合逻辑电路</strong><br>1.二进制普通编码器<br>用n位二进制代码对m=2的n次方个信号进行编码的电路称为二进制编码器。<br>2.BCD普通编码器<br>功能是将十进制数0~9转换为二进制代码<br>3.优先编码器<br>与普通编码器一样，外加优先级设定。<br>4.编码器集成电路<br>74HC148是8-3优先编码器<br>有8个信号输入端，3个编码输出端，还有使能输入端EIN，使能输出端EON，优先级标志输出端GSN。<br>功能：<br>1.EIN为使能输入端，低电平有效。当EIN输入高电平（H信号）时，编码器不工作，所有输出端均输出高电平（H信号）<br>。当EIN输入低电平时，编码器工作。<br>2.编码器工作时，I7优先级最高，I0优先级最低.<br>3.如果编码器工作，输入端均有效，则EON输出高电平,否则输出低电平。<br>4..GSN用于表示是否有编码输出</p>
<hr>
<p><strong>译码器</strong><br>译码是编码的逆过程</p>
<p>1.二进制译码器<br>2.数码显示译码器<br>八字形最上面为a，顺时针分别为bcdef，中间为g</p>
<p>3.译码器集成电路<br>74HC138<br>1.当使能输入端EIN,E2N=0,E3=1，译码器不工作。<br>2.其余情况正常译码</p>
<p>4.集成数码显示译码器<br>74HC4511<br>当使能输入端为LHH时工作，对应输出字形对应的a~g</p>
<hr>
<p><strong>数据选择器</strong><br>4-1数据选择器-74HC153<br>1.输入使能EN=0，选择器工作，否则不工作<br>2.I0-I3数据输入，S0-S1选择输入</p>
<hr>
<p><strong>数值比较器</strong><br>1.4位数值比较器-74HC85<br>当能判断大小时，直接就大小比较进行输出；<br>否则，由级联输入决定输出。</p>
<hr>
<p><strong>加法器</strong><br>1.串行进位加法器<br>2.超前进位加法器<br>3.有符号二进制数加法器<br>有符号加法器利用补码进行运算，符号相异时运算结果正确，符号相同时考虑是否溢出</p>
<hr>
<p>竞争冒险是指当输入信号发生变化后，在输出达到稳定之前，输出端可能出现异常的虚假信号，称为竞争冒险</p>
<p>卡诺图中的圈不相切，则不会有竞争冒险</p>
<p>解决方案：<br>1.选通法<br>2.滤波法<br>3.增加冗余项法</p>
<hr>
]]></content>
      
        <categories>
            
            <category> eda </category>
            
        </categories>
        
        
        <tags>
            
            <tag> eda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数字逻辑基础]]></title>
      <url>/2018/01/05/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<p>-基本知识<br><a id="more"></a><br><strong>十六进制数</strong><br>十六进制数的特点是：<br>1.由16个数码，0~9和A~F组成<br>2.基数是16，运算规则是逢16进1<br>3.在小数点左边，从右至左的位权依次是：$16^0$,$16^1$,$16^2$……在小数点右边，从左至右的位权依次是：$16^{-1}$,$16^{-2}$,$16^{-3}$,……;</p>
<p><strong>数制转换</strong><br><strong>1.非十进制数转换成十进制数</strong><br>转换方法是：将非十进制数按维权展开后求和<br>(1011.101)<sub>2</sub>=1<em>$2^3$+0</em>$2^2$+1<em>$2^1$+1</em>$2^0$+1<em>$2^{-1}$+0</em>$2^{-2}$+1*$2^{-3}$=11.625</p>
<p>(723.24)<sub>8</sub>=7<em>$8^2$+2</em>$8^1$+3<em>$8^0$+2</em>$8^{-1}$+4*$8^{-2}$=467.3125</p>
<p>(2D9.A8)<sub>16</sub>=2<em>$16^2$+13</em>$16^1$+9<em>$16^0$+10</em>$16^{-1}$+8*$16^{-2}$=729.65625</p>
<p><strong>2.十进制树转换成非十进制数</strong><br>十进制数转换成非十进制数，需要分别对整数部分和小数部分进行转换<br>①整数部分转换方法：不断除以技术取余数直到商为0，从下至上读取余数<br>②小数部分转换方法：不断乘以基数取余数，从上到下读取整数，直到满足精度要求为止<br>(179)<sub>10</sub>=(10110011)<sub>2</sub>=(263)<sub>8</sub>=(B3)<sub>16</sub><br>(0.6875)<sub>10</sub>=(0.1011)<sub>2</sub>=(0.54)<sub>8</sub>=(0.B)<sub>16</sub></p>
<p><strong>码制</strong><br><strong>1.原码</strong><br>将数的真值形式整数符号用0表示，负数符号用符号位1表示，叫做数的原码形式。<br><strong>2.反码</strong><br>对于正数，反码与原码相同<br>对于负数，保留原码符号位，其他位取反<br><strong>3.补码</strong><br>对于正数，补码与原码相同<br>对于负数，补码为反码+1</p>
]]></content>
      
        <categories>
            
            <category> eda </category>
            
        </categories>
        
        
        <tags>
            
            <tag> eda </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B树完整实现]]></title>
      <url>/2017/12/25/B%E6%A0%91%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0-C%E8%AF%AD%E8%A8%80/</url>
      <content type="html"><![CDATA[<p>-B树完整接口实现<br><a id="more"></a><br> <strong>B树的定义</strong><br>B树是一种平衡的多路查找树。<br>一颗m阶B树，或为空树，或为满足下列特性的m叉树。<br>（1）树中每个结点最多含有m棵子树;<br>（2）若根结点不是叶子结点，则至少有两颗子树;<br>（3）除根之外的所有非终端结点至少有[m/2];<br>（4）每个非终端结点中包含信息：（n,A0,K1,A1,K2,A2,…,Kn,An)。其中<br>①Ki（1≤i≤n）为关键字，且关键字按升序排序。<br>②指针Ai（0≤i≤n）指向子树的根结点。<br>③关键字的个数n必须满足：[m/2]-1≤n≤m-1<br>（5）所有的叶子结点都出现在同一层次上，并且不带信息（可以看作是外部节点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）</p>
<p><strong>编程环境与配置</strong><br>IDE：Dev-C++ 5.11<br>编程语言：C</p>
<p><strong>程序结构图</strong><br><img src="http://img.blog.csdn.net/20171225173432967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><strong>B树的抽象数据类型定义</strong></p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">ADT BTree&#123;</div><div class="line">数据对象：D是具有相同特性的数据元素的集合</div><div class="line">数据关系：<span class="symbol">R1</span>=&#123;&lt;ai-<span class="number">1</span>,ai&gt;|ai-<span class="number">1</span>,ai∈D，i=<span class="number">2</span>，...,<span class="built_in">n</span>&#125;</div><div class="line">     		  <span class="symbol">R2</span>=&#123;&lt;ptr[i-<span class="number">1</span>],ptr[i]&gt;|i=<span class="number">1</span>...,<span class="built_in">n</span>&#125;</div><div class="line">  约定<span class="symbol">a1</span>|key[<span class="number">1</span>]为关键字数组头，an|key[p-&lt;keynum]为关键字数组尾</div><div class="line">  约定ptr[i]为结点的第i个子树</div><div class="line">基本操作：</div><div class="line">InitBTree(<span class="built_in">t</span>)</div><div class="line">初始条件：B树已定义</div><div class="line">操作结果：初始化B树</div><div class="line">SearchBTNode(BTNode *p,KeyType k)</div><div class="line">初始条件：结点p已存在</div><div class="line">操作结果：在结点p中查找关键字k的插入位置i </div><div class="line">Result SearchBTree(BTree <span class="built_in">t</span>,KeyType k)</div><div class="line">初始条件：B树已存在</div><div class="line">操作结果：在B树查找关键字k的插入位置，返回查找结果</div><div class="line">InsertBTNode(BTNode *&amp;p,<span class="built_in">int</span> i,KeyType k,BTNode *q)</div><div class="line">初始条件：结点p和结点q已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：将关键字k和结点q分别插入到p-&gt;key[i+<span class="number">1</span>]和p-&gt;ptr[i+<span class="number">1</span>]中</div><div class="line">SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)</div><div class="line">初始条件：结点p和结点q已存在</div><div class="line">操作结果：将结点p分裂成两个结点,前一半保留,后一半移入结点q</div><div class="line">NewRoot(BTNode *&amp;<span class="built_in">t</span>,KeyType k,BTNode *p,BTNode *q)</div><div class="line">初始条件：结点<span class="built_in">t</span>,p,q已存在</div><div class="line">操作结果：生成新的根结点<span class="built_in">t</span>,原p和q为子树指针</div><div class="line">InsertBTree(BTree &amp;<span class="built_in">t</span>,<span class="built_in">int</span> i,KeyType k,BTNode *p)</div><div class="line">初始条件：结点p和结点<span class="built_in">t</span>已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：在B树<span class="built_in">t</span>中插入关键字k</div><div class="line">Remove(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：p结点删除key[i]和它的孩子指针ptr[i]</div><div class="line">Substitution(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：查找替代值</div><div class="line">MoveRight(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整右移操作</div><div class="line">MoveLeft(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整左移操作</div><div class="line">Combine(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：结点调整合并操作</div><div class="line">AdjustBTree(BTNode *p,<span class="built_in">int</span> i)</div><div class="line">初始条件：结点p已存在，<span class="number">0</span>&lt;i&lt;p-&gt;keynum</div><div class="line">操作结果：B树调整操作</div><div class="line">BTNodeDelete(BTNode *p,KeyType k)</div><div class="line">初始条件：结点p已存在</div><div class="line">操作结果：在结点p中删除关键字k</div><div class="line">BTreeDelete(BTree &amp;<span class="built_in">t</span>,KeyType k)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：在B树<span class="built_in">t</span>中删除关键字k</div><div class="line">DestroyBTree(BTree &amp;<span class="built_in">t</span>)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：递归释放B树</div><div class="line">PrintBTree(BTree <span class="built_in">t</span>)</div><div class="line">初始条件：B树<span class="built_in">t</span>已存在</div><div class="line">操作结果：遍历打印B树</div><div class="line">&#125;ADT BTree</div></pre></td></tr></table></figure>
<p><strong>头文件</strong><br>定义了需要用到的数据类型，结构体类型，以及所有函数接口;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//==========ADT BTree的表示与实现==========</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10              	<span class="comment">//定义B树的最大的阶数</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">4</span>;               		<span class="comment">//设定B树的阶数 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=m<span class="number">-1</span>;           		<span class="comment">//结点的最大关键字数量 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=(m<span class="number">-1</span>)/<span class="number">2</span>;				<span class="comment">//结点的最小关键字数量 </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;       	 		<span class="comment">//KeyType为关键字类型</span></div><div class="line"></div><div class="line"><span class="comment">//===============B树存储结构==============</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>         		<span class="comment">//B树和B树结点类型 </span></div><div class="line">	<span class="keyword">int</span> keynum;    		        <span class="comment">//结点关键字个数</span></div><div class="line">	KeyType key[MAXM];          	<span class="comment">//关键字数组，key[0]不使用 </span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span>        	<span class="comment">//双亲结点指针</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ptr</span>[<span class="title">MAXM</span>];</span>     	<span class="comment">//孩子结点指针数组 </span></div><div class="line">&#125;BTNode,*BTree;</div><div class="line">   </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              		<span class="comment">//B树查找结果类型 </span></div><div class="line">	BTNode *pt;              	<span class="comment">//指向找到的结点</span></div><div class="line">	<span class="keyword">int</span> i;                   		<span class="comment">//在结点中的关键字位置; </span></div><div class="line">	<span class="keyword">int</span> tag;                 		<span class="comment">//查找成功与否标志</span></div><div class="line">&#125;Result;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>               <span class="comment">//链表和链表结点类型 </span></div><div class="line">  	BTree data;     				<span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>     		<span class="comment">//指针域</span></div><div class="line">&#125;LNode, *LinkList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> status&#123;               <span class="comment">//枚举类型（依次递增） </span></div><div class="line">    TRUE,</div><div class="line">    FALSE,</div><div class="line">    OK,</div><div class="line">    ERROR,</div><div class="line">    OVERFLOW,</div><div class="line">  	EMPTY</div><div class="line">&#125;Status;</div><div class="line"></div><div class="line"><span class="comment">//============基本操作的函数原型声明=============</span></div><div class="line"><span class="function">Status <span class="title">InitBTree</span><span class="params">(BTree &amp;t)</span></span>;</div><div class="line"><span class="comment">//初始化B树 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBTNode</span><span class="params">(BTNode *p,KeyType k)</span></span>;                  		</div><div class="line"><span class="comment">//在结点p中查找关键字k的插入位置i</span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree t,KeyType k)</span></span>;               			</div><div class="line"><span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTNode</span><span class="params">(BTNode *&amp;p,<span class="keyword">int</span> i,KeyType k,BTNode *q)</span></span>; 		</div><div class="line"><span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitBTNode</span><span class="params">(BTNode *&amp;p,BTNode *&amp;q)</span></span>;						</div><div class="line"><span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewRoot</span><span class="params">(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)</span></span>;			</div><div class="line"><span class="comment">//生成新的根结点t,原结点p和结点q为子树指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTree</span><span class="params">(BTree &amp;t,<span class="keyword">int</span> i,KeyType k,BTNode *p)</span></span>;			</div><div class="line"><span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>; 									</div><div class="line"><span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Substitution</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;      						</div><div class="line"><span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                               </div><div class="line"><span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">将左结点aq中的最后一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveLeft</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;</div><div class="line"><span class="comment">/*将双亲结点p中的第一个关键字移入结点aq中，</span></div><div class="line"><span class="comment">将结点q中的第一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                  </div><div class="line"><span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">并调整双亲结点p中的剩余关键字的位置*/</span>										 </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustBTree</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                              </div><div class="line"><span class="comment">//删除结点p中的第i个关键字后,调整B树										 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindBTNode</span><span class="params">(BTNode *p,KeyType k,<span class="keyword">int</span> &amp;i)</span></span>;                     </div><div class="line"><span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDelete</span><span class="params">(BTNode *p,KeyType k)</span></span>;                          </div><div class="line"><span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeDelete</span><span class="params">(BTree &amp;t,KeyType k)</span></span>;                          	</div><div class="line"><span class="comment">//构建删除框架，执行删除操作 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBTree</span><span class="params">(BTree &amp;t)</span></span>;                                    </div><div class="line"><span class="comment">//递归释放B树</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkList &amp;L)</span></span>;                                  </div><div class="line"><span class="comment">//初始化队列 </span></div><div class="line"><span class="function">LNode* <span class="title">CreateNode</span><span class="params">(BTree t)</span></span>;                               		</div><div class="line"><span class="comment">//新建一个结点 </span></div><div class="line"><span class="function">Status <span class="title">Enqueue</span><span class="params">(LNode *p,BTree t)</span></span>;								</div><div class="line"><span class="comment">//元素q入队列</span></div><div class="line"><span class="function">Status <span class="title">Dequeue</span><span class="params">(LNode *p,BTNode *&amp;q)</span></span>;                            </div><div class="line"><span class="comment">//出队列，并以q返回值</span></div><div class="line"><span class="function">Status <span class="title">IfEmpty</span><span class="params">(LinkList L)</span></span>;                       				</div><div class="line"><span class="comment">//队列判空 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkList L)</span></span>;    								</div><div class="line"><span class="comment">//销毁队列 </span></div><div class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(BTree t,LinkList L,<span class="keyword">int</span> newline,<span class="keyword">int</span> sum)</span></span>;		</div><div class="line"><span class="comment">//用队列遍历输出B树 </span></div><div class="line"><span class="function">Status <span class="title">PrintBTree</span><span class="params">(BTree t)</span></span>;                                     </div><div class="line"><span class="comment">//输出B树 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>;                  									</div><div class="line"><span class="comment">//测试B树功能函数 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><strong>B树具体接口实现</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div></pre></td><td class="code"><pre><div class="line"><span class="number">2.4</span>.<span class="number">1</span>InitBTree函数</div><div class="line">功能:初始化B树</div><div class="line">代码实现:</div><div class="line">Status InitBTree(BTree &amp;t)&#123;</div><div class="line">    t=NULL;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">2</span>SearchBTNode函数</div><div class="line">功能：在结点p中查找关键字k的插入位置i</div><div class="line">代码实现：</div><div class="line">int SearchBTNode(BTNode *p,KeyType k)&#123;</div><div class="line">    int i=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>&amp;&amp;p-&gt;</span>key[i+<span class="number">1</span>]&lt;=k;i++);</div><div class="line">    return i;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">3</span>SearchBTree函数</div><div class="line">功能：在树t中查找关键字k，返回查找结果类型</div><div class="line">代码实现：</div><div class="line">Result SearchBTree(BTree t,KeyType k)&#123;</div><div class="line">    BTNode *p=t,*q=NULL; 							<span class="comment">//初始化结点p和结点q,p指向待查结点,q指向p的双亲</span></div><div class="line">    int found_tag=<span class="number">0</span>;                        		<span class="comment">//设定查找成功与否标志 </span></div><div class="line">	int i=<span class="number">0</span>;                 </div><div class="line">    Result r;                             			<span class="comment">//设定返回的查找结果 </span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(p!=NULL&amp;&amp;found_tag==<span class="number">0</span>)&#123;</div><div class="line">        <span class="function"><span class="title">i</span>=SearchBTNode(p,k);              			//在结点p中查找关键字k        			<span class="keyword">if</span>(i&gt;0&amp;&amp;p-&gt;</span>key[i]==k)    		  			<span class="comment">//找到待查关键字</span></div><div class="line">            found_tag=<span class="number">1</span>;                    		<span class="comment">//查找成功 </span></div><div class="line">        <span class="keyword">else</span>&#123;                               		<span class="comment">//查找失败 </span></div><div class="line">            q=p;                            </div><div class="line">            <span class="function"><span class="title">p</span>=p-&gt;</span>ptr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;                   			<span class="comment">//查找成功</span></div><div class="line">        r.pt=p;</div><div class="line">        r.i=i;</div><div class="line">        r.tag=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                            				<span class="comment">//查找失败</span></div><div class="line">        r.pt=q;</div><div class="line">		r.i=i;</div><div class="line">        r.tag=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    return r;                       				<span class="comment">//返回关键字k的位置(或插入位置)</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">4</span>InsertBTNode函数</div><div class="line">功能：关键字<span class="function"><span class="title">k</span>和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]中</div><div class="line">代码实现：</div><div class="line">void InsertBTNode(BTNode *&amp;p,int i,KeyType k,BTNode *q)&#123;</div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=p-&gt;</span>keynum;j&gt;i;j--)&#123;  						<span class="comment">//整体后移空出一个位置</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>key[i+<span class="number">1</span>]=k;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>ptr[i+<span class="number">1</span>]=q;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=p;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum++;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">5</span>SplitBTNode函数</div><div class="line">功能：将结点p分裂成两个结点,前一半保留,后一半移入结点q</div><div class="line">代码实现：</div><div class="line">void SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)&#123;</div><div class="line">    int i;</div><div class="line">	int s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    q=(BTNode *)malloc(sizeof(BTNode));    			<span class="comment">//给结点q分配空间</span></div><div class="line">	 </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=p-&gt;</span>ptr[s];                   			<span class="comment">//后一半移入结点q</span></div><div class="line">    <span class="keyword">for</span>(i=s+<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[i-s]=p-&gt;</span>key[i];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i-s]=p-&gt;</span>ptr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">keynum</span>=p-&gt;</span>keynum-s;                </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum-s;i++) 						<span class="comment">//修改双亲指针 </span></div><div class="line">        <span class="function"><span class="title">if</span>(q-&gt;</span>ptr[i]!=NULL) </div><div class="line">			<span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>parent=q;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum=s-<span class="number">1</span>;                 				<span class="comment">//结点p的前一半保留,修改结点p的keynum</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">6</span>NewRoot函数</div><div class="line">功能：生成新的根结点t,原p和q为子树指针</div><div class="line">代码实现：</div><div class="line">void NewRoot(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)&#123;</div><div class="line">    t=(BTNode *)malloc(sizeof(BTNode));       		<span class="comment">//分配空间 </span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>keynum=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">0</span>]=p;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">1</span>]=q;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>key[<span class="number">1</span>]=k;</div><div class="line">    <span class="keyword">if</span>(p!=NULL) 									<span class="comment">//调整结点p和q的双亲指针 </span></div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>parent=t;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=t;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>parent=NULL;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">7</span>InsertBTree函数</div><div class="line">功能：在树t中插入关键字k，返回插入结果</div><div class="line">代码实现：</div><div class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTNode *p)&#123;</div><div class="line">    BTNode *q;</div><div class="line">    int finish_tag,newroot_tag,s;                   <span class="comment">//设定需要新结点标志和插入完成标志 </span></div><div class="line">    KeyType x;</div><div class="line">    <span class="keyword">if</span>(p==NULL)                      				<span class="comment">//t是空树</span></div><div class="line">        NewRoot(t,k,NULL,NULL);         			<span class="comment">//生成仅含关键字k的根结点t</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x=k;</div><div class="line">        q=NULL;</div><div class="line">        finish_tag=<span class="number">0</span>;       </div><div class="line">        newroot_tag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(finish_tag==<span class="number">0</span>&amp;&amp;newroot_tag==<span class="number">0</span>)&#123;</div><div class="line">            I<span class="function"><span class="title">nsertBTNode</span>(p,i,x,q);               	//将关键字x和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]</div><div class="line">            <span class="function"><span class="title">if</span> (p-&gt;</span>keynum&lt;=Max) </div><div class="line">				finish_tag=<span class="number">1</span>; 						<span class="comment">//插入完成</span></div><div class="line">            <span class="keyword">else</span>&#123;         </div><div class="line">                s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">                SplitBTNode(p,q);                 <span class="comment">//分裂结点 </span></div><div class="line">                <span class="function"><span class="title">x</span>=p-&gt;</span>key[s];</div><div class="line">                <span class="function"><span class="title">if</span>(p-&gt;</span>parent)&#123;              		<span class="comment">//查找x的插入位置</span></div><div class="line">                    <span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">                    i=SearchBTNode(p, x);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>                            <span class="comment">//没找到x，需要新结点 </span></div><div class="line">					newroot_tag=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(newroot_tag==<span class="number">1</span>)                 		<span class="comment">//根结点已分裂为结点p和q </span></div><div class="line">            NewRoot(t,x,p,q);              		<span class="comment">//生成新根结点t,p和q为子树指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">8</span>Remove函数</div><div class="line">功能：从p结点删除key[i]和它的孩子指针ptr[i]</div><div class="line">代码实现：</div><div class="line">void Remove(BTNode *p,int i)&#123;</div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=i+1;j&lt;=p-&gt;</span>keynum;j++)&#123;      				<span class="comment">//前移删除key[i]和ptr[i]</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j-1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j-1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">9</span>Substitution函数</div><div class="line">功能：寻找替代值（右子树中最小的关键字）</div><div class="line">代码实现：</div><div class="line">void Substitution(BTNode *p,int i)&#123;</div><div class="line">    BTNode *q;</div><div class="line">    <span class="function"><span class="title">for</span>(q=p-&gt;</span><span class="function"><span class="title">ptr</span>[i];q-&gt;</span><span class="function"><span class="title">ptr</span>[0]!=NULL;q=q-&gt;</span>ptr[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];    						<span class="comment">//复制关键字值</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">10</span>MoveRight函数</div><div class="line">功能：双亲结点p中的最后一个关键字移入右结点q中</div><div class="line">将左结点aq中的最后一个关键字移入双亲结点p中</div><div class="line">代码实现：</div><div class="line">void MoveRight(BTNode *p,int i)&#123;    </div><div class="line">int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=q-&gt;</span>keynum;j&gt;<span class="number">0</span>;j--)&#123; 						<span class="comment">//将右兄弟q中所有关键字向后移动一位</span></div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[1]=q-&gt;</span>ptr[<span class="number">0</span>];        					<span class="comment">//从双亲结点p移动关键字到右兄弟q中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[1]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum++;</div><div class="line">    				</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=aq-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span>keynum];					<span class="comment">//将左兄弟aq中最后一个关键字移动到双亲结点p中</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span><span class="function"><span class="title">ptr</span>[0]=aq-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span>keynum];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">11</span>MoveLeft函数</div><div class="line">功能：将双亲结点p中的第一个关键字移入左结点aq中，</div><div class="line">将右结点q中的第一个关键字移入双亲结点p中</div><div class="line">代码实现：</div><div class="line">void MoveLeft(BTNode *p,int i)&#123; </div><div class="line">	int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">                					</div><div class="line">	<span class="function"><span class="title">aq</span>-&gt;</span>keynum++;									<span class="comment">//把双亲结点p中的关键字移动到左兄弟aq中</span></div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i]; </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">                			</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];							<span class="comment">//把右兄弟q中的关键字移动到双亲节点p中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=q-&gt;</span>ptr[<span class="number">1</span>];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum--;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=aq-&gt;</span>keynum;j++)&#123;    					<span class="comment">//将右兄弟q中所有关键字向前移动一位</span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=aq-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=aq-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">12</span>Combine函数</div><div class="line">功能：双亲结点p、右结点q合并入左结点aq，</div><div class="line">并调整双亲结点p中的剩余关键字的位置</div><div class="line">代码实现：</div><div class="line">void Combine(BTNode *p,int i)&#123;</div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];            				</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">keynum</span>++;                    		       //将双亲结点的关键字p-&gt;</span>key[i]插入到左结点aq		</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=q-&gt;</span>keynum;j++)&#123;        				<span class="comment">//将右结点q中的所有关键字插入到左结点aq </span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span>keynum++;</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=i;j&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>;j++)&#123;     					//将双亲结点p中的p-&gt;</span>key[i]后的所有关键字向前移动一位 </div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=p-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=p-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;                                    <span class="comment">//修改双亲结点p的keynum值 </span></div><div class="line">    free(q);                        				<span class="comment">//释放空右结点q的空间</span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">13</span>AdjustBTree函数</div><div class="line">功能：删除结点p中的第i个关键字后,调整B树</div><div class="line">代码实现：</div><div class="line">void AdjustBTree(BTNode *p,int i)&#123;</div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)                           				<span class="comment">//删除的是最左边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[1]-&gt;</span>keynum&gt;Min)                   <span class="comment">//右结点可以借</span></div><div class="line">            MoveLeft(p,<span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span>                                        <span class="comment">//右兄弟不够借 </span></div><div class="line">            Combine(p,<span class="number">1</span>);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(i==p-&gt;</span>keynum)              				<span class="comment">//删除的是最右边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)                 <span class="comment">//左结点可以借 </span></div><div class="line">            MoveRight(p,i);</div><div class="line">        <span class="keyword">else</span>										<span class="comment">//左结点不够借 </span></div><div class="line">            Combine(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)  	 			<span class="comment">//删除关键字在中部且左结点够借 </span></div><div class="line">        MoveRight(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i+1]-&gt;</span>keynum&gt;Min)                <span class="comment">//删除关键字在中部且右结点够借 </span></div><div class="line">        MoveLeft(p,i+<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span>                                            <span class="comment">//删除关键字在中部且左右结点都不够借</span></div><div class="line">        Combine(p,i);</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">14</span>BTNodeDelete函数</div><div class="line">功能：在结点p中查找并删除关键字k</div><div class="line">代码实现：</div><div class="line">int BTNodeDelete(BTNode *p,KeyType k)&#123;</div><div class="line">    int i;</div><div class="line">    int found_tag;                                 	<span class="comment">//查找标志 </span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">        return <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    	found_tag=FindBTNode(p,k,i);				<span class="comment">//返回查找结果 </span></div><div class="line">        <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;       			        <span class="comment">//查找成功 </span></div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i-<span class="number">1</span>]!=NULL)&#123;             		<span class="comment">//删除的是非叶子结点</span></div><div class="line">                Substitution(p,i);                 	<span class="comment">//寻找相邻关键字(右子树中最小的关键字) </span></div><div class="line">                BTN<span class="function"><span class="title">odeDelete</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i],p-&gt;</span>key[i]); 	<span class="comment">//执行删除操作 </span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Remove(p,i);                    	<span class="comment">//从结点p中位置i处删除关键字</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="function"><span class="title">found_tag</span>=BTNodeDelete(p-&gt;</span>ptr[i],k);    <span class="comment">//沿孩子结点递归查找并删除关键字k</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i]!=NULL)</div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>keynum&lt;Min)          		<span class="comment">//删除后关键字个数小于MIN</span></div><div class="line">                AdjustBTree(p,i);					<span class="comment">//调整B树 </span></div><div class="line">        return found_tag;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">15</span>BTreeDelete函数</div><div class="line">功能：构建删除框架，执行删除操作</div><div class="line">代码实现：</div><div class="line">void BTreeDelete(BTree &amp;t,KeyType k)&#123;  </div><div class="line">    BTNode *p;</div><div class="line">	int a=BTNodeDelete(t,k);                 		<span class="comment">//删除关键字k </span></div><div class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)                                    	<span class="comment">//查找失败 </span></div><div class="line">        printf(<span class="string">"   关键字%d不在B树中\n"</span>,k);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(t-&gt;</span>keynum==<span class="number">0</span>)&#123;                          <span class="comment">//调整 </span></div><div class="line">        p=t;</div><div class="line">        <span class="function"><span class="title">t</span>=t-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">        free(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">16</span>DestroyBTree函数</div><div class="line">功能：递归释放B树</div><div class="line">代码实现：</div><div class="line">void DestroyBTree(BTree &amp;t)&#123;</div><div class="line">    int i;  </div><div class="line">    BTNode* p=t;  </div><div class="line">    <span class="keyword">if</span>(p!=NULL)&#123;                                 	<span class="comment">//B树不为空  </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum;i++)&#123;  				<span class="comment">//递归释放每一个结点 </span></div><div class="line">            D<span class="function"><span class="title">estroyBTree</span>(*&amp;p-&gt;</span>ptr[i]);  </div><div class="line">        &#125;  </div><div class="line">        free(p);  </div><div class="line">    &#125;  </div><div class="line">    t=NULL;  </div><div class="line">&#125;  </div><div class="line"><span class="number">2.4</span>.<span class="number">17</span>InitQueue函数</div><div class="line">功能：初始化队列</div><div class="line">代码实现： </div><div class="line">Status InitQueue(LinkList &amp;L)&#123;</div><div class="line">	L=(LNode*)malloc(sizeof(LNode));				<span class="comment">//分配结点空间 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//分配失败				</span></div><div class="line">        return OVERFLOW;</div><div class="line">     L-&gt;next=NULL;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">18</span>CreateNode函数</div><div class="line">功能：新建一个结点</div><div class="line">代码实现：</div><div class="line">LNode* CreateNode(BTNode *p)&#123;</div><div class="line">    LNode *q;</div><div class="line">    q=(LNode*)malloc(sizeof(LNode)); 				<span class="comment">//分配结点空间</span></div><div class="line">    <span class="keyword">if</span>(q!=NULL)&#123;                                    <span class="comment">//分配成功 </span></div><div class="line">    	<span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=p;</div><div class="line">       	<span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    &#125;</div><div class="line">   return q;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">19</span>Enqueue函数</div><div class="line">功能：元素q入队列</div><div class="line">代码实现：</div><div class="line">Status Enqueue(LNode *p,BTNode *q)&#123; </div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">		return ERROR; 								</div><div class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next!=NULL)                            <span class="comment">//调至队列最后 </span></div><div class="line">        <span class="function"><span class="title">p</span>=p-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=CreateNode(q);                          <span class="comment">//生成结点让q进入队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">20</span>Dequeue函数</div><div class="line">功能：出队列，并以q返回值</div><div class="line">代码实现： </div><div class="line">Status Dequeue(LNode *p,BTNode *&amp;q)&#123;</div><div class="line">	LNode *aq;</div><div class="line">    <span class="function"><span class="title">if</span>(p==NULL||p-&gt;</span>next==NULL) 						<span class="comment">//删除位置不合理 </span></div><div class="line">		return ERROR; </div><div class="line">    <span class="function"><span class="title">aq</span>=p-&gt;</span>next;										<span class="comment">//修改被删结点aq的指针域</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=aq-&gt;</span>next; 								</div><div class="line">    <span class="function"><span class="title">q</span>=aq-&gt;</span><span class="keyword">data</span>;</div><div class="line">    free(aq); 										<span class="comment">//释放结点aq</span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">21</span>IfEmpty函数</div><div class="line">功能：队列判空 </div><div class="line">代码实现：</div><div class="line">Status IfEmpty(LinkList L)&#123;</div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//队列不存在 </span></div><div class="line">		return ERROR;</div><div class="line">    <span class="function"><span class="title">if</span>(L-&gt;</span>next==NULL) 								<span class="comment">//队列为空 </span></div><div class="line">		return TRUE;</div><div class="line">    return FALSE;									<span class="comment">//队列非空 </span></div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">22</span>DestroyQueue函数</div><div class="line">功能：销毁队列</div><div class="line">代码实现：</div><div class="line">void DestroyQueue(LinkList L)&#123;</div><div class="line">   LinkList p;</div><div class="line">    <span class="keyword">if</span>(L!=NULL)&#123;</div><div class="line">    	p=L;</div><div class="line">       	L=L-&gt;next;</div><div class="line">       	free(p);                                   	<span class="comment">//逐一释放 </span></div><div class="line">        DestroyQueue(L);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">23</span>Traverse函数</div><div class="line">功能：用队列遍历输出B树</div><div class="line">代码实现：</div><div class="line">Status Traverse(BTree t,LinkList L,int newline,int sum)&#123; </div><div class="line">    int i;</div><div class="line">    BTree p;</div><div class="line">    <span class="keyword">if</span>(t!=NULL)&#123;</div><div class="line">        printf(<span class="string">"  [ "</span>);</div><div class="line">        E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[<span class="number">0</span>]);                      	<span class="comment">//入队         </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=1;i&lt;=t-&gt;</span>keynum;i++)&#123;</div><div class="line">            <span class="function"><span class="title">printf</span>(" %d ",t-&gt;</span>key[i]);</div><div class="line">            E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[i]);					<span class="comment">//子结点入队 </span></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="title">sum</span>+=t-&gt;</span>keynum+<span class="number">1</span>;</div><div class="line">        printf(<span class="string">"]"</span>);</div><div class="line">        <span class="keyword">if</span>(newline==<span class="number">0</span>)&#123;                             <span class="comment">//需要另起一行 </span></div><div class="line">        	printf(<span class="string">"\n"</span>);</div><div class="line">            newline=sum-<span class="number">1</span>;</div><div class="line">            sum=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            newline--;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">if</span>(IfEmpty(L)==FALSE)&#123;                       	<span class="comment">//l不为空 </span></div><div class="line">         Dequeue(L,p);								<span class="comment">//出队，以p返回 </span></div><div class="line">         Traverse(p,L,newline,sum);					<span class="comment">//遍历出队结点 </span></div><div class="line">     &#125;</div><div class="line">     return OK;</div><div class="line"> &#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">24</span>PrintBTree函数</div><div class="line">功能：输出B树</div><div class="line">代码实现：</div><div class="line">Status PrintBTree(BTree t)&#123;</div><div class="line">   LinkList L;</div><div class="line">    <span class="keyword">if</span>(t==NULL)&#123;</div><div class="line">        printf(<span class="string">"  B树为空树"</span>);</div><div class="line">        return OK;</div><div class="line">    &#125;</div><div class="line">    InitQueue(L);                        			<span class="comment">//初始化队列 </span></div><div class="line">    Traverse(t,L,<span class="number">0</span>,<span class="number">0</span>);								<span class="comment">//利用队列输出 </span></div><div class="line">    DestroyQueue(L);								<span class="comment">//销毁队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"><span class="number">2.4</span>.<span class="number">25</span>Test1函数</div><div class="line">功能：测试B树功能</div><div class="line">代码实现：</div><div class="line">void Test1()&#123; </div><div class="line">	system(<span class="string">"color 70"</span>);  </div><div class="line">    BTNode *t=NULL;</div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">    int j,n=<span class="number">15</span>;</div><div class="line">    KeyType k;</div><div class="line">    KeyType a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;                           </div><div class="line">    printf(<span class="string">"创建一棵%d阶B树:\n"</span>,m);</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;								<span class="comment">//逐一插入元素 </span></div><div class="line">        s=SearchBTree(t,a[j]);</div><div class="line">        <span class="keyword">if</span>(s.tag==<span class="number">0</span>)</div><div class="line">            InsertBTree(t,s.i,a[j],s.pt);</div><div class="line">        printf(<span class="string">"   第%d步,插入元素%d:\n "</span>,j+<span class="number">1</span>,a[j]);</div><div class="line">        PrintBTree(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"删除操作:\n"</span>);                         	<span class="comment">//删除操作 </span></div><div class="line">    k=<span class="number">9</span>;														</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    k=<span class="number">1</span>;</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"  递归释放B树\n"</span>); 						<span class="comment">//递归释放B树</span></div><div class="line">    DestroyBTree(t);								 </div><div class="line">	PrintBTree(t);</div><div class="line">&#125; </div><div class="line"><span class="number">2.4</span>.<span class="number">26</span>Test2函数</div><div class="line">功能：测试B树功能</div><div class="line">代码实现：</div><div class="line">void Test2()&#123;</div><div class="line">	int i,k; </div><div class="line">	system(<span class="string">"color 70"</span>);</div><div class="line">	BTree t=NULL;  </div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">	printf(<span class="string">"此时的B树：\n"</span>);</div><div class="line">	PrintBTree(t); </div><div class="line">	printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"=============Operation Table=============\n"</span>);</div><div class="line">    printf(<span class="string">"   1.Init     2.Insert    3.Delete    \n"</span>);</div><div class="line">    printf(<span class="string">"   4.Destroy  5.Exit  	  \n"</span>);</div><div class="line">    printf(<span class="string">"=========================================\n"</span>);</div><div class="line">    printf(<span class="string">"Enter number to choose operation:_____\b\b\b"</span>);</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;i);</div><div class="line">    switch(i)&#123;</div><div class="line">    	case <span class="number">1</span>:&#123;</div><div class="line">			InitBTree(t);</div><div class="line">			printf(<span class="string">"InitBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		case <span class="number">2</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to InsertBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			s=SearchBTree(t,k);</div><div class="line">			InsertBTree(t,s.i,k,s.pt);</div><div class="line">			printf(<span class="string">"InsertBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">3</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to DeleteBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			BTreeDelete(t,k);</div><div class="line">			printf(<span class="string">"\n"</span>);</div><div class="line">			printf(<span class="string">"DeleteBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">4</span>:&#123;</div><div class="line">			DestroyBTree(t);</div><div class="line">			break;</div><div class="line">			printf(<span class="string">"DestroyBTree successfully.\n"</span>);</div><div class="line">		&#125;</div><div class="line">		case <span class="number">5</span>:&#123;</div><div class="line">			exit(-<span class="number">1</span>);				</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>三.功能测试</strong><br>插入功能测试/遍历功能测试<br>依次插入1-15进行测试输出，结果如下：<br><img src="http://img.blog.csdn.net/20171225173213197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>由输出的B树可知，插入功能正常并且遍历功能正常<br>3.2删除功能测试<br>在之前插入1-15后进行删除关键字的功能测试，选取9和1依次进行删除测试，结果如下：<br><img src="http://img.blog.csdn.net/20171225173233140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>根据B树的定义和该B树的输出，删除功能正常<br>3.3释放功能测试<br>在之前的基础上进行递归释放B树功能测试，结果如下：<br><img src="http://img.blog.csdn.net/20171225173241746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>遍历输出的结果为B数为空树，说明释放功能正常<br>3.4其他功能测试<br>其他接口在以上功能中已经有所体现，均正常，不再一一调用测试。<br><strong>四.思考与小结</strong><br><strong>错误总结</strong><br>（1）在部分需要判空的地方没有判空<br>（2）递归实现的时候多次爆栈<br>（3）插入分裂的SplitBTNode函数一开始写的时候分裂成两个<br>（4）删除操作中的Combine函数的指针忘记调整<br><strong>4.2部分优化</strong><br>4.2.1输出优化<br>在一开始输出的时候选用的是括号输出法(测试功能选用的值略有不同),在直观上比较难的去分辨哪些是双亲结点的左右结点，因此在输出函数上进行了优化<br><img src="http://img.blog.csdn.net/20171225173325462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>通过队列遍历，在每一次遍历的过程中能够，模拟层次遍历，在B树的结构上更加美观，而且更容易看清楚B树的结构<br><img src="http://img.blog.csdn.net/20171225173335299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>4.2.2测试界面优化<br>在保持原本接口不变的情况下，写了Test2函数，自行创建和进行各种B树的操作.<br><img src="http://img.blog.csdn.net/20171225173348525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>整个程序源代码</strong><br><strong>头文件</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _BTREE_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10              		<span class="comment">//定义B树的最大的阶数</span></span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> m=<span class="number">4</span>;               		<span class="comment">//设定B树的阶数 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Max=m<span class="number">-1</span>;           		<span class="comment">//结点的最大关键字数量 </span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> Min=(m<span class="number">-1</span>)/<span class="number">2</span>;				<span class="comment">//结点的最小关键字数量 </span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> KeyType;       	 		<span class="comment">//KeyType为关键字类型</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>         		<span class="comment">//B树和B树结点类型 </span></div><div class="line">	<span class="keyword">int</span> keynum;    		         	<span class="comment">//结点关键字个数</span></div><div class="line">	KeyType key[MAXM];          	<span class="comment">//关键字数组，key[0]不使用 </span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">parent</span>;</span>        	<span class="comment">//双亲结点指针</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">ptr</span>[<span class="title">MAXM</span>];</span>     	<span class="comment">//孩子结点指针数组 </span></div><div class="line">&#125;BTNode,*BTree;</div><div class="line">   </div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              		<span class="comment">//B树查找结果类型 </span></div><div class="line">	BTNode *pt;              		<span class="comment">//指向找到的结点</span></div><div class="line">	<span class="keyword">int</span> i;                   		<span class="comment">//在结点中的关键字位置; </span></div><div class="line">	<span class="keyword">int</span> tag;                 		<span class="comment">//查找成功与否标志</span></div><div class="line">&#125;Result;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>               <span class="comment">//链表和链表结点类型 </span></div><div class="line">  	BTree data;     				<span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>     		<span class="comment">//指针域</span></div><div class="line">&#125;LNode, *LinkList;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> status&#123;               <span class="comment">//枚举类型（依次递增） </span></div><div class="line">    TRUE,</div><div class="line">    FALSE,</div><div class="line">    OK,</div><div class="line">    ERROR,</div><div class="line">    OVERFLOW,</div><div class="line">  	EMPTY</div><div class="line">&#125;Status;</div><div class="line"></div><div class="line"><span class="function">Status <span class="title">InitBTree</span><span class="params">(BTree &amp;t)</span></span>;                                     <span class="comment">//初始化B树 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchBTNode</span><span class="params">(BTNode *p,KeyType k)</span></span>;                  		<span class="comment">//在结点p中查找关键字k的插入位置i </span></div><div class="line"><span class="function">Result <span class="title">SearchBTree</span><span class="params">(BTree t,KeyType k)</span></span>;               			<span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">																tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">																关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTNode</span><span class="params">(BTNode *&amp;p,<span class="keyword">int</span> i,KeyType k,BTNode *q)</span></span>; 		<span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SplitBTNode</span><span class="params">(BTNode *&amp;p,BTNode *&amp;q)</span></span>;						<span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">NewRoot</span><span class="params">(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)</span></span>;			<span class="comment">//生成新的根结点t,原结点p和结点q为子树指针</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBTree</span><span class="params">(BTree &amp;t,<span class="keyword">int</span> i,KeyType k,BTNode *p)</span></span>;			<span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">																 结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>; 									<span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Substitution</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;      						<span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveRight</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                <span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">																将左结点aq中的最后一个关键字移入双亲结点p中*/</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveLeft</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                 <span class="comment">/*将双亲结点p中的第一个关键字移入结点aq中，</span></div><div class="line"><span class="comment">																 将结点q中的第一个关键字移入双亲结点p中*/</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Combine</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                                  <span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">																并调整双亲结点p中的剩余关键字的位置*/</span>																 </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustBTree</span><span class="params">(BTNode *p,<span class="keyword">int</span> i)</span></span>;                              <span class="comment">//删除结点p中的第i个关键字后,调整B树																 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindBTNode</span><span class="params">(BTNode *p,KeyType k,<span class="keyword">int</span> &amp;i)</span></span>;                     <span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BTNodeDelete</span><span class="params">(BTNode *p,KeyType k)</span></span>;                          <span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BTreeDelete</span><span class="params">(BTree &amp;t,KeyType k)</span></span>;                          	<span class="comment">//构建删除框架，执行删除操作 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyBTree</span><span class="params">(BTree &amp;t)</span></span>;                                    <span class="comment">//递归释放B树</span></div><div class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkList &amp;L)</span></span>;                                  <span class="comment">//初始化队列 </span></div><div class="line"><span class="function">LNode* <span class="title">CreateNode</span><span class="params">(BTree t)</span></span>;                               		<span class="comment">//新建一个结点 </span></div><div class="line"><span class="function">Status <span class="title">Enqueue</span><span class="params">(LNode *p,BTree t)</span></span>;								<span class="comment">//元素q入队列</span></div><div class="line"><span class="function">Status <span class="title">Dequeue</span><span class="params">(LNode *p,BTNode *&amp;q)</span></span>;                            <span class="comment">//出队列，并以q返回值</span></div><div class="line"><span class="function">Status <span class="title">IfEmpty</span><span class="params">(LinkList L)</span></span>;                       				<span class="comment">//队列判空 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkList L)</span></span>;    								<span class="comment">//销毁队列 </span></div><div class="line"><span class="function">Status <span class="title">Traverse</span><span class="params">(BTree t,LinkList L,<span class="keyword">int</span> newline,<span class="keyword">int</span> sum)</span></span>;		<span class="comment">//用队列遍历输出B树 </span></div><div class="line"><span class="function">Status <span class="title">PrintBTree</span><span class="params">(BTree t)</span></span>;                                     <span class="comment">//输出B树 </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span>;                  									<span class="comment">//测试B树功能函数 </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p><strong>BTree代码</strong></p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div></pre></td><td class="code"><pre><div class="line">#include<span class="string">"BTREE.h"</span></div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;malloc.h&gt;</div><div class="line">#include &lt;stdlib.h&gt; </div><div class="line"></div><div class="line">Status InitBTree(BTree &amp;t)&#123;</div><div class="line"><span class="comment">//初始化B树 </span></div><div class="line">    t=NULL;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int SearchBTNode(BTNode *p,KeyType k)&#123;</div><div class="line"><span class="comment">//在结点p中查找关键字k的插入位置i </span></div><div class="line">    int i=<span class="number">0</span>;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>&amp;&amp;p-&gt;</span>key[i+<span class="number">1</span>]&lt;=k;i++);</div><div class="line">    return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Result SearchBTree(BTree t,KeyType k)&#123;</div><div class="line"><span class="comment">/*在树t上查找关键字k,返回结果(pt,i,tag)。若查找成功,则特征值</span></div><div class="line"><span class="comment">tag=1,关键字k是指针pt所指结点中第i个关键字；否则特征值tag=0,</span></div><div class="line"><span class="comment">关键字k的插入位置为pt结点的第i个*/</span></div><div class="line"></div><div class="line">    BTNode *p=t,*q=NULL; 							<span class="comment">//初始化结点p和结点q,p指向待查结点,q指向p的双亲</span></div><div class="line">    int found_tag=<span class="number">0</span>;                        		<span class="comment">//设定查找成功与否标志 </span></div><div class="line">	int i=<span class="number">0</span>;                 </div><div class="line">    Result r;                             			<span class="comment">//设定返回的查找结果 </span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span>(p!=NULL&amp;&amp;found_tag==<span class="number">0</span>)&#123;</div><div class="line">        <span class="function"><span class="title">i</span>=SearchBTNode(p,k);              			//在结点p中查找关键字k,使得p-&gt;</span><span class="function"><span class="title">key</span>[i]&lt;=k&lt;p-&gt;</span>key[i+<span class="number">1</span>]</div><div class="line">        <span class="function"><span class="title">if</span>(i&gt;0&amp;&amp;p-&gt;</span>key[i]==k)    		  			<span class="comment">//找到待查关键字</span></div><div class="line">            found_tag=<span class="number">1</span>;                    		<span class="comment">//查找成功 </span></div><div class="line">        <span class="keyword">else</span>&#123;                               		<span class="comment">//查找失败 </span></div><div class="line">            q=p;                            </div><div class="line">            <span class="function"><span class="title">p</span>=p-&gt;</span>ptr[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;                   			<span class="comment">//查找成功</span></div><div class="line">        r.pt=p;</div><div class="line">        r.i=i;</div><div class="line">        r.tag=<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                            				<span class="comment">//查找失败</span></div><div class="line">        r.pt=q;</div><div class="line">		r.i=i;</div><div class="line">        r.tag=<span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return r;                       				<span class="comment">//返回关键字k的位置(或插入位置)</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void InsertBTNode(BTNode *&amp;p,int i,KeyType k,BTNode *q)&#123;</div><div class="line"><span class="comment">//将关键字k和结点q分别插入到p-&gt;key[i+1]和p-&gt;ptr[i+1]中</span></div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=p-&gt;</span>keynum;j&gt;i;j--)&#123;  						<span class="comment">//整体后移空出一个位置</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>key[i+<span class="number">1</span>]=k;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>ptr[i+<span class="number">1</span>]=q;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=p;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void SplitBTNode(BTNode *&amp;p,BTNode *&amp;q)&#123;</div><div class="line"><span class="comment">//将结点p分裂成两个结点,前一半保留,后一半移入结点q</span></div><div class="line">    int i;</div><div class="line">	int s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">    q=(BTNode *)malloc(sizeof(BTNode));    			<span class="comment">//给结点q分配空间</span></div><div class="line">	 </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=p-&gt;</span>ptr[s];                   			<span class="comment">//后一半移入结点q</span></div><div class="line">    <span class="keyword">for</span>(i=s+<span class="number">1</span>;i&lt;=m;i++)&#123;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[i-s]=p-&gt;</span>key[i];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i-s]=p-&gt;</span>ptr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">keynum</span>=p-&gt;</span>keynum-s;                </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">parent</span>=p-&gt;</span>parent;</div><div class="line">    <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum-s;i++) 					<span class="comment">//修改双亲指针 </span></div><div class="line">        <span class="function"><span class="title">if</span>(q-&gt;</span>ptr[i]!=NULL) </div><div class="line">			<span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>parent=q;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum=s-<span class="number">1</span>;                 					<span class="comment">//结点p的前一半保留,修改结点p的keynum</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void NewRoot(BTNode *&amp;t,KeyType k,BTNode *p,BTNode *q)&#123;</div><div class="line"><span class="comment">//生成新的根结点t,原p和q为子树指针</span></div><div class="line">    t=(BTNode *)malloc(sizeof(BTNode));       		<span class="comment">//分配空间 </span></div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>keynum=<span class="number">1</span>;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">0</span>]=p;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>ptr[<span class="number">1</span>]=q;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>key[<span class="number">1</span>]=k;</div><div class="line">    <span class="keyword">if</span>(p!=NULL) 									<span class="comment">//调整结点p和结点q的双亲指针 </span></div><div class="line">		<span class="function"><span class="title">p</span>-&gt;</span>parent=t;</div><div class="line">    <span class="keyword">if</span>(q!=NULL) </div><div class="line">		<span class="function"><span class="title">q</span>-&gt;</span>parent=t;</div><div class="line">    <span class="function"><span class="title">t</span>-&gt;</span>parent=NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void InsertBTree(BTree &amp;t,int i,KeyType k,BTNode *p)&#123;</div><div class="line"><span class="comment">/*在树t上结点q的key[i]与key[i+1]之间插入关键字k。若引起</span></div><div class="line"><span class="comment">结点过大,则沿双亲链进行必要的结点分裂调整,使t仍是B树*/</span></div><div class="line">    BTNode *q;</div><div class="line">    int finish_tag,newroot_tag,s;                   <span class="comment">//设定需要新结点标志和插入完成标志 </span></div><div class="line">    KeyType x;</div><div class="line">    <span class="keyword">if</span>(p==NULL)                      				<span class="comment">//t是空树</span></div><div class="line">        NewRoot(t,k,NULL,NULL);         			<span class="comment">//生成仅含关键字k的根结点t</span></div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        x=k;</div><div class="line">        q=NULL;</div><div class="line">        finish_tag=<span class="number">0</span>;       </div><div class="line">        newroot_tag=<span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(finish_tag==<span class="number">0</span>&amp;&amp;newroot_tag==<span class="number">0</span>)&#123;</div><div class="line">            I<span class="function"><span class="title">nsertBTNode</span>(p,i,x,q);               	//将关键字x和结点q分别插入到p-&gt;</span><span class="function"><span class="title">key</span>[i+1]和p-&gt;</span>ptr[i+<span class="number">1</span>]</div><div class="line">            <span class="function"><span class="title">if</span> (p-&gt;</span>keynum&lt;=Max) </div><div class="line">				finish_tag=<span class="number">1</span>; 						<span class="comment">//插入完成</span></div><div class="line">            <span class="keyword">else</span>&#123;         </div><div class="line">                s=(m+<span class="number">1</span>)/<span class="number">2</span>;</div><div class="line">                SplitBTNode(p,q);                   <span class="comment">//分裂结点 </span></div><div class="line">                <span class="function"><span class="title">x</span>=p-&gt;</span>key[s];</div><div class="line">                <span class="function"><span class="title">if</span>(p-&gt;</span>parent)&#123;              		<span class="comment">//查找x的插入位置</span></div><div class="line">                    <span class="function"><span class="title">p</span>=p-&gt;</span>parent;</div><div class="line">                    i=SearchBTNode(p, x);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span>                                <span class="comment">//没找到x，需要新结点 </span></div><div class="line">					newroot_tag=<span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(newroot_tag==<span class="number">1</span>)                 			<span class="comment">//根结点已分裂为结点p和q </span></div><div class="line">            NewRoot(t,x,p,q);              			<span class="comment">//生成新根结点t,p和q为子树指针</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Remove(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//从p结点删除key[i]和它的孩子指针ptr[i]</span></div><div class="line">    int j;</div><div class="line">    <span class="function"><span class="title">for</span>(j=i+1;j&lt;=p-&gt;</span>keynum;j++)&#123;      				<span class="comment">//前移删除key[i]和ptr[i]</span></div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j-1]=p-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j-1]=p-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Substitution(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//查找被删关键字p-&gt;key[i](在非叶子结点中)的替代叶子结点(右子树中值最小的关键字) </span></div><div class="line">    BTNode *q;</div><div class="line">    <span class="function"><span class="title">for</span>(q=p-&gt;</span><span class="function"><span class="title">ptr</span>[i];q-&gt;</span><span class="function"><span class="title">ptr</span>[0]!=NULL;q=q-&gt;</span>ptr[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];    						<span class="comment">//复制关键字值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void MoveRight(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p中的最后一个关键字移入右结点q中</span></div><div class="line"><span class="comment">将左结点aq中的最后一个关键字移入双亲结点p中*/</span> </div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=q-&gt;</span>keynum;j&gt;<span class="number">0</span>;j--)&#123; 						<span class="comment">//将右兄弟q中所有关键字向后移动一位</span></div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[j+1]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j+1]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[1]=q-&gt;</span>ptr[<span class="number">0</span>];        					<span class="comment">//从双亲结点p移动关键字到右兄弟q中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">key</span>[1]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum++;</div><div class="line">    				</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=aq-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span>keynum];					<span class="comment">//将左兄弟aq中最后一个关键字移动到双亲结点p中</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span><span class="function"><span class="title">ptr</span>[0]=aq-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span>keynum];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span>keynum--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void MoveLeft(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p中的第一个关键字移入左结点aq中，</span></div><div class="line"><span class="comment">将右结点q中的第一个关键字移入双亲结点p中*/</span> </div><div class="line">	int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];</div><div class="line">                					</div><div class="line">	<span class="function"><span class="title">aq</span>-&gt;</span>keynum++;									<span class="comment">//把双亲结点p中的关键字移动到左兄弟aq中</span></div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i]; </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">                			</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[i]=q-&gt;</span>key[<span class="number">1</span>];							<span class="comment">//把右兄弟q中的关键字移动到双亲节点p中</span></div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span><span class="function"><span class="title">ptr</span>[0]=q-&gt;</span>ptr[<span class="number">1</span>];</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>keynum--;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=aq-&gt;</span>keynum;j++)&#123;    					<span class="comment">//将右兄弟q中所有关键字向前移动一位</span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=aq-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=aq-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void Combine(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">/*将双亲结点p、右结点q合并入左结点aq，</span></div><div class="line"><span class="comment">并调整双亲结点p中的剩余关键字的位置*/</span> </div><div class="line">    int j;</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *q=p-&gt;</span>ptr[i];            				</div><div class="line">    BTN<span class="function"><span class="title">ode</span> *aq=p-&gt;</span>ptr[i-<span class="number">1</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">keynum</span>++;                    		       //将双亲结点的关键字p-&gt;</span>key[i]插入到左结点aq		</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=p-&gt;</span>key[i];</div><div class="line">    <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=1;j&lt;=q-&gt;</span>keynum;j++)&#123;        				<span class="comment">//将右结点q中的所有关键字插入到左结点aq </span></div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span>keynum++;</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">key</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>key[j];</div><div class="line">        <span class="function"><span class="title">aq</span>-&gt;</span><span class="function"><span class="title">ptr</span>[aq-&gt;</span><span class="function"><span class="title">keynum</span>]=q-&gt;</span>ptr[j];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span>(j=i;j&lt;p-&gt;</span><span class="function"><span class="title">keynum</span>;j++)&#123;     					//将双亲结点p中的p-&gt;</span>key[i]后的所有关键字向前移动一位 </div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">key</span>[j]=p-&gt;</span>key[j+<span class="number">1</span>];</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">ptr</span>[j]=p-&gt;</span>ptr[j+<span class="number">1</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>keynum--;                                    <span class="comment">//修改双亲结点p的keynum值 </span></div><div class="line">    free(q);                        				<span class="comment">//释放空右结点q的空间</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void AdjustBTree(BTNode *p,int i)&#123;</div><div class="line"><span class="comment">//删除结点p中的第i个关键字后,调整B树</span></div><div class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>)                           				<span class="comment">//删除的是最左边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[1]-&gt;</span>keynum&gt;Min)                   <span class="comment">//右结点可以借</span></div><div class="line">            MoveLeft(p,<span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span>                                        <span class="comment">//右兄弟不够借 </span></div><div class="line">            Combine(p,<span class="number">1</span>);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(i==p-&gt;</span>keynum)              				<span class="comment">//删除的是最右边关键字</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)                 <span class="comment">//左结点可以借 </span></div><div class="line">            MoveRight(p,i);</div><div class="line">        <span class="keyword">else</span>										<span class="comment">//左结点不够借 </span></div><div class="line">            Combine(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i-1]-&gt;</span>keynum&gt;Min)  	 			<span class="comment">//删除关键字在中部且左结点够借 </span></div><div class="line">        MoveRight(p,i);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i+1]-&gt;</span>keynum&gt;Min)                <span class="comment">//删除关键字在中部且右结点够借 </span></div><div class="line">        MoveLeft(p,i+<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span>                                            <span class="comment">//删除关键字在中部且左右结点都不够借</span></div><div class="line">        Combine(p,i);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int FindBTNode(BTNode *p,KeyType k,int &amp;i)&#123;</div><div class="line"><span class="comment">//反映是否在结点p中是否查找到关键字k </span></div><div class="line">	<span class="function"><span class="title">if</span>(k&lt;p-&gt;</span>key[<span class="number">1</span>])&#123;    							<span class="comment">//结点p中查找关键字k失败 </span></div><div class="line">        i=<span class="number">0</span>;</div><div class="line">        return <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;                							<span class="comment">//在p结点中查找</span></div><div class="line">        <span class="function"><span class="title">i</span>=p-&gt;</span>keynum;</div><div class="line">        <span class="function"><span class="title">while</span>(k&lt;p-&gt;</span>key[i]&amp;&amp;i&gt;<span class="number">1</span>)</div><div class="line">            i--;</div><div class="line">    	<span class="function"><span class="title">if</span>(k==p-&gt;</span>key[i])                            <span class="comment">//结点p中查找关键字k成功 </span></div><div class="line">    		return <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int BTNodeDelete(BTNode *p,KeyType k)&#123;</div><div class="line"><span class="comment">//在结点p中查找并删除关键字k</span></div><div class="line">    int i;</div><div class="line">    int found_tag;                                 	<span class="comment">//查找标志 </span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">        return <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">    	found_tag=FindBTNode(p,k,i);				<span class="comment">//返回查找结果 </span></div><div class="line">        <span class="keyword">if</span>(found_tag==<span class="number">1</span>)&#123;       			        <span class="comment">//查找成功 </span></div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i-<span class="number">1</span>]!=NULL)&#123;             		<span class="comment">//删除的是非叶子结点</span></div><div class="line">                Substitution(p,i);                 	<span class="comment">//寻找相邻关键字(右子树中最小的关键字) </span></div><div class="line">                BTN<span class="function"><span class="title">odeDelete</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i],p-&gt;</span>key[i]); 	<span class="comment">//执行删除操作 </span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                Remove(p,i);                    	<span class="comment">//从结点p中位置i处删除关键字</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="function"><span class="title">found_tag</span>=BTNodeDelete(p-&gt;</span>ptr[i],k);    <span class="comment">//沿孩子结点递归查找并删除关键字k</span></div><div class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>ptr[i]!=NULL)</div><div class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span><span class="function"><span class="title">ptr</span>[i]-&gt;</span>keynum&lt;Min)          		<span class="comment">//删除后关键字个数小于MIN</span></div><div class="line">                AdjustBTree(p,i);					<span class="comment">//调整B树 </span></div><div class="line">        return found_tag;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void BTreeDelete(BTree &amp;t,KeyType k)&#123;</div><div class="line"><span class="comment">//构建删除框架，执行删除操作  </span></div><div class="line">    BTNode *p;</div><div class="line">	int a=BTNodeDelete(t,k);                 		<span class="comment">//删除关键字k </span></div><div class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>)                                    	<span class="comment">//查找失败 </span></div><div class="line">        printf(<span class="string">"   关键字%d不在B树中\n"</span>,k);</div><div class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span>(t-&gt;</span>keynum==<span class="number">0</span>)&#123;                          <span class="comment">//调整 </span></div><div class="line">        p=t;</div><div class="line">        <span class="function"><span class="title">t</span>=t-&gt;</span>ptr[<span class="number">0</span>];</div><div class="line">        free(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">void DestroyBTree(BTree &amp;t)&#123;</div><div class="line"><span class="comment">//递归释放B树 </span></div><div class="line">    int i;  </div><div class="line">    BTNode* p=t;  </div><div class="line">    <span class="keyword">if</span>(p!=NULL)&#123;                                 	<span class="comment">//B树不为空  </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=0;i&lt;=p-&gt;</span>keynum;i++)&#123;  				<span class="comment">//递归释放每一个结点 </span></div><div class="line">            D<span class="function"><span class="title">estroyBTree</span>(*&amp;p-&gt;</span>ptr[i]);  </div><div class="line">        &#125;  </div><div class="line">        free(p);  </div><div class="line">    &#125;  </div><div class="line">    t=NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">Status InitQueue(LinkList &amp;L)&#123;</div><div class="line"><span class="comment">//初始化队列 </span></div><div class="line">	L=(LNode*)malloc(sizeof(LNode));				<span class="comment">//分配结点空间 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//分配失败				</span></div><div class="line">        return OVERFLOW;</div><div class="line">     L-&gt;next=NULL;</div><div class="line">     return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">LNode* CreateNode(BTNode *p)&#123;</div><div class="line"><span class="comment">//新建一个结点 </span></div><div class="line">    LNode *q;</div><div class="line">    q=(LNode*)malloc(sizeof(LNode)); 				<span class="comment">//分配结点空间</span></div><div class="line">    <span class="keyword">if</span>(q!=NULL)&#123;                                    <span class="comment">//分配成功 </span></div><div class="line">    	<span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=p;</div><div class="line">       	<span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    &#125;</div><div class="line">   return q;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">Status Enqueue(LNode *p,BTNode *q)&#123; </div><div class="line"><span class="comment">//元素q入队列</span></div><div class="line">    <span class="keyword">if</span>(p==NULL)                                     </div><div class="line">		return ERROR; 								</div><div class="line">    <span class="function"><span class="title">while</span>(p-&gt;</span>next!=NULL)                            <span class="comment">//调至队列最后 </span></div><div class="line">        <span class="function"><span class="title">p</span>=p-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=CreateNode(q);                          <span class="comment">//生成结点让q进入队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"></div><div class="line">Status Dequeue(LNode *p,BTNode *&amp;q)&#123;</div><div class="line"><span class="comment">//出队列，并以q返回值 </span></div><div class="line">	LNode *aq;</div><div class="line">    <span class="function"><span class="title">if</span>(p==NULL||p-&gt;</span>next==NULL) 						<span class="comment">//删除位置不合理 </span></div><div class="line">		return ERROR; </div><div class="line">    <span class="function"><span class="title">aq</span>=p-&gt;</span>next;										<span class="comment">//修改被删结点aq的指针域</span></div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=aq-&gt;</span>next; 								</div><div class="line">    <span class="function"><span class="title">q</span>=aq-&gt;</span><span class="keyword">data</span>;</div><div class="line">    free(aq); 										<span class="comment">//释放结点aq</span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line">Status IfEmpty(LinkList L)&#123;</div><div class="line"><span class="comment">//队列判空 </span></div><div class="line">    <span class="keyword">if</span>(L==NULL) 									<span class="comment">//队列不存在 </span></div><div class="line">		return ERROR;</div><div class="line">    <span class="function"><span class="title">if</span>(L-&gt;</span>next==NULL) 								<span class="comment">//队列为空 </span></div><div class="line">		return TRUE;</div><div class="line">    return FALSE;									<span class="comment">//队列非空 </span></div><div class="line">&#125;</div><div class="line"></div><div class="line">void DestroyQueue(LinkList L)&#123;</div><div class="line"><span class="comment">//销毁队列 </span></div><div class="line">   LinkList p;</div><div class="line">    <span class="keyword">if</span>(L!=NULL)&#123;</div><div class="line">    	p=L;</div><div class="line">       	L=L-&gt;next;</div><div class="line">       	free(p);                                   	<span class="comment">//逐一释放 </span></div><div class="line">        DestroyQueue(L);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status Traverse(BTree t,LinkList L,int newline,int sum)&#123;</div><div class="line"><span class="comment">//用队列遍历输出B树 </span></div><div class="line">    int i;</div><div class="line">    BTree p;</div><div class="line">    <span class="keyword">if</span>(t!=NULL)&#123;</div><div class="line">        printf(<span class="string">"  [ "</span>);</div><div class="line">        E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[<span class="number">0</span>]);                      	<span class="comment">//入队         </span></div><div class="line">        <span class="function"><span class="title">for</span>(i=1;i&lt;=t-&gt;</span>keynum;i++)&#123;</div><div class="line">            <span class="function"><span class="title">printf</span>(" %d ",t-&gt;</span>key[i]);</div><div class="line">            E<span class="function"><span class="title">nqueue</span>(L,t-&gt;</span>ptr[i]);					<span class="comment">//子结点入队 </span></div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="title">sum</span>+=t-&gt;</span>keynum+<span class="number">1</span>;</div><div class="line">        printf(<span class="string">"]"</span>);</div><div class="line">        <span class="keyword">if</span>(newline==<span class="number">0</span>)&#123;                             <span class="comment">//需要另起一行 </span></div><div class="line">        	printf(<span class="string">"\n"</span>);</div><div class="line">            newline=sum-<span class="number">1</span>;</div><div class="line">            sum=<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            newline--;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="keyword">if</span>(IfEmpty(L)==FALSE)&#123;                       	<span class="comment">//l不为空 </span></div><div class="line">         Dequeue(L,p);								<span class="comment">//出队，以p返回 </span></div><div class="line">         Traverse(p,L,newline,sum);					<span class="comment">//遍历出队结点 </span></div><div class="line">     &#125;</div><div class="line">     return OK;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line">Status PrintBTree(BTree t)&#123;</div><div class="line"><span class="comment">//输出B树 </span></div><div class="line">   LinkList L;</div><div class="line">    <span class="keyword">if</span>(t==NULL)&#123;</div><div class="line">        printf(<span class="string">"  B树为空树"</span>);</div><div class="line">        return OK;</div><div class="line">    &#125;</div><div class="line">    InitQueue(L);                        			<span class="comment">//初始化队列 </span></div><div class="line">    Traverse(t,L,<span class="number">0</span>,<span class="number">0</span>);								<span class="comment">//利用队列输出 </span></div><div class="line">    DestroyQueue(L);								<span class="comment">//销毁队列 </span></div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Test1()&#123; </div><div class="line">	system(<span class="string">"color 70"</span>);  </div><div class="line">    BTNode *t=NULL;</div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">    int j,n=<span class="number">15</span>;</div><div class="line">    KeyType k;</div><div class="line">    KeyType a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;;                           </div><div class="line">    printf(<span class="string">"创建一棵%d阶B树:\n"</span>,m);</div><div class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123;								<span class="comment">//逐一插入元素 </span></div><div class="line">        s=SearchBTree(t,a[j]);</div><div class="line">        <span class="keyword">if</span>(s.tag==<span class="number">0</span>)</div><div class="line">            InsertBTree(t,s.i,a[j],s.pt);</div><div class="line">        printf(<span class="string">"   第%d步,插入元素%d:\n "</span>,j+<span class="number">1</span>,a[j]);</div><div class="line">        PrintBTree(t);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"删除操作:\n"</span>);                         	<span class="comment">//删除操作 </span></div><div class="line">    k=<span class="number">9</span>;														</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line"></div><div class="line">    k=<span class="number">1</span>;</div><div class="line">    BTreeDelete(t,k);</div><div class="line">    printf(<span class="string">"  删除%d:\n "</span>,k);</div><div class="line">    printf(<span class="string">"  删除后的B树: \n"</span>);</div><div class="line">    PrintBTree(t);</div><div class="line">    printf(<span class="string">"\n"</span>);</div><div class="line">    </div><div class="line">    printf(<span class="string">"  递归释放B树\n"</span>); 						<span class="comment">//递归释放B树</span></div><div class="line">    DestroyBTree(t);								 </div><div class="line">	PrintBTree(t);</div><div class="line">&#125; </div><div class="line"></div><div class="line">void Test2()&#123;</div><div class="line">	int i,k; </div><div class="line">	system(<span class="string">"color 70"</span>);</div><div class="line">	BTree t=NULL;  </div><div class="line">    Result s;                    					<span class="comment">//设定查找结果 </span></div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</div><div class="line">	printf(<span class="string">"此时的B树：\n"</span>);</div><div class="line">	PrintBTree(t); </div><div class="line">	printf(<span class="string">"\n"</span>);</div><div class="line">    printf(<span class="string">"=============Operation Table=============\n"</span>);</div><div class="line">    printf(<span class="string">"   1.Init     2.Insert    3.Delete    \n"</span>);</div><div class="line">    printf(<span class="string">"   4.Destroy  5.Exit  	  \n"</span>);</div><div class="line">    printf(<span class="string">"=========================================\n"</span>);</div><div class="line">    printf(<span class="string">"Enter number to choose operation:_____\b\b\b"</span>);</div><div class="line">    scanf(<span class="string">"%d"</span>,&amp;i);</div><div class="line">    switch(i)&#123;</div><div class="line">    	case <span class="number">1</span>:&#123;</div><div class="line">			InitBTree(t);</div><div class="line">			printf(<span class="string">"InitBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		</div><div class="line">		case <span class="number">2</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to InsertBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			s=SearchBTree(t,k);</div><div class="line">			InsertBTree(t,s.i,k,s.pt);</div><div class="line">			printf(<span class="string">"InsertBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">3</span>:&#123;</div><div class="line">			printf(<span class="string">"Enter number to DeleteBTree:_____\b\b\b"</span>);</div><div class="line">			scanf(<span class="string">"%d"</span>,&amp;k);</div><div class="line">			BTreeDelete(t,k);</div><div class="line">			printf(<span class="string">"\n"</span>);</div><div class="line">			printf(<span class="string">"DeleteBTree successfully.\n"</span>);</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">		case <span class="number">4</span>:&#123;</div><div class="line">			DestroyBTree(t);</div><div class="line">			break;</div><div class="line">			printf(<span class="string">"DestroyBTree successfully.\n"</span>);</div><div class="line">		&#125;</div><div class="line">		case <span class="number">5</span>:&#123;</div><div class="line">			exit(-<span class="number">1</span>);				</div><div class="line">			break;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	Test2();</div><div class="line">	return <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note success"><p>卡了下代码量<br>521lines<br>Merry christmas！</p></div>]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[B树]]></title>
      <url>/2017/11/29/B%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-B树定义<br>-B树操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>B树定义</strong><br>B树，称为多路平衡查找树。B树中所有结点的孩子结点树的最大值称为B树的阶，通常称为m。</p>
<p>一颗m阶B树或为空树，或为满足以下特性的m叉树：<br>1.树中每个结点至多有m棵子树（至多含有m-1个关键字）<br>2.若根结点不是终端结点，则至少有两颗子树<br>3.除根结点外的所有非叶结点至少有【m/2】棵子树。（至少含有【m/2】-1个关键字）【】是向上取整符号。<br>4.所有的叶结点都出现在同一层次上，并且不带信息</p>
<hr>
<p><strong>B树的查找</strong><br>B树的具体查找步骤如下：<br>1.先让key与根结点中的关键字比较，如果key等于k[i]（k[]为结点内的关键字数组），则查找成功</p>
<p>2.若key &lt; k[1],则到p[0]所指示的子树中进行继续查找</p>
<p>3.若key &gt; k[n],则到p[n]所指示的子树中进行继续查找</p>
<p>4.若k[i] &lt; key &lt;  k [i+1],则到p[i]所指示的子树继续查找</p>
<p>5.如果最后遇到空指针，则证明查找不成功</p>
<hr>
<p><strong>B树的插入</strong></p>
<p>对于关键字的插入，需要找到插入位置。在B树的查找过程中，当遇到空指针时，则证明查找不成功，同时也找到了插入位置，即根据空指针可以确定在最底层非叶结点中的插入位置。</p>
<p>为了方便，称最底层的非叶结点为<strong>终端结点</strong>。由此可见，B树结点的插入总是落在终端结点上。在插入过程中有可能破坏B树的特性，如果新关键字的插入使得结点中关键字的个数超过规定个数，这时要进行<strong>结点的拆分</strong>。</p>
<hr>
<p><strong>B树删除</strong><br>对于关键字的删除，需要找到待删除关键字。在结点中删除关键字的过程中也可能破除B树的特性，如旧关键字的删除可能使得结点中关键字的个数少于规定个数，这时可能需要向其兄弟结点借关键字或者和其孩子结点进行关键字的交换，也可能需要进行结点的合并。其中，和当前结点的孩子结点进行关键字的操作可以保证删除操作总是发生在终端结点上。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速排序]]></title>
      <url>/2017/11/27/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-快速排序算法思想<br>-快速排序算法实现<br>-快速排序性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<div class="note success"><p>算法介绍</p></div>
<p>快速排序是“交换”累的排序，通过多次划分操作实现排序。以升序为例，其执行流程可以概括下：每一趟选择当前所有子序列中的一个关键字（通常是第一个）作为枢轴，将子序列中比枢轴小的移到枢轴前面，比枢轴打的移到枢轴后面；当本趟所有子序列都被枢轴以上述规则划分后会得到新的一组更短的子序列。</p>
<hr>
<p><strong>算法思想</strong><br>选第一个为关键字，从右开始找小于他的交换，再从左找大于它的交换，完成一趟排序。依次类推，多趟排序后使序列有序。</p>
<hr>
<p><strong>算法实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</div><div class="line"><span class="comment">//对从R[low]到R[r]的关键字排序</span></div><div class="line"><span class="keyword">int</span> temp;</div><div class="line"><span class="keyword">int</span> i=low,j=r;</div><div class="line"><span class="keyword">if</span>(low&lt;high)&#123;</div><div class="line">	temp=R[low];</div><div class="line">	<span class="keyword">while</span>(i!=j)&#123;</div><div class="line">		<span class="keyword">while</span>(j&gt;i&amp;&amp;R[i]&gt;=temp)</div><div class="line">			--j;</div><div class="line">		<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">			R[i]=R[j];</div><div class="line">			++i;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;R[i]&lt;temp)</div><div class="line">			++i;</div><div class="line">		</div><div class="line">	<span class="keyword">if</span>(i&lt;j)&#123;</div><div class="line">		R[j]=R[i];</div><div class="line">		--j;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	R[i]=temp;</div><div class="line">	QuickSort(R,low,i<span class="number">-1</span>);</div><div class="line">	QuickSort(R,i+<span class="number">1</span>,high);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>时间复杂度</strong><br>最好情况下，复杂度为O（nlog2n）<br>最坏情况下，复杂度为O（n2）<br>平均情况下，复杂度为O（nlog2n）</p>
<hr>
<p><strong>空间复杂度</strong><br>快速排序是递归进行的，递归需要栈的辅助，算法的空间复杂度为O（log2n）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[冒泡排序]]></title>
      <url>/2017/11/27/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-冒泡排序算法思想<br>-冒泡排序算法实现</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>算法介绍</p></div>
冒泡排序又称起泡排序。它是通过一系列的“交换”动作完成的。首先，第一个关键字和第二个关键字比较，如果第一个大，则二者交换，否则不执行交换；然后第二个关键字和第三个关键字比较，如果第二个大，则执行交换，否则不交换......依次执行下去。第一趟冒泡排序完成，最大的关键字被交换到了最后。经过多趟排序，最终使整个序列有序。

起泡排序算法结束的条件是在一趟排序过程中没有发生关键字交换。

---
<div class="note danger"><p>算法实现</p></div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> R[],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line"> <span class="comment">//默认待排序关键字为整型</span></div><div class="line">	<span class="keyword">int</span> i,j,flag;</div><div class="line">	<span class="keyword">int</span> temp;</div><div class="line">	<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)&#123;</div><div class="line">		flag=<span class="number">0</span>;              <span class="comment">//flag用来标记本趟排序是否发生了交换</span></div><div class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;j++)</div><div class="line">			<span class="keyword">if</span>(R[i<span class="number">-1</span>]&gt;R[i])&#123;</div><div class="line">				temp=R[i];</div><div class="line">				R[i]=R[i<span class="number">-1</span>];</div><div class="line">				R[i<span class="number">-1</span>]=temp;</div><div class="line">				flag=<span class="number">1</span>;</div><div class="line">				&#125;</div><div class="line">			<span class="keyword">if</span>(flag==<span class="number">0</span>)</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div class="note primary"><p>时间复杂度</p></div>
最坏情况下，每趟都要发生交换，复杂度为O（n2）
最好情况下，每一趟只进行循环，不进行交换，复杂度为O（n）
平均时间下时间复杂度为O（n2）

---
<div class="note default"><p>空间复杂度</p></div>
<p>由算法可知，额外辅助空间只有一个temp，因此空间复杂度为O（1）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/11/26/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-希尔排序算法思想</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>算法介绍</p></div>
希尔排序又叫做缩小增量排序，其本质还是插入排序，只不过是将待排序序列按照某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。这个规则的体现就是增量的选取，如果增量为1，就是直接排序。

增量是逐渐减小的。直接插入排序适合于序列基本有序的情况，希尔排序的每趟排序都会使整个序列变得更加有序，等整个序列基本又虚了，再进行一次直接插入排序，这样会使排序效率更高，这就是希尔排序的思想。

---
<div class="note danger"><p>时间复杂度</p></div>
<p>希尔排序的时间复杂度和增量选取有关，希尔排序的增量选取规则有很多，常见的增量选取规则有以下两个。<br>1.希尔自己提出的选取规则：<br>[n/2],[n/4],…,2,1<br>每次将增量除2向下取整，其中n为序列长度，此时时间复杂度为O（n2）</p>
<p>2.帕佩尔诺夫和斯塔舍维奇提出的选取规则：<br>2的k次方+1,…,65,33,17,9,5,3,1<br>其中，k为大于等于1的整数，2的k次方小于待排序列长度，增量序列末尾的1是额外添加的。此时时间复杂度为O(n1.5)</p>
<hr>
<div class="note primary"><p>空间复杂度</p></div>
<p>希尔排序的空间复杂度同直接插入排序一样，为O（1）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-3]]></title>
      <url>/2017/11/26/Verilog%20HDL-3/</url>
      <content type="html"><![CDATA[<p>-模块与端口</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>模块的组成</p></div>
模块是Verilog HDL设计中的基本功能块，用于描述某个设计的功能或结构，以及它与其他模块进行通信的端口。端口是模块与外部环境交互的接口和通道。

模块定义说明：
1.模块以关键字module开始，并以关键字endmodule结束
2.模块名、端口列表、端口声明和可选的参数声明必须出现在其他部分前面；同样地，为了使模块描述清晰和具有良好的可读性，变量、寄存器、线网和参数等的声明部分必须在使用前出现，放在任何语句的前面。
3.端口是模块和外部环境交互的通道，一个模块可以没有端口
4.模块内部有5个组成部分：变量声明、数据流语句、地层模块实例、行为语句以及任务和函数。
5.对于模块的定义只有关键字module、endmodule和模块名是必须的，其他都是可选的
6.一个Verilog源文件可以包含多个模块，而且对于模块的排列没有要求

---
<div class="note danger"><p>模块的端口定义</p></div>
<p>在模块名的后面紧跟着的就是端口列表，如果模块和外界没有任何交互信号，也可以没有端口列表。</p>
<p>端口列表中的所有端口都必须在模块中进行声明，根据端口的流动方向，端口分为input(输入)、output(输出)和inout(输入/输出双向)三种类型。</p>
<p>所有端口默认的声明为wire型，如果希望输出端口能够保存数据，那就需要显式地将端口声明为reg型；不能将input端口和inout端口设为reg型，因为reg型式用于保存数据的，而输入端口用来反映外界数据的变化，并不可以进行保存。</p>
<hr>
<div class="note primary"><p>模块的调用</p></div>
<p>模块调用语法：<br>模块名    实例名（端口连接关系表）<br>·“模块名”是模块定义的（紧接着module关键字）名称<br>·“实例名”是所调用模块的实例名称<br>·“端口连接关系表”用于说明该模块实例端口所连接的外部信号，它指明了模块实例和外界的连接关系</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-2]]></title>
      <url>/2017/11/26/Verilog%20HDL-2/</url>
      <content type="html"><![CDATA[<p>-基本知识</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note warning"><p>标识符</p></div> 
Verilog HDL中的标识符可以是任意一组字母、数字、$符号和_（下划线）符号的组合。标识符是区分大小写的，第一个字符必须是字母或者下划线，不能以数字和$符号开始。例如:Max,MIN,Four$,_Y2011.

---
<div class="note primary"><p>关键字</p></div> 
<p>关键字时Verilog HDL中预留的表示特定含义的保留标识符，Verilog HDL中的关键字全部是小写的。<br>例如：BEGIN（非关键字）与begin（关键字）是不同的</p>
<hr>
<div class="note danger"><p>注释</p></div>
Verilog HDL有两种形式的注释
风格与C语言一样

---
<div class="note default"><p>编写格式</p></div>
<p>Verilog HDL是自由格式的，代码可以在一行内编写，也可以跨越多行编写。空格、制表符和空白行没有意义。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//举例</span></div><div class="line">initial  begin  pa=<span class="number">0</span>;pb=<span class="number">0</span>;pCin=<span class="number">0</span>;  end</div><div class="line"><span class="comment">//上面代码与下面的是一样的</span></div><div class="line">initial </div><div class="line">	begin</div><div class="line">		pa=<span class="number">0</span>;</div><div class="line">		pb=<span class="number">0</span>;</div><div class="line">		pCin=<span class="number">0</span>;</div><div class="line">	end</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Verilog HDL-1]]></title>
      <url>/2017/11/26/Verilog%20HDL-1/</url>
      <content type="html"><![CDATA[<p>-风格描述介绍<br>-测试平台的编写</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>门级风格的描述</p></div> 
<pre><code>数据流风格描述方式是最常用的一种风格，用数据流描述方式对一个设计建模的最基本机制就是使用连续赋值语句。在连续赋值语句中，线网类型变量被赋予某个值，右边表达式的操作时无论何时发生变化，表达式都要重新计算，计算结果被赋予左边表达式的线网类型变量。
</code></pre>

---
<div class="note warning"><p>数据流风格的描述</p></div> 
<pre><code>数据流风格描述方式是最常用的一种风格，用数据流描述方式对一个设计建模的最基本机制就是使用连续赋值语句。在连续赋值语句中，线网类型变量被赋予某个值，右边表达式的操作时无论何时发生变化，表达式都要重新计算，计算结果被赋予左边表达式的线网类型变量。
</code></pre><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">module</span> mux<span class="number">_f</span>low(<span class="keyword">out</span>,a,b,sel);</div><div class="line">	input a,b,sel;</div><div class="line">	output <span class="keyword">out</span>;</div><div class="line">	<span class="keyword">assign</span> <span class="keyword">out</span>=(sel)?b:a;      <span class="comment">//连续赋值</span></div><div class="line">endmodule</div></pre></td></tr></table></figure>
<hr>
<div class="note primary"><p>行为风格的描述</p></div> 
行为风格使用initial语句（语句只执行一次）和always语句（重复执行），只有变量类型数据能够在这两种语句中被赋值，所有initial语句和always语句在0时刻开始并发执行
undefined

---
<div class="note danger"><p>测试平台的编写</p></div> 
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">module testMux;</div><div class="line">	reg pa,pb,psel;</div><div class="line">	wire pout;</div><div class="line">	mux_beha tmux(pout,pa,pb,psel);      <span class="comment">//调用</span></div><div class="line"></div><div class="line">   initial</div><div class="line">	   begin</div><div class="line">		   pa=<span class="number">0</span>;pb=<span class="number">0</span>;psel=<span class="number">0</span>;<span class="comment">//赋初值</span></div><div class="line">		   #<span class="number">5</span> pa=<span class="number">1</span>;  <span class="comment">//五个单位时间延迟后进行赋值</span></div><div class="line">		   #<span class="number">5</span> pb=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">0</span>;</div><div class="line">		   #<span class="number">5</span> psel=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">1</span>;</div><div class="line">		   #<span class="number">5</span> pb=<span class="number">0</span>;</div><div class="line">		   #<span class="number">5</span> pa=<span class="number">0</span>;</div><div class="line">		end</div><div class="line"> </div><div class="line"> initial</div><div class="line">	 $monitor(<span class="string">"time=%t,a=%b.b=%b,sel=%b,out=%b"</span>,$time,pa,pb,psel,pout);</div><div class="line">	 <span class="comment">//调用系统任务$monitor，当pa、pb、psel、pout中任一个发生变化时就输出显示</span></div><div class="line">endmodule</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Verilog HDL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-6]]></title>
      <url>/2017/11/26/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-6<br>-广义表部分</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>/<strong><strong>**</strong></strong><br>【题目】试按依次对每个元素递归分解的分析方法重写求广义表的深度的递归算法。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> GListDepth(GList <span class="keyword">ls</span>)</div><div class="line"><span class="comment">/* Return the depth of list */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> h1,h2;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">ls</span>==NULL)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">ls</span>-&gt;tag==ATOM)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    h1=GListDepth(<span class="keyword">ls</span>-&gt;un.ptr.hp)+<span class="number">1</span>;</div><div class="line">    h2=GListDepth(<span class="keyword">ls</span>-&gt;un.ptr.tp);</div><div class="line">    <span class="keyword">return</span> h1&gt;h2?h1:h2;</div><div class="line">              </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写判别两个广义表是否相等的递归算法。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Status Equal(GList A, GList B)</div><div class="line"><span class="comment">/* 判断广义表A和B是否相等,是则返回TRUE,否则返回FALSE */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(A-&gt;tag==ATOM&amp;&amp;B-&gt;tag==ATOM)</div><div class="line">        <span class="keyword">if</span>(A-&gt;un.atom==B-&gt;un.atom)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(A-&gt;tag==<span class="keyword">LIST</span>&amp;&amp;B-&gt;tag==<span class="keyword">LIST</span>)</div><div class="line">        <span class="keyword">if</span>(Equal(A-&gt;un.ptr.hp,B-&gt;un.ptr.hp)&amp;&amp;Equal(A-&gt;un.ptr.tp,B-&gt;un.ptr.tp))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">FALSE</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写递归算法，输出广义表中所有原子项及其所在层次。<br>广义表类型GList的定义：<br>typedef enum {ATOM,LIST} ElemTag;<br>typedef struct GLNode{<br>     ElemTag tag;<br>     union {<br>       char atom;<br>       struct {<br>         GLNode <em>hp, </em>tp;<br>       } ptr;<br>     }un;<br>} <em>GList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void OutAtom<span class="comment">(GList A, int layer, void(*Out2)</span><span class="comment">(char, int)</span>)</div><div class="line"><span class="comment">/* 递归地用函数Out2输出广义表的原子及其所在层次,layer表示当前层次 */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span><span class="comment">(A)</span>&#123;</div><div class="line">        <span class="keyword">if</span><span class="comment">(A-&gt;tag==ATOM)</span></div><div class="line">            Out<span class="number">2</span><span class="comment">(A-&gt;un.atom,layer)</span>;</div><div class="line">        else&#123;</div><div class="line">            OutAtom<span class="comment">(A-&gt;un.ptr.hp,layer+1,Out2)</span>;</div><div class="line">            OutAtom<span class="comment">(A-&gt;un.ptr.tp,layer,Out2)</span>;</div><div class="line">        &#125;</div><div class="line">   &#125;         </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[折半插入排序]]></title>
      <url>/2017/11/26/%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p>-折半插入算法介绍</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>折半插入排序</p></div>
<p>如果线性表是有序的，进行查找可以用折半查找来实现。在确定出待插入位置后，就可以统一的向后移动元素了。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line">	int i,j,low,high,mid;</div><div class="line">	for(i=<span class="number">2</span>;i&lt;=n;i++)&#123;           <span class="comment">//依次将A[2]~A[n]插入到前面已排好序的序列中</span></div><div class="line">		A[<span class="number">0</span>]=A[i];               <span class="comment">//将A[i]暂存到A[0]</span></div><div class="line">		low=<span class="number">1</span>;</div><div class="line">		high=i<span class="number">-1</span>;                <span class="comment">//设置查找范围</span></div><div class="line">		while(low&lt;=high)&#123;</div><div class="line">			mid=(low+high)/<span class="number">2</span>;    <span class="comment">//去中间点</span></div><div class="line">			if(A.[mid].<span class="type">key</span>&gt;A[<span class="number">0</span>].<span class="type">key</span>)</div><div class="line">				high=mid<span class="number">-1</span>;      <span class="comment">//查询左子表</span></div><div class="line">				else</div><div class="line">					low=mid+<span class="number">1</span>;   <span class="comment">//查询右子表</span></div><div class="line">			&#125;</div><div class="line">		for(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</div><div class="line">			A[j+<span class="number">1</span>]=A[j];         <span class="comment">//统一后移元素，空出插入位置</span></div><div class="line">		A[high+<span class="number">1</span>]=A[<span class="number">0</span>];          <span class="comment">//插入操作</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述算法中，不难看出折半插入排序仅仅是减少了比较元素的次数，约为O（nlog2n），该比较次数与待排序表的初始状态无关，仅取决于表中元素个数n；而元素的移动次数没有改变，它取决于待排序表的初始状态。因此，折半插入排序的时间复杂度仍为O（n2）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[直接插入排序]]></title>
      <url>/2017/11/23/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1/</url>
      <content type="html"><![CDATA[<p>-直接插入排序算法简介<br>-直接插入排序算法分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>插入排序</p></div>
<p>插入排序是一种简单直观的排序方法，其基本思想在于每次将一个待排序的记录，按其关键字大小插入到前面已经排序的子序列中，知道全部记录插入完成。</p>
<hr>
<p><strong>直接插入排序</strong><br>为了实现将元素L(i)插入到已有序的子序列L[1…i-1]，需要执行以下操作：<br>1.查找出L(i)在L[1…i-1]中的插入位置k<br>2.将L[k…i-1]中所有元素全部后移一个位置<br>3.将L[i]复制到L[k]</p>
<p>为了实现排序，将L(2)~L(n)依次插入到前面已排好序的子序列中，初始假定L[1]是一个已排好序的子序列。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void InsertSort(ElemType A[],int n)&#123;</div><div class="line"><span class="comment">//直接插入排序算法</span></div><div class="line">	int i,j;</div><div class="line">	for(i=<span class="number">2</span>;i&lt;=n;i++)             <span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></div><div class="line">		if(A[i].<span class="type">key</span>&lt;A[i<span class="number">-1</span>].<span class="type">key</span>)&#123;  <span class="comment">//若A[i]的关键码小于其前驱，需将A[i]插入到有序表</span></div><div class="line">			A[<span class="number">0</span>]=A[i];            <span class="comment">//复制为哨兵</span></div><div class="line">			for(j=i<span class="number">-1</span>;A[<span class="number">0</span>].<span class="type">key</span>&lt;A[j].<span class="type">key</span>;--j)  <span class="comment">//从后往前查找待插入位置</span></div><div class="line">				A[j+<span class="number">1</span>]=A[j];      <span class="comment">//复制到插入位置</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>性能分析</strong><br>空间效率：使用了常数个辅助单元，空间复杂度为O（1）<br>时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了n-1趟，每趟操作都分为比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。<br>在最好的情况下，表中元素已经有序，每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为O（n）<br>在最坏的情况下，表中顺序刚好与排序结果中元素顺序相反时，总的比较次数达到最大，为2+3+…+n，总的移动次数也达到最大，3+4+…+n+1.<br>平均情况下，考虑待排序表中的元素是随机的，此时可以取上述最好与最坏情况的平均值作为平均情况下的时间复杂度，总的比较次数与移动次数约为n2/4.</p>
<p>由此，直接插入排序算法的时间复杂度为O（n2）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序]]></title>
      <url>/2017/11/22/%E6%8E%92%E5%BA%8F-1/</url>
      <content type="html"><![CDATA[<p>-排序简介</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><div class="note success"><p>排序</p></div>
<p>排序就是重新排列表中的元素，使表中的元素满足按关键字递增或递减的过程</p>
<hr>
<div class="note danger"><p>算法稳定性</p></div>
<p>如果待排序表中有两个元素Ri、Rj，其对应关键字keyi=keyj，且在排序前Ri在Rj的前面，如果使用某一排序算法后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的<br>算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述</p>
<hr>
<div class="note info"><p>内部排序</p></div>
<p>指在排序期间元素全部存放在内存中的排序</p>
<hr>
<div class="note primary"><p>外部排序</p></div>
<p>指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并查集]]></title>
      <url>/2017/11/22/%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8--%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>-并查集的基本操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>并查集的操作</strong><br>并查集是一种简单的集合表示，它支持一下三种操作：<br>1.Union(S,Root1,Root2)：把集合S中的子集合Root2并入子集合Root1中。要求Root1和Root2互不相交，否则不执行合并。<br>2.Find(S,x)：查找集合S中单元素x所在的子集合，并返回该子集合的名字。<br>3.Initial(S)：将集合S中每一个元素都初始化为只有一个单元素的子集合。</p>
<p>通常用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示。所有表示子集合的树，构成表示全集合的树，存放在双亲表示数组内。通常用数组元素的下标代表元素名，根结点的下标代表子集合名，根结点的双亲结点为负数。</p>
<hr>
<p>为了得到两个子集合的并，只要将其中一个子集合根结点的双亲之争指向另一个集合的根结点即可。<br>在采用树的双亲指针表示作为并查集的存储表示时，集合元素编号从0到size-1，其中size是最大元素的个数</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//并查集的结构定义</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 100</span></div><div class="line"><span class="keyword">int</span> UFSets[SIZE];            <span class="comment">//集合元素数组（双亲指针数组）</span></div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//并查集的初始化操作</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)        <span class="comment">//每个自成单元素集合</span></div><div class="line">		S[i]=<span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Find操作（函数在并查集S中查找并返回包含元素x的树的根）</span></div><div class="line"><span class="keyword">Int</span> <span class="keyword">Find</span>(<span class="keyword">int</span> S[],<span class="keyword">int</span> x)&#123;</div><div class="line">	<span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)         <span class="comment">//循环查找x的根</span></div><div class="line">		x=S[x];</div><div class="line">	<span class="keyword">return</span> x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Union操作(函数求两个不相交子集合的并集)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[],<span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2)</span></span>&#123;</div><div class="line">	<span class="comment">//要求Root1与Root2是不同的，且表示子集合的名字</span></div><div class="line">	S[Root2]=Root1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树、森林与二叉树的转换]]></title>
      <url>/2017/11/22/%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>-树型结构的相互转换</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p>由于二叉树和树都可以用二叉链表作为存储结构，则以二叉链表作为媒介可以导出树与二叉树的一个对应关系，即给定一棵树，可以找到唯一的一颗二叉树与之对应。从物理结构上看，树的孩子兄弟表示法语二叉树的二叉链表表示法相同，即每个结点共有两个指针，分别指向结点第一个孩子和结点的下一兄弟结点，而二叉链表使用双指针。因此，就可以用同一存储结构的不同解释将一棵树转换为二叉树。</p>
<hr>
<p><strong>树转换成二叉树</strong><br>每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为“左孩子右兄弟”。由于根结点没有兄弟，所以，由树转换而得的二叉树没有右子树。</p>
<p><img src="http://img.blog.csdn.net/20171122094256947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><strong>森林转换成二叉树</strong><br>将森林转换成二叉树的规则与树类似。先将森林中的每一棵树转换成二叉树，再将第一棵树的根作为转换后的二叉树的根，第一棵树的左子树作为转换后二叉树根的左子树，第二棵树作为转换后二叉树根的右子树，第三棵树作为转换后二叉树根的右子树的右子树，以此类推。</p>
<hr>
<p><strong>二叉树转换成森林</strong><br>若二叉树非空，则二叉树根及其左子树为第一棵树的二叉树形式，二叉树根的右子树可以看作是一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后产生一颗没有右子树的二叉树为止，这样就得到了原森林。</p>
<hr>
<p><strong>树转换成二叉树的画法</strong><br>1.在兄弟结点之前加一连线<br>2.对每一个结点，只保留它与第一个子结点的连线，与其他子结点的连线全部抹掉<br>3.以树根为轴心，顺时针旋转45</p>
<hr>
<p><strong>森林转换成二叉树的画法</strong><br>1.将每棵树的根相连<br>2.将森林中的每棵树转换成相应的二叉树<br>3.以第一棵树的根为轴心顺时针旋转45</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树与森林]]></title>
      <url>/2017/11/21/%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97/</url>
      <content type="html"><![CDATA[<p>-树的存储结构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>树的存储结构</strong><br>树的存储方式有多种，可以采用顺序存储结构，也可以采用链式存储结构。</p>
<hr>
<p><strong>双亲表示法</strong><br>这种存储方式采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br><img src="http://img.blog.csdn.net/20171121224128464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//双亲表示法的存储结构</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100            <span class="comment">//树中最多结点数</span></span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                      <span class="comment">//树中结点定义</span></div><div class="line">	ElemType data;                   <span class="comment">//数据元素</span></div><div class="line">	<span class="keyword">int</span> parent;                      <span class="comment">//双亲位置域</span></div><div class="line">&#125;PTNode;</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                     <span class="comment">//树类型的定义</span></div><div class="line">	PTNode nodes[MAX_TREE_SIZE];    <span class="comment">//双亲表示</span></div><div class="line">	<span class="keyword">int</span> n;                          <span class="comment">//结点数</span></div><div class="line">&#125;PTree;</div></pre></td></tr></table></figure>
<hr>
<p><strong>孩子表示法</strong><br>孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，则N个结点就有N个孩子结点（叶子结点的孩子链表为空表）<br>对于这种存储方式寻找子女的操作非常直接，但是寻找双亲的操作需要遍历N个结点中孩子链表指针域所指向的N个孩子链表。</p>
<hr>
<p><strong>孩子兄弟表示法</strong><br>孩子兄弟表示法又称为二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针。<img src="http://img.blog.csdn.net/20171121231935558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//孩子兄弟表示法的存储结构描述如下：</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></div><div class="line">	ElemType data;                           <span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>  <span class="comment">//第一个孩子和右兄弟指针</span></div><div class="line">&#125;CSNode,*CSTree;</div></pre></td></tr></table></figure>
<p>这种存储表示法灵活，最大优点是可以方便的将树转换为二叉树，易于查找结点的孩子等，但缺点是从当前结点寻找其双亲结点比较麻烦。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[平衡二叉树]]></title>
      <url>/2017/11/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-平衡二叉树及调整规律</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>平衡二叉树的定义</strong><br>为了避免树的高度增长过快，降低二叉排序树的性能，规定在插入和删除二叉树结点时，要保证任意结点的左右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树，简称平衡树(AVL树)。</p>
<p><strong>平衡因子</strong><br>定义结点的左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子只可能为-1,0,1。</p>
<hr>
<p><strong>平衡二叉树的插入</strong><br>二叉排序树保证平衡的基本思想：每当在二叉排序树中插入（或删除）一个结点时，首先要检查其插入路径上的结点是否因为此次操作导致了不平衡。如果导致了不平衡，则先要找到插入路径上离插入结点最近的平衡因子绝对值大于1的结点，再对A为根的子树，在保持二叉排序树特性的前提下，调整各结点的位置关系，使之重新达到平衡。</p>
<hr>
<p><strong>失衡调整规律</strong><br>1.LL平衡旋转（右单旋转）<br>由于在结点A的左孩子B（L）的左子树BL（L）上插入了新结点，该结点的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行一次向右的旋转操作。<br>将A的左孩子向右上旋转成为根结点，将A结点向右下旋转称为B的右子树的根结点，而B的原右子树BR成为A结点的左子树。</p>
<p>2.RR平衡旋转<br>由于在结点A的右孩子B（R）的右子树BR（R）上插入了新结点，A的平衡因子由-1减至-2，导致以A为根的子树失去平衡，需要进行一次向左的旋转操作。<br>将A的右孩子B向左上旋转成为根结点，将A结点向左下旋转成为B的左子树根结点，将B的原左子树作为A结点的右子树。</p>
<p>3.LR平衡旋转（先左后右双旋转）<br>由于在A的左孩子B（L）的右子树BR（R）上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行两次旋转操作，先左旋转后右旋转。<br>先将A的左孩子B的右子树的根结点向左上旋转到B结点的位置，然后再把该C结点向右上旋转提升到A结点的位置。</p>
<p>4.RL平衡旋转（先右后左双旋转）<br>由于在A的右孩子（R）的左子树（L）上插入新结点，A的平衡因子由-1减至-2，导致导致以A为根的子树失去平衡，需要进行两次旋转操作，先右旋转后左旋转。<br>先将A结点的右孩子B的左子树的根结点C向右上旋转提升至B结点的位置，然后再把该C结点向左上旋转到A的位置。<br><img src="http://img.blog.csdn.net/20171121131347624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<hr>
<p><strong>平衡二叉树的查找</strong><br>在平衡二叉树上进行查找的过程和二叉排序树相同，因此，在查找的过程中和给定值进行比较的关键字个数不超过树的深度。假设以Nh表示深度为h的平衡树中含有的最少结点树。显然，N0=1，N1=1,N2=2，并且有Nh=Nh-1+Nh-2+1.可以证明含有n个结点平衡二叉树的最大深度为log2n，因此，平衡二叉树的平均查找长度为O(log2n).</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++数据类型]]></title>
      <url>/2017/11/20/C++%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>-接近拖了一个月了才继续…</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><hr>
<p><strong>变量名命名规则</strong><br>·在名称中只能使用字母字符、数字和下划线（_）<br>·名称的第一个字符不能是数字<br>·区分大写字符与小写字符<br>·不能将C++关键字用作名称<br>·以两个下划线或下划线和大写字母打头的名称全部被保留给实现<br>·C++对于名称的长度没有限制</p>
<hr>
<p><strong>整型</strong><br>C++的基本整型有char，short，int，long和long long</p>
<p>C++提供了一种灵活的标准，它确保了最小长度：<br>·short至少16位<br>·int至少与short一样长<br>·long至少32位，且至少与int一样长<br>·long long至少64位，且至少与long一样长</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明变量</span></div><div class="line"><span class="keyword">short</span> score;</div><div class="line"><span class="keyword">int</span> temperature;</div><div class="line"><span class="keyword">long</span> <span class="built_in">position</span>;</div></pre></td></tr></table></figure>
<p>sizeof运算符可以用来返回类型或变量的长度</p>
<hr>
<p><strong>变量初始化</strong><br>初始化将赋值与声明合并在一起<br>可以将变量初始化成字面值，可以将变量初始化为另一个变量，条件是后者已经被定义过<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">int uncles</span>=5;</div><div class="line"><span class="attribute">int aunts</span>=uncles;</div><div class="line"><span class="attribute">int chairs</span>=aunts+uncles+4;</div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++初始化方式</span></div><div class="line"><span class="keyword">int</span> hamburgers=&#123;<span class="number">24</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">wren</span><span class="params">(<span class="number">432</span>)</span></span>;</div></pre></td></tr></table></figure>
<hr>
<p><strong>无符号类型</strong><br>要创建无符号版本的基本整型，只需在关键词unsigned来修改声明即可</p>
<hr>
<p><strong>char类型</strong><br>char类型是专为存储字符而设计的<br>char最常被用来处理字符，但也可以用做比short更小的整型</p>
<p>cout.put()函数可以用来输出单个字符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">'s'</span>;     <span class="comment">//输出s字符对应的整数值</span></div><div class="line"><span class="built_in">cout</span>.put(<span class="string">'s'</span>);    <span class="comment">//输出s字符</span></div></pre></td></tr></table></figure>
<hr>
<p><strong>bool类型</strong><br>bool类型用来表示真和假<br>字面值true和false可以通过提升转换为int类型，true被转换为1，而false被转换为0<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ans=<span class="literal">true</span>;        <span class="comment">//1</span></div><div class="line"><span class="keyword">int</span> promise=<span class="literal">false</span>;   <span class="comment">//0</span></div><div class="line"><span class="keyword">bool</span> start=<span class="number">-100</span>;     <span class="comment">//true</span></div><div class="line"><span class="keyword">bool</span> stop=<span class="number">0</span>;         <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>const限定符</strong><br>与#define类似，const也是用来处理符号常量<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> months=<span class="number">12</span>;</div><div class="line"><span class="comment">//months是int类型常量12</span></div><div class="line"><span class="comment">//无法修改</span></div></pre></td></tr></table></figure></p>
<hr>
<p><strong>浮点数</strong><br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//书写浮点数的方式</span></div><div class="line">double a=<span class="number">12.34</span>;</div><div class="line">dounle b=<span class="number">2.52e+8</span>;</div></pre></td></tr></table></figure></p>
<p>C++有三种浮点类型：float,duble,long double.<br>通常float为32位，double为64位</p>
<p>在默认情况下，浮点常量属于double类型。希望常量为float类型，则使用f或F后缀。对于long double类型，使用l或L后缀</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉排序树]]></title>
      <url>/2017/11/20/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-二叉排序树的基本操作</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉排序树的定义</strong><br>二叉排序树，也称为二叉查找树。<br>二叉排序树要么是空树，要么是具有以下特征的非空二叉树：<br>·若左子树非空，则左子树上所有结点关键字值均小于根结点的关键字值<br>·若右子树非空，则右子树上所有结点关键字值均大于根结点的关键字值<br>·左右子树本身也是一颗二叉排序树</p>
<p>根据二叉排序树的定义，有左子树结点值&lt;根结点值&lt;右子树结点值<br>因此，如果对二叉排序树进行中序遍历，可以得到一个递增的序列</p>
<hr>
<p><strong>二叉排序树的查找</strong><br>二叉排序树的查找是从根结点开始，沿某一个分支逐层向下进行比较的过程。若二叉排序树非空，将给定值与根结点的关键字比较，若相等，则查找成功；若不等，则当根结点的关键字大于给定关键字时，在根结点的左子树中查找，否则在根结点的右子树中查找。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//二叉排序树的非递归查找算法</div><div class="line">BSTNode *BST_Search(BiTree <span class="literal">T</span>,ElemType key,BSTNode *&amp;p)&#123;</div><div class="line">	//查找函数返回指向关键字为key的节点指针，若不存在，则返回<span class="literal">NULL</span></div><div class="line">	p=<span class="literal">NULL</span>;</div><div class="line"><span class="keyword">while</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>&amp;&amp;key!=<span class="literal">T</span>-&gt;data)&#123;</div><div class="line">		p=<span class="literal">T</span>;</div><div class="line">		<span class="keyword">if</span>(key&lt;<span class="literal">T</span>-&gt;data)</div><div class="line">			<span class="literal">T</span>=<span class="literal">T</span>-&gt;lchild;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="literal">T</span>=<span class="literal">T</span>-&gt;rchild;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">T</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的插入</strong><br>二叉树作为一种动态集合，其特点是树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字等于给定值的结点时再进行插入<br>由于二叉排序树是递归定义，插入结点的过程是，若原二叉排序树为空，则直接插入结点。若关键字k小于根结点关键字，则插入到左子树中，若关键字k大于根结点关键字，则插入到右结点中。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int BST_Insert(BiTree &amp;<span class="literal">T</span>,KeyType k)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="literal">T</span>==<span class="literal">NULL</span>)&#123;</div><div class="line">		<span class="literal">T</span>=(BiTree)malloc(sizeof(BSTNode));</div><div class="line">		<span class="literal">T</span>-&gt;data=k;</div><div class="line">		<span class="literal">T</span>-&gt;lchild=<span class="literal">T</span>-&gt;rchild=<span class="literal">NULL</span>;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	<span class="keyword">else</span>	<span class="keyword">if</span>(<span class="literal">T</span>-&gt;data=k)</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">T</span>-&gt;data&gt;k)    //左子树中插入</div><div class="line">		<span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;lchild,k);</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">T</span>-&gt;data&lt;k)   //右子树中插入</div><div class="line">		<span class="keyword">return</span> BST_Insert(<span class="literal">T</span>-&gt;rchild,k);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的构造</strong><br>构造一颗二叉排序树就是依次输入数据元素，并将它们插入到二叉排序树中的适当位置上的过程。具体过程是，每读入一个元素，就建立一个结点，若二叉排序树非空，则将新节点的值与根结点的比较，如果小于根结点，插入到左子树中，否则插入到右子树中；<br>若二叉排序树为空，则新节点作为二叉排序树的根结点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create_BST</span><span class="params">(BiTree &amp;T,KeyTypestr [],<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">	<span class="comment">//用关键字数组str [] 建立一个二叉排序树</span></div><div class="line">	T=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(i&lt;n)&#123;   <span class="comment">//依次读入元素</span></div><div class="line">		BST_Insert(T,str[i]);</div><div class="line">		i++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p><strong>二叉排序树的删除</strong><br>删除操作有三种情况：<br>1.如果被删除结点z是叶结点，直接进行删除操作即可<br>2.如果结点z只有一颗左子树或右子树，则让z的子树成为z父结点的子树<br>3.如果结点z有左右两颗子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删除这个直接后继（或直接前驱），转换成第一或第二种情况。（中序遍历的下一个）（不断取左子树的最大或者右子树的最小递归删除）</p>
<hr>
<p><strong>二叉排序树的查找效率分析</strong><br>对于高度为H的二叉排序树，其插入和删除操作的运行时间都是O(H).<br>但在最坏的情况下，即构造二叉排序树的输入序列是有序的，则会形成一个倾斜的二叉树，高度也增加为元素个数N</p>
<p>二叉排序树查找算法的平均查找长度，主要取决于树的高度，即与二叉树的形态有关。<br>如果二叉排序树是只有左（右）孩子的二叉树，算法复杂度为O(n).如果是平衡二叉树，算法复杂度为O（log2n）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线索二叉树]]></title>
      <url>/2017/11/13/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-6天回归战场<br>-希望有个好成绩吧</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>线索二叉树基本概念</strong><br>二叉树的遍历就是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到，二叉树结点的各种遍历序列。二叉树遍历的实质就是对一个非线性结构进行线性化操作，使在这个访问序列中每一个结点（除第一个和最后一个）都有一个直接前驱和直接后继。<br>传统的链式存储只能体现一种父子关系，不能直接得到结点在遍历中的前驱或后继。通过观察，我们发现在二叉链表表示的二叉树中存在大量的空指针，若利用这些空链域存放指向其直接前驱或后继的指针，便可以更方便地运用某些二叉树的操作算法。引入线索二叉树是为了加快查找结点前驱和后继的速度。</p>
<p><strong>在有N个结点的二叉树中，有N+1个空指针。</strong>这是因为每一个叶子结点有两个空指针，而每一个度为1的结点有一个空指针，总计2N0+N1，又有N0=N2+1，所以，总的空指针为N+1.</p>
<hr>
<p><strong>线索化</strong><br>在二叉树线索化时，通常规定：若无左子树，令lchild指向其前驱结点；若无右结点，令rchild指向其后继结点。因此，需要增加两个标志域表明当前指针域所指对象是指向左（右）子结点还是直接前驱（后继）。</p>
<p><img src="http://img.blog.csdn.net/20171113114056883" alt="这里写图片描述"><br>其中标志域的含义：<br>ltag=0 时lchild指向左子女；<br>ltag=1 时lchild指向前驱；<br>rtag=0 时rchild指向右子女；<br>rtag=1 时rchild指向后继；</p>
<p>线索二叉树的存储结构描述如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></div><div class="line">	ElemType data;                       <span class="comment">//数据元素</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>   <span class="comment">//左、右孩子指针</span></div><div class="line">	<span class="keyword">int</span> ltag,rtag;                       <span class="comment">//左右线索标志</span></div><div class="line">&#125;ThreadNode,*ThreadTree;</div></pre></td></tr></table></figure></p>
<p>以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做<strong>线索链表</strong>，其中指向结点前驱和后继的指针，叫做<strong>线索</strong>。加上线索的二叉树称为<strong>线索二叉树</strong>。对二叉树以某种次序遍历使其变为线索二叉树的过程称为<strong>线索化</strong>。</p>
<hr>
<p><strong>线索二叉树的构造</strong><br>对二叉树的线索化，实质上就是遍历一次二叉树，在遍历过程中，检查当前结点左、右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。</p>
<p>通过中序遍历对二叉树线索化的递归算法如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void InThread(ThreadTree &amp;p,ThreadTree &amp;pre)&#123;</div><div class="line">	<span class="comment">//中序遍历对二叉树线索化的递归算法</span></div><div class="line">		<span class="keyword">if</span>(p!=NULL)&#123;</div><div class="line">			I<span class="function"><span class="title">nThread</span>(p-&gt;</span>lchild,pre);       <span class="comment">//递归，线索化左子树</span></div><div class="line"> 			<span class="function"><span class="title">if</span>(p-&gt;</span>lchild==NULL)&#123;           <span class="comment">//左子树为空，建立前驱线索</span></div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span>lchild=pre;</div><div class="line">				<span class="function"><span class="title">p</span>-&gt;</span>ltag=<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="title">if</span>(pre!=NULL&amp;&amp;pre-&gt;</span>rchild==NULL)&#123;</div><div class="line">				<span class="function"><span class="title">pre</span>-&gt;</span>rchild=p;             <span class="comment">//建立前驱结点的后继线索</span></div><div class="line">				<span class="function"><span class="title">pre</span>-&gt;</span>rtag=<span class="number">1</span>;               </div><div class="line">			&#125;</div><div class="line">			pre=p;                         <span class="comment">//标记当前结点称为刚刚访问过的结点</span></div><div class="line">			I<span class="function"><span class="title">nThread</span>(p-&gt;</span>rchild,pre);       <span class="comment">//递归，线索化右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过中序遍历建立中序线索二叉树的主过程算法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</div><div class="line">	ThreadTree pre=<span class="literal">NULL</span>;</div><div class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;              <span class="comment">//非空二叉树，线索化</span></div><div class="line">		InThread(T,pre);      <span class="comment">//线索化二叉树</span></div><div class="line">		pre-&gt;rchild=<span class="literal">NULL</span>;     <span class="comment">//处理遍历的最后一个结点</span></div><div class="line">		pre-&gt;rtag=<span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>线索二叉树的遍历</strong><br>中序线索化二叉树主要是为了访问运算服务的，这种遍历不再需要借助栈，因为它的结点中隐含了线索二叉树的前驱和后继。利用线索二叉树，可以实现二叉树遍历而非递归算法。不含头结点的线索二叉树的遍历算法如下：<br>1.<strong>求中序线索二叉树中中序序列下的第一个结点</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ThreadNode *Firstnode(ThreadNode *p)&#123;</div><div class="line">	<span class="keyword">while</span>(p-&gt;ltag=<span class="number">0</span>)</div><div class="line">		p=p-&gt;lchild;    <span class="regexp">//</span>最左下结点</div><div class="line">	<span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.<strong>求中序线索二叉树中结点p在中序序列下的后继结点</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ThreadNode *Nextnode(ThreadNode *p)&#123;</div><div class="line">	<span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)                   </div><div class="line">		<span class="keyword">return</span> Firstnode(p-&gt;rchild);</div><div class="line">	<span class="keyword">else</span> <span class="comment">//rtag==1直接返回后继线索</span></div><div class="line">		<span class="keyword">return</span> p-&gt;rchild;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.<strong>利用上面两个算法，写出不含头结点的中序线索二叉树的中序遍历算法</strong><br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void Inorder(<span class="name">ThreadNode</span> *T)&#123;</div><div class="line">	for(ThreadNode *p=Firstnode(<span class="name">T</span>)<span class="comment">; p!=NULL; p=Nextnode(p))</span></div><div class="line">		visit(<span class="name">p</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-3]]></title>
      <url>/2017/11/13/%E4%BA%8C%E5%8F%89%E6%A0%91-3/</url>
      <content type="html"><![CDATA[<p>-遍历二叉树</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉树的遍历</strong><br>所谓二叉树的遍历，是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，而且只被访问一次。<br>由二叉树的递归定义可知，遍历一颗二叉树便要决定对根结点N，左子树L和右子树R的访问顺序。按照先遍历左子树再遍历右子树的原则，常见的遍历次序有先序（NLR）、中序（LNR）、后序（LRN）三种遍历算法。</p>
<hr>
<p><strong>先序遍历</strong><br>先序遍历的操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.访问根结点<br>2.先序遍历左子树<br>3.先序遍历右子树</p>
<p>对应的递归算法如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void PreOrder<span class="comment">(BiTree T)</span>&#123;</div><div class="line">	<span class="keyword">if</span><span class="comment">(T!=NULL)</span>&#123;               </div><div class="line">		visit<span class="comment">(T)</span>;              <span class="comment">//访问根结点 </span></div><div class="line">		PreOrder<span class="comment">(T-&gt;lchild)</span>;   <span class="comment">//递归遍历左子树</span></div><div class="line">		PreOrder<span class="comment">(T-&gt;rchild)</span>;   <span class="comment">//递归遍历右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>中序遍历</strong><br>中序遍历的操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.中序遍历左子树<br>2.访问根结点<br>3.中序遍历右子树</p>
<p>对应的递归算法如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void Inorder(BiTree T)&#123;</div><div class="line">	<span class="keyword">if</span>(T!=NULL）</div><div class="line">		I<span class="function"><span class="title">norder</span>(T-&gt;</span>lchild);   <span class="comment">//递归遍历左子树</span></div><div class="line">		visit(T);             <span class="comment">//访问根结点  </span></div><div class="line">		I<span class="function"><span class="title">norder</span>(T-&gt;</span>rchild);   <span class="comment">//递归遍历右子树</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>后序遍历</strong><br>后序遍历操作过程为：<br>如果二叉树为空，什么也不做。否则：<br>1.后序遍历左子树<br>2.后序遍历右子树<br>3.访问根结点</p>
<p>对应的递归算法如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void PostOrder(BiTree <span class="literal">T</span>)&#123;</div><div class="line">	<span class="keyword">if</span>(<span class="literal">T</span>!=<span class="literal">NULL</span>)&#123;</div><div class="line">		PostOrder(<span class="literal">T</span>-&gt;lchild);</div><div class="line">		PostOrder(<span class="literal">T</span>-&gt;rchild);</div><div class="line">		visit(<span class="literal">T</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>不管是哪种便利算法，每个结点都只访问一次，时间复杂度都是O（n）</strong></p>
<hr>
<p><strong>递归算法与非递归算法的转换</strong><br>可以借助栈，将二叉树的递归算法转换成非递归算法</p>
<p>以中序遍历为例，给出非递归算法的实现<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void InOrder2(BiTree T)&#123;</div><div class="line">	<span class="comment">//二叉树中序遍历的非递归算法，算法需要借助一个栈</span></div><div class="line">	InitStack(S);                 <span class="comment">//初始化栈</span></div><div class="line">	BiTree p=T;                   <span class="comment">//p是遍历指针</span></div><div class="line">	<span class="keyword">while</span>(p||!IsEmpty(s))&#123;        <span class="comment">//栈不空或p不空时循环</span></div><div class="line">		<span class="keyword">if</span>(p)&#123;                    <span class="comment">//根指针进栈，遍历左子树</span></div><div class="line">			Push(S,p);            <span class="comment">//没遇到非空二叉树先向左走</span></div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>lchild;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span>&#123;                     <span class="comment">//根指针退栈，访问根结点，遍历右子树  </span></div><div class="line">			Pop(S,p);             <span class="comment">//退栈，访问根结点 </span></div><div class="line">			visit(p);              </div><div class="line">			<span class="function"><span class="title">p</span>=p-&gt;</span>rchild;          <span class="comment">//再向右子树走</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先扫描（并非访问）根结点的所有左结点并将它们一一进栈。然后出战一个结点<em>p（显然结点</em>p没有左孩子结点或者左孩子结点均已访问过），则访问它。然后扫描该结点的右孩子结点，将其进栈，再扫描该右孩子结点的所有左结点并一一进栈，如此继续，直到栈空为止。<br>显然，非递归算法的执行效率要高于递归算法。</p>
<hr>
<p><strong>层次遍历</strong><br>二叉树的层次遍历，即按照箭头所指方向，按照1,2,3,4的层次顺序，对二叉树中各个结点进行访问。<br>要进行层次遍历，需要借助一个队列。先将二叉树的结点入队，然后出队，访问该结点，如果它有左子树，则将左子树根结点入队；如果它有右子树，则将右子树根结点入队。然后出队，对出队结点进行访问，如此反复，直到队列为空。</p>
<p>二叉树的层次遍历算法如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">LevelOrder</span>(BiTree T)&#123;</div><div class="line">	<span class="selector-tag">InitQueue</span>(Q);                    <span class="comment">//初始化辅助队列</span></div><div class="line">	<span class="selector-tag">BiTree</span> <span class="selector-tag">p</span>;                        </div><div class="line">	<span class="selector-tag">EnQueue</span>(Q,T);                    <span class="comment">//将根结点入队</span></div><div class="line">	<span class="selector-tag">while</span>(!IsEmpty(Q))&#123;              <span class="comment">//队列不空循环</span></div><div class="line">		<span class="selector-tag">DeQueue</span>(Q,p);                <span class="comment">//队头元素出队  </span></div><div class="line">		<span class="selector-tag">visit</span>(p);                    <span class="comment">//访问当前结点</span></div><div class="line">		<span class="selector-tag">if</span>(p-&gt;lchild!=NULL)          <span class="comment">//左子树不空，左子树入队列</span></div><div class="line">			<span class="selector-tag">EnQueue</span>(Q,p-&gt;lchild);</div><div class="line">		<span class="selector-tag">if</span>(p-&gt;rchild!=NULL)          <span class="comment">//右子树不空，右子树入队列</span></div><div class="line">			<span class="selector-tag">EnQueue</span>(Q,p-&gt;rchild);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>由遍历序列构造二叉树</strong><br>由二叉树的先序序列和中序序列可以唯一地确定一颗二叉树，在先序遍历序列中，第一个结点一定是二叉树的根结点，而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列就是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这颗二叉树。<br>同理，由二叉树的后序序列和中序序列也可以唯一地确定一颗二叉树，因为后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，就可以得到一颗二叉树。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-2]]></title>
      <url>/2017/11/12/%E4%BA%8C%E5%8F%89%E6%A0%91-2/</url>
      <content type="html"><![CDATA[<p>-二叉树存储结构</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>二叉树的存储结构</strong><br><strong>1.顺序存储结构</strong><br>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在某个数组下标为i-1的分量中，然后通过一些办法确定结点在逻辑上的父子和兄弟关系。</p>
<p>对于完全二叉树和满二叉树采用顺序存储比较合适<br>但对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点让其每个结点与完全二叉树上的结点相对照。用0表示其中并不存在的结点。</p>
<hr>
<p><strong>2.链式存储结构</strong><br>顺序存储对空间利用率是非常低的，因此，一般二叉树都采用链式存储结构。<br>链式结构使用一个链表来存储一颗二叉树，二叉树中每一个结点用链表的一个链结点来存储。<br>二叉链表至少包含三个域：<strong>数据域data、左指针域lchild、右指针域rchild</strong></p>
<p>二叉树的链式存储结构描述如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></div><div class="line">	ElemType data;     <span class="comment">//数据域</span></div><div class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>    <span class="comment">//左、右孩子指针</span></div><div class="line">&#125;BiTNode,*BiTree;</div></pre></td></tr></table></figure></p>
<p>使用不同的存储结构，实现二叉树操作的算法也会完全不同。因此要选择合适的存储结构。<br><strong>容易验证，在含有n个结点的二叉链表中含有n+1个空链域</strong></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二叉树-1]]></title>
      <url>/2017/11/12/%E4%BA%8C%E5%8F%89%E6%A0%91-1/</url>
      <content type="html"><![CDATA[<p>-终于度过了低迷期</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>1.二叉树的定义</strong><br>二叉树是一种树形结构，其特点是每个节点至多只有两颗子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<p><strong>二叉树与度为2的有序树的区别</strong><br>1.度为2的树至少有三个结点，而二叉树可以为空<br>2.度为2的有序树的孩子结点的左右次序是相对于另一孩子结点而言的，如果某个结点只有一个孩子结点，这个孩子结点就无需区分其左右次序</p>
<p><strong>结点编号方式</strong><br>自上而下，自左向右<br>对于一个编号为i的结点，如果有双亲，双亲编号为i/2，如果有左孩子，左孩子编号为2i；如果有右孩子，则右孩子为2i+1；</p>
<hr>
<p><strong>特殊的二叉树</strong><br><strong>满二叉树</strong>：一颗高度为h，并且含有2的h次方-1个结点的二叉树称为满二叉树，树中每一层都含有最多的结点。</p>
<p><strong>完全二叉树</strong>：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。换言之，就是每一个结点都与高度为h的满二叉树的结点一一对应。</p>
<p><img src="http://img.blog.csdn.net/20171110155605187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>二叉排序树</strong>：左子树上所有结点的关键字均小于根结点的关键字；右子树上所有节点的关键字均大于根结点的关键字。左子树和右子树又各是一颗二叉排序树。</p>
<p><strong>平衡二叉树</strong>：树上任一结点的左子树和右子树的深度之差不超过1</p>
<hr>
<p><strong>二叉树的性质</strong><br>1.非空二叉树上叶子结点数N0等于度为2的结点树加1，即N0=N2+1</p>
<ol>
<li>非空二叉树上第k层上只是多有2的H次方-1个结点</li>
<li>高度为H的二叉树中至多有2的H次方-1个结点</li>
<li>对完全二叉树按从上到下，从左到右的顺序依次编号，有以下关系：<br>①当i&gt;1,结点i的双亲结点编号为i/2，即当i为偶数时，其双亲结点编号为i/2，它是双亲结点的左结点；当i为奇数时，其双亲结点的编号为(i-1)/2，它是双亲结点的右孩子<br>②当2i≤N时，结点i的左孩子编号为2i，否则无左孩子<br>③当2i+1≤N时，结点i的右孩子编号为2i+1，否则无右孩子<br>④结点i所在深度为log2i+1<br>5.具有N个结点的完全二叉树的高度为log2(N+1)或log2N+1</li>
</ol>
<h2 id="—"><a href="#—" class="headerlink" title="—"></a>—</h2>]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-5]]></title>
      <url>/2017/11/10/Anyview%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-5/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-5<br>-递归基础<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试编写如下定义的递归函数的递归算法:<br>    g(m,n) = 0             当m=0,n&gt;=0<br>    g(m,n) = g(m-1,2n)+n   当m&gt;0,n&gt;=0<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 如果 m&lt;0 或 n&lt;0 则返回 -1 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&gt;<span class="number">0</span>&amp;&amp;n&gt;=<span class="number">0</span>)</div><div class="line">       <span class="keyword">return</span> G(m<span class="number">-1</span>,<span class="number">2</span>*n)+n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写出求递归函数F(n)的递归算法：<br>    F(n) = n+1      当n=0<br>    F(n) = nF(n/2)  当n&gt;0<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"><span class="comment">/* 如果 n&lt;0 则返回 -1 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n*F(n/<span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p<em>p-A|&lt;e<br>  sqrt(A,p,e) = sqrt(A,(p+A/p)/2,e) 当|p</em>p-A|&gt;=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的递归算法。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">float</span> A, <span class="keyword">float</span> p, <span class="keyword">float</span> e)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p*p-A)&lt;e)</div><div class="line">       <span class="keyword">return</span> p;</div><div class="line">    <span class="keyword">else</span></div><div class="line">       <span class="keyword">return</span> Sqrt(A,(p+A/p)/<span class="number">2</span>,e); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知Ackerman函数的定义如下：<br>   akm(m,n) = n+1                 当m=0<br>   akm(m,n) = akm(m-1,1)          当m!=0,n=0<br>   akm(m,n) = akm(m-1,akm(m,n-1)) 当m!=0,n!=0<br>请写出递归算法。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Akm</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></div><div class="line"><span class="function"><span class="comment">/* 若 m&lt;0 或 n&lt;0 则返回-1  */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   <span class="keyword">if</span>(m&lt;<span class="number">0</span>||n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Akm(m<span class="number">-1</span>,<span class="number">1</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;n!=<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> Akm(m<span class="number">-1</span>,Akm(m,n<span class="number">-1</span>)) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写出求递归函数F(n)的非递归算法：<br>    F(n) = n+1      当n=0<br>    F(n) = nF(n/2)  当n&gt;0<br><strong><strong>**</strong></strong>/<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> F(<span class="keyword">int</span> n)</div><div class="line"><span class="comment">/* 如果 n&lt;0 则返回 -1 */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i=n,<span class="keyword">count</span>=<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;        </div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">for</span>(;i&gt;<span class="number">0</span>;i=i/<span class="number">2</span>)</div><div class="line">            <span class="keyword">count</span>=<span class="keyword">count</span>*i;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">count</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】求解平方根 的迭代函数定义如下：<br>  sqrt(A,p,e) = p                   当|p<em>p-A|&lt;e<br>  sqrt(A,p,e) = sqrt(A,(p+A/p)/2,e) 当|p</em>p-A|&gt;=e<br>其中，p是A的近似平方根，e是结果允许误差。试写出相<br>应的非递归算法。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sqrt</span><span class="params">(<span class="keyword">float</span> A, <span class="keyword">float</span> p, <span class="keyword">float</span> e)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">float</span> mp=p;</div><div class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(p*p-A)&lt;e)</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">while</span>(<span class="built_in">fabs</span>(mp*mp-A)&gt;=e)</div><div class="line">            mp=(mp+A/mp)/<span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> mp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设以二维数组g[1..m][1..n]表示一个图像<br>区域，g[i][j]表示该区域中点(i,j)所具颜色，其值<br>为从0到k的整数。试编写递归算法，将点(i0,j0)所在<br>区域的颜色置换为颜色c。约定与(i0,j0)同色的上、<br>下、左、右的邻接点为同色区域的点。</p>
<p>表示图像区域的类型定义如下：<br>typedef char GTYPE[m+1][n+1];<br><strong><strong>**</strong></strong>/<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">void ChangeColor(GTYPE g, int m, int n, </div><div class="line">                 char c, int <span class="built_in">i0</span>, int <span class="built_in">j0</span>)</div><div class="line"><span class="comment">/* 在g[1..m][1..n]中，将元素g[i0][j0] */</span></div><div class="line"><span class="comment">/* 所在的同色区域的颜色置换为颜色c    */</span></div><div class="line">&#123;   </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>&gt;m||<span class="built_in">j0</span>&gt;n)</div><div class="line">         <span class="built_in">return</span>;  </div><div class="line"> </div><div class="line">     int <span class="built_in">color</span>;  </div><div class="line">     <span class="built_in">color</span>=g[<span class="built_in">i0</span>][<span class="built_in">j0</span>];  </div><div class="line">     g[<span class="built_in">i0</span>][<span class="built_in">j0</span>]=c; </div><div class="line">      </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>-<span class="number">1</span>&gt;=<span class="number">1</span>)//判断是否越界，下同       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>-<span class="number">1</span>][<span class="built_in">j0</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>-<span class="number">1</span>,<span class="built_in">j0</span>);                        </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">i0</span>+<span class="number">1</span>&lt;=m)       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>+<span class="number">1</span>][<span class="built_in">j0</span>]==<span class="built_in">color</span>)         </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>+<span class="number">1</span>,<span class="built_in">j0</span>);                    </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">j0</span>-<span class="number">1</span>&gt;=<span class="number">1</span>)       </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>][<span class="built_in">j0</span>-<span class="number">1</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>,<span class="built_in">j0</span>-<span class="number">1</span>);                    </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">j0</span>+<span class="number">1</span>&lt;=n)           </div><div class="line">         <span class="keyword">if</span>(g[<span class="built_in">i0</span>][<span class="built_in">j0</span>+<span class="number">1</span>]==<span class="built_in">color</span>)           </div><div class="line">             ChangeColor(g,m,n,c,<span class="built_in">i0</span>,<span class="built_in">j0</span>+<span class="number">1</span>);                    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑模拟-2]]></title>
      <url>/2017/11/06/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%A8%A1%E6%8B%9F-2/</url>
      <content type="html"><![CDATA[<p>-2013题型<br><a id="more"></a></p>
<hr>
<p><strong>推理题之CP规则</strong><br>一般用于S-&gt;T的类型<br>将S作为附加前提<br>推导出T<br>这就是CP规则的用法</p>
<hr>
<p><strong>证明代数系统</strong><br>先确定集合为非空集合<br>再保证运算在该集合上是封闭运算</p>
<hr>
<p><strong>主析取范式与主合取范式的转换</strong><br>若有主析取范式<br>G=m1+m2+m3+m5+m7<br>则¬G=m0+m4+m6<br>主合取范式为G=¬m0+¬m4+¬m6</p>
<hr>
<p><strong>单射双射满射</strong><br>单射就是只能一对一，不能多对一，满射就是不论一对一，还是多对一，在映射f:X→Y中，Y中任一元素y都是X中某元素的像，也就是Y中所有元素在X中都能找到原像，至于找到的只有一个原像,那就是双射，但有的可以找到一个以上的那就不是双射，即双射就是既是单射又是满射。<br>单射：一对一<br>满射：不管映射方式，保证每个元素都有对应的<br>双射：一一对应<br><img src="http://img.blog.csdn.net/20171106205147588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<hr>
<p><strong>同态同构</strong><br>C是从A-B的映射<br>A中封闭运算为a，B中封闭运算为b<br>C（x a y）=C（x） b  C（y）<br>称为<strong>同态</strong><br>C为单射，满射，双射时<br>分别称C是<strong>单一同态，满同态，同构</strong></p>
<hr>
<p><strong>证明一个代数系统为半群</strong><br>半群性质：满足结合律</p>
<hr>
<p><strong>证明一个代数系统是群</strong><br>运算满足结合律<br>有幺元<br>每个元素都有逆元</p>
<hr>
<p><strong>求元素的周期</strong><br>求幺元e<br>求使元素a的n次方等于e的最小正整数</p>
<hr>
<p><strong>循环群与生成元</strong><br>每个元素都能用一个元素g的n次方表示，称为循环群<br>g为一个生成元</p>
<hr>
<p><strong>拉格朗日定理结论</strong><br>1.阶为n的有限群中，对任意a∈ G，有a的n次方等于e（e为幺元）<br>2.素数阶有限群G都是循环群，除了幺元外的所有元素都是它的生成元</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑模拟-1]]></title>
      <url>/2017/11/04/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E6%A8%A1%E6%8B%9F-1/</url>
      <content type="html"><![CDATA[<p>-2015题型<br><a id="more"></a><br><strong>求公式的主合取范式</strong><br>先消去公式中的<strong>→</strong>与<strong>↔</strong><br>如果需要补基础元(P)，可以使用<strong>∧(P∨¬P）</strong>或者<strong>∨（P∧¬P）</strong><br>接着进行结合的调换，调成主合取范式<br>（主析取范式也是如此）</p>
<hr>
<p><strong>已知主析取范式求主合取范式</strong><br>将所有的主析取范式剩下的极小项转换成极大项<br>再用合取连接起来<br>这样就得到了主合取范式<br>（已知主合取范式求主析取范式的过程类似）</p>
<hr>
<p><strong>证明过程题</strong><br>US：全称特指<br>ES：存在特指<br>UG：全称推广<br>EG：存在推广<br>P：引用<br>T：推理</p>
<hr>
<p><strong>代数系统题</strong><br>结合律，交换律，幂等律（a<em>a=a），消去律（a</em>x=a<em>y），分配律，吸收律（x-(x</em>y)=x）<br>幺元（单位元）<br>零元（a<em>b=b</em>a=b）<br>逆元（a*b=e）</p>
<hr>
<p><strong>群与陪集</strong><br>求陪集的方法：<br>以右陪集为例；<br>用子群与群中每一元素进行二元运算，删除重复部分，即为陪集</p>
<hr>
<p><strong>拉格朗日定理</strong><br>子群的阶记为m，有限群的阶记为n，子群的陪集个数为k<br>首先n一定是m的倍数，即n能被m整除<br>k=n/m<br>由此可计算陪集的个数</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑复习笔记-2]]></title>
      <url>/2017/10/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      <content type="html"><![CDATA[<p>-必考题解法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>利用真值表技术求某公式的主析取范式和主合取范式（一般是大题）</strong><br>1.先列出真值表（真值表中不需要列出极大项和极小项）<br>2.根据真值表中的公式等于1对应的情况写出极小项，构造主析取范式<br>3.根据剩余极小项，进行取反获得主合取范式<br><img src="http://img.blog.csdn.net/20171031090255154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20171031090053020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2Vla19qZXJvbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>先列真值表<br>再求主析取范式<br>再根据主析取范式求主合取范式</p>
<hr>
<p><strong>求某公式的主析取范式和主合取范式（选择填空题）</strong><br>如果是要同时求主析取范式和主合取范式，先看公式容不容易化简，否则用真值表技术</p>
<p>如果只是求主析取范式和主合取范式中的一个，可以尝试用<strong>分析法</strong>，直接去分析什么情况下公式等于0或什么情况下公式等于1，一般取范式不会太长，所以只用做一个极大项或极小项的<strong>排除</strong>，即简化真值表操作</p>
<hr>
<p><strong>几大元的定义</strong><br><strong>消去元</strong>：存在一个元素a∈A对于任意的x,y∈A，都有a<em>x=a</em>y，即可以消去a，a称为消去元<br><strong>幂等元</strong>：若元素a∈A，且满足a<em>a=a，则a称为A关于“</em>”的幂等元<br><strong>幺元（单位元）</strong>：对于任意a∈A，存在e∈A，使得a<em>e=e</em>a=a，则称e为幺元（单位元）<br><strong>零元</strong>：对于任意a∈A，存在b∈A，使得a<em>b=b</em>a=b,则称b为零元<br><strong>逆元</strong>：e是幺元，a∈A，存在b∈A，使得a<em>b=b</em>a=e，则称a是b的逆元（可倒置）</p>
<p>幺元对应1<br>零元对应0<br>逆元对应倒数</p>
<hr>
<p><strong>代数系统定义</strong><br><strong>代数系统</strong>：集合和定义在集合上的n元封闭运算称为代数系统<br><strong>广群</strong>：二元运算不加限制的一般代数系统<br><strong>半群</strong>：若代数系统中的二元运算满足结合律，则称为半群<br><strong>循环半群</strong>：存在a∈A，对任意x∈S，有x=a^n,则称此代数系统为循环半群<br><strong>生成元</strong>：循环半群中的a，称为循环半群的一个生成元<br><strong>群</strong>：二元运算满足结合律，存在幺元，每个元素都有逆元，这样的二元代数系统称为群</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数理逻辑复习笔记-1]]></title>
      <url>/2017/10/31/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<p>-模糊概念<br><a id="more"></a></p>
<hr>
<p><strong>量词辖域的确定方法</strong>：<br>1.若量词后有括号，则括号内的子公式就是量词的辖域<br>2.若量词后没有括号，则与量词邻接的子公式就是该量词的辖域</p>
<hr>
<p><strong>约束变元的改名规则</strong>：<br>1.将量词中出现的变元以及该量词辖域中此变量所有约束出现都用新的个体变元替换<br>2.新的变元一定要有别于改名辖域中的所有其他变量</p>
<p><strong>自由变元的代入规则</strong>：<br>1.将公式中出现该自由变元的每一处都用新的个体变元替换<br>2.新变元不允许在原公式中以任何约束形式出现</p>
<hr>
<p><strong>前束范式的转换方法</strong>：<br>设G施任一公式，通过下述步骤可将其转换为与之等价的前束范式<br>1.消去公式中包含的联结词“-&gt;””&lt;-&gt;”<br>2.反复运用德摩根定律，直接将“¬”內移到原子谓词公式的前端<br>3.使用谓词的等价公式将所有量词提到公式的最前端</p>
<hr>
<p><strong>求Skolem标准型的方法</strong>：<br>将原公式中的前置量词逐一消去，存在量词替换成一些特定的字母，全称量词可以不变，但是，如果存在量词在全称量词后方，应转换成用全称量词表示的函数</p>
<hr>
<p><strong>使用推理规则注意</strong>：<br><strong>使用US规则来消去量词时，所选用取代x的变量y在公式中必须是自由的</strong></p>
<p><strong>使用ES规则来消去量词时，若还有其他自由变元时，必须用关于自由变元的函数符号来取代常数符号</strong></p>
<p><strong>使用UG规则来添加量词时，所使用的的变元符号不能与辖域内的变元符号相同</strong></p>
<p><strong>使用EG规则来添加量词时，所使用的的变元符号不能与辖域内的变元符号相同</strong></p>
<hr>
<p><strong>谓词演算综合推理方法</strong>：<br>1.推导过程中可以引用命题演算中的规则P和规则T<br>2.如果结论是以条件形式给出，可以使用规则CP<br>3.若需消去量词，可以引用规则US和ES<br>4.当所需要的结论可能被定量时，此时可引用规则UG和EG将量词加入</p>
<hr>
<p><strong>代数系统判断方法</strong>：<br>判断集合A和其上代数运算是否为代数系统，关键是判断两点：<br>1.集合A非空<br>2.这些运算在A上是否满足封闭性</p>
<hr>
<p><strong>特殊元计算方法</strong>：<br>计算幺元，零元，幂等元等特殊元时，首先可以假设这些元存在，然后根据定义直接得到方程，解这个方程计算这些元，如果无解则不存在，如果有解还要进一步验证是否是对应的特殊元</p>
<hr>
<p><strong>证明同态与同构</strong>：<br>首先可以假设f就是同态或同构映射，然后利用同态，同构的定义，导出f的一些性质，并利用这些性质来构造同态与同构映射，从而证明代数系统的同态与同构</p>
<hr>
<p><strong>群的性质</strong>：<br>满足结合律<br>有幺元<br>每个元有逆元</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDOJ-1001]]></title>
      <url>/2017/10/30/HDOJ-1001/</url>
      <content type="html"><![CDATA[<p>-simple<br>-sum problem<br><a id="more"></a></p>
<hr>
<p>Sum Problem</p>
<p>Time Limit: 1000/500 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 500758    Accepted Submission(s): 127099</p>
<p>Problem Description<br>Hey, welcome to HDOJ(Hangzhou Dianzi University Online Judge).</p>
<p>In this problem, your task is to calculate SUM(n) = 1 + 2 + 3 + … + n.</p>
<p>Input<br>The input will consist of a series of integers n, one integer per line.</p>
<p>Output<br>For each case, output SUM(n) in one line, followed by a blank line. You may assume the result will be in the range of 32-bit signed integer.</p>
<p>Sample Input<br>1<br>100</p>
<p>Sample Output<br>1</p>
<p>5050</p>
<hr>
<p>sum问题，注意下中间多一个空行就好</p>
<hr>
<p>AC代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> x;</div><div class="line">  <span class="keyword">int</span> i,sum=<span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x)&#123;</div><div class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=x;i++)  </div><div class="line">        sum+=i;</div><div class="line">	 <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">     sum=<span class="number">0</span>;</div><div class="line">   &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> HDOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDOJ-1000]]></title>
      <url>/2017/10/30/HDOJ-1000/</url>
      <content type="html"><![CDATA[<p>-simple<br>-A+B problem<br><a id="more"></a></p>
<hr>
<p>A + B Problem</p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 701093    Accepted Submission(s): 216996</p>
<p>Problem Description<br>Calculate A + B.</p>
<p>Input<br>Each line will contain two integers A and B. Process to end of file.</p>
<p>Output<br>For each case, output A + B in one line.</p>
<p>Sample Input<br>1 1</p>
<p>Sample Output<br>2</p>
<hr>
<p>简单A+B题</p>
<hr>
<p>AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> x,y;</div><div class="line">  <span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y)</div><div class="line">	     <span class="built_in">cout</span>&lt;&lt;x+y&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> HDOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[静电场-2]]></title>
      <url>/2017/10/30/%E9%9D%99%E7%94%B5%E5%9C%BA-2/</url>
      <content type="html"><![CDATA[<p>-电通量<br>-静电场中的高斯定理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>电场线</strong>：用于形象描述电场在空间的分布情况</p>
<p>电场线有如下性质：<br>1.电场线起自正电荷（或来自无穷远），终止于负电荷（或伸向无限远），在无电荷的地方不会中断<br>2.任意两条电场线不相交，即静电场中每一点的场强只有一个方向<br>3.电场线不形成闭合回线<br>4.电场强处电场线密集，电场弱处电场线稀疏</p>
<hr>
<p><strong>电通量</strong>：穿过电场中任意给定面的电场线条数称为通过该面的电场强度通量</p>
<p>均匀电场中，穿过垂直于电场方向的任意平面S的电通量为<strong>φ=ES</strong>，若与场强成θ角，则<strong>φ=EScosθ</strong></p>
<p>如果是曲面，则通过dS的电通量为：<strong>dφ=EdScosθ=E·dS</strong><br>通过整个曲面S的电通量为<strong>φ=∫s（dφ）=∫s（E·dS）</strong></p>
<p><strong>如果是闭合曲面，则规定由内向外的方向为个面积元法矢en的正方向</strong></p>
<hr>
<p><strong>高斯定理</strong>：静电场的高斯定理表述为：真空中任何静电场中，穿过任一闭合曲面的电通量等于该闭合曲面包围电荷代数和的ε0分之一，即<br><strong>φ=∫s（E·dS）=（1/ε0）∑qi</strong></p>
<p>对高斯定理的理解应注意：<br>1.高斯定理表达式作坊的场强E是闭合面上dS处的场强，它是由闭合面内外全部电荷共同产生的，即闭合面外的电荷对空间各点的E有贡献，要影响闭合面上各面元的通量dφ<br>2.通过闭合曲面的总电通量只决定于闭合面内所包围的电荷，闭合曲面外部的电荷对闭合面的总电通量∫E·dS无贡献.</p>
<hr>
]]></content>
      
        <categories>
            
            <category> 大学物理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> basic courses </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开始学习C++]]></title>
      <url>/2017/10/30/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0C++/</url>
      <content type="html"><![CDATA[<p>-C++基础介绍</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>Hello world</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  //预处理器编译指令</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  <span class="comment">//编译指令</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;   <span class="comment">//函数头</span></div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"HelloWorld"</span>&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//cout语句输出，endl换行</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;   <span class="comment">//C++注释用“//......”或者“/* ...... */”来进行注释</span></div></pre></td></tr></table></figure></p>
<p>如C一般，这种程序在运行完之后立即关闭，需要加一句<code>cin.get();</code>语句来保持打开状态，直到按任何键才关闭。</p>
<p>using编译指令使得std名称空间中的所有名称都可用，例如：可以直接使用cout和cin，而不用加std：：前缀。</p>
<hr>
<p><strong>C++语句</strong><br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int i<span class="comment">; //声明语句</span></div><div class="line"><span class="attribute">i</span>=<span class="number">1</span><span class="comment">;  //赋值语句</span></div></pre></td></tr></table></figure></p>
<p>除此之外，C++还有许多的其他语句，循环等。</p>
<hr>
<p><strong>类简介</strong><br>类是面向对象编程的核心概念之一，也是JAVA语言的核心，C++的优势在于既可以面向过程，也可以面向对象，是一种综合编程语言。类定义描述的是数据格式及其用法，而对象是根据数据格式规范创建的实体</p>
<hr>
<p><strong>关键字</strong><br>C++中有int,double,new等关键字，这些关键字都是C++专用的，不能用于自定义变量名，函数名……</p>
<hr>
]]></content>
      
        <categories>
            
            <category> C++ programming language </category>
            
        </categories>
        
        
        <tags>
            
            <tag> programming language learning </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[静电场-1]]></title>
      <url>/2017/10/29/%E9%9D%99%E7%94%B5%E5%9C%BA-1/</url>
      <content type="html"><![CDATA[<p>-电荷基础<br>-电场基础</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>自然界只存在正负两种电荷，同种电荷相互排斥，异种电荷相互吸引</p>
<p><strong>电荷守恒定律</strong>：在一个孤立系统内，无论发生怎样的物理过程，系统内电荷的代数和是不变的，这个结论称为电荷守恒定律</p>
<p>任何带电体所带电量都是某一基本电量的整数倍，这一基本电量就是电子所带电量的绝对值，以e表示，电荷的这一特性称为<strong>电荷的量子化</strong></p>
<p>电子的电量大小为<strong>$e=1.602*10^-19C$</strong></p>
<p>实验证明，粒子所带的电荷量与其运动状态无关。例如：加速器将质子或电子加速时，随着它们速度的变化，其质量变化是显著的，但是电荷却没有任何变化。这一性质叫<strong>电荷的相对论不变性</strong></p>
<hr>
<p><strong>库仑定律</strong>：真空中两个静止点电荷之间的相互作用力大小与这两个点电荷量q1和q2的乘积成正比，与他们之间距离r的平方成反比，作用力的方向沿它们的连线方向，同号电荷相斥，异号电荷相吸</p>
<p>库伦定律可以用矢量式表示为<strong>$F=kq1q2/(r^2)$</strong></p>
<p>1.当F＞0时，F与r同方向表示斥力；当F＜0时，F与r反方向表示引力<br>2.比例系数k写成<strong>$k=1/(4πε0)$</strong></p>
<p>因此，库仑定律可以写成<strong>$F=1/(4πε0) *q1q2/(r^2)$</strong></p>
<hr>
<p>静电场重要的对外表现有：<br>1.力的表现；放入电场中的电荷要受到电场的作用力<br>2.功的表现；电荷在静电场中移动式，电场力将对电荷做功</p>
<p><strong>电场强度</strong>：用E表示，<strong>E=F/q0</strong>，电场中某一点的电场强度等于单位正电荷在该点受到的电场力</p>
<p><strong>场强叠加定理</strong>：<strong>E=E1+E2+…+En</strong><br>点电荷系电场中任一点的电场强度等于各点电荷单独存在时在该点产生的场强的矢量和</p>
<p>若将实验电荷q0放在距离q为r的P点，则q0所受的电场力为<strong>F=(1/4πε0)<em>(q</em>q0/(r^3)*r)</strong><br>因此场强<strong>E=F/q0=(1/4πε0)<em>(q/(r^3)</em>r)</strong></p>
<hr>
<p><strong>任意带电体的场强</strong><br>真空中一电荷连续分布的任意带电体，把带电体看成许多电荷元dq组成，电荷元dq可视为点电荷，它在场点P产生的场强为dE<br>由此可得：<strong>dE=F/q0=(1/4πε0)<em>(dq/(r^3)</em>r)</strong></p>
<p>由场强叠加原理，<strong>E=∫dE=(1/4πε0)<em>∫(dq/(r^3)</em>r)</strong></p>
<hr>
]]></content>
      
        <categories>
            
            <category> 大学物理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> basic courses </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1048题解]]></title>
      <url>/2017/10/28/ZOJ-1048/</url>
      <content type="html"><![CDATA[<p>-简单的求均值题</p>
<a id="more"></a>
<p>Financial Management<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB</p>
<p>Larry graduated this year and finally has a job. He’s making a lot of money, but somehow never seems to have enough. Larry has decided that he needs to grab hold of his financial portfolio and solve his financing problems. The first step is to figure out what’s been going on with his money. Larry has his bank account statements and wants to see how much money he has. Help Larry by writing a program to take his closing balance from each of the past twelve months and calculate his average account balance.</p>
<p>Input Format: </p>
<p>The input will be twelve lines. Each line will contain the closing balance of his bank account for a particular month. Each number will be positive and displayed to the penny. No dollar sign will be included.</p>
<p>Output Format: </p>
<p>The output will be a single number, the average (mean) of the closing balances for the twelve months. It will be rounded to the nearest penny, preceded immediately by a dollar sign, and followed by the end-of-line. There will be no other spaces or characters in the output. </p>
<p>Sample Input: </p>
<p>100.00<br>489.12<br>12454.12<br>1234.10<br>823.05<br>109.20<br>5.27<br>1542.25<br>839.18<br>83.99<br>1295.01<br>1.75</p>
<p>Sample Output: </p>
<p>$1581.42</p>
<hr>
<p>简单的入门题，输入求均值输出就行</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt; </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">float</span> a[<span class="number">12</span>];</div><div class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">	<span class="keyword">float</span> sum=<span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">12</span>;i++)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</div><div class="line">		sum+=a[i];</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"$"</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;sum/<span class="number">12</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1037题解]]></title>
      <url>/2017/10/28/ZOJ-1037/</url>
      <content type="html"><![CDATA[<p>-注意提交格式！</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>Gridland<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB<br>Background</p>
<p>For years, computer scientists have been trying to find efficient solutions to different computing problems. For some of them efficient algorithms are already available, these are the “easy” problems like sorting, evaluating a polynomial or finding the shortest path in a graph. For the “hard” ones only exponential-time algorithms are known. The traveling-salesman problem belongs to this latter group. Given a set of N towns and roads between these towns, the problem is to compute the shortest path allowing a salesman to visit each of the towns once and only once and return to the starting point.</p>
<p>Problem</p>
<p>The president of Gridland has hired you to design a program that calculates the length of the shortest traveling-salesman tour for the towns in the country. In Gridland, there is one town at each of the points of a rectangular grid. Roads run from every town in the directions North, Northwest, West, Southwest, South, Southeast, East, and Northeast, provided that there is a neighbouring town in that direction. The distance between neighbouring towns in directions North-South or East-West is 1 unit. The length of the roads is measured by the Euclidean distance. For example, Figure 7 shows 2 <em> 3-Gridland, i.e., a rectangular grid of dimensions 2 by 3. In 2 </em> 3-Gridland, the shortest tour has length 6.</p>
<p>Figure 7: A traveling-salesman tour in 2 * 3-Gridland.</p>
<p>Input</p>
<p>The first line contains the number of scenarios.</p>
<p>For each scenario, the grid dimensions m and n will be given as two integer numbers in a single line, separated by a single blank, satisfying 1 &lt; m &lt; 50 and 1 &lt; n &lt; 50.</p>
<p>Output</p>
<p>The output for each scenario begins with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. In the next line, print the length of the shortest traveling-salesman tour rounded to two decimal digits. The output for every scenario ends with a blank line.</p>
<p>Sample Input</p>
<p>2<br>2 2<br>2 3</p>
<p>Sample Output</p>
<p>Scenario #1:<br>4.00</p>
<p>Scenario #2:<br>6.00 </p>
<hr>
<p>题目大意：先给案例个数，每个案例有两个数，作为长宽，然后以此来走，求走完所有点的最短长度</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> n;</div><div class="line">	<span class="keyword">int</span> x,y;</div><div class="line">	<span class="keyword">int</span> count=<span class="number">1</span>;</div><div class="line">	<span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>);</div><div class="line">	<span class="keyword">while</span>(n--)&#123;</div><div class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Scenario #"</span>&lt;&lt;count&lt;&lt;<span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">1</span>&amp;&amp;y%<span class="number">2</span>==<span class="number">1</span>)  <span class="comment">//都是奇数 </span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;(<span class="keyword">double</span>)(x*y+<span class="number">0.41</span>)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">			<span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;(<span class="keyword">double</span>)(x*y)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>; </div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>submit了几次才成功，也是很久没有做OJ题了。<br>主要的问题都不大，就是要注意下格式，不然就会Presentation Error</p>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ZOJ-1001题解]]></title>
      <url>/2017/10/28/ZOJ-1001/</url>
      <content type="html"><![CDATA[<p>……</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>A + B Problem<br>Time Limit: 2 Seconds      Memory Limit: 65536 KB</p>
<p>Calculate a + b<br>Input<br>The input will consist of a series of pairs of integers a and b,separated by a space, one pair of integers per line.<br>Output<br>For each pair of input integers a and b you should output the sum of a and b in one line,and with one line of output for each line in input.<br>Sample Input<br>1 5<br>Sample Output<br>6<br>Hint<br>Use + operator</p>
<hr>
<p>解题思路：没有什么思路，直接加输出就是了</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </div><div class="line">  </div><div class="line">   <span class="keyword">int</span> a,b;  </div><div class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b)&#123;  </div><div class="line">     <span class="built_in">cout</span>&lt;&lt;a+b&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">   &#125;  </div><div class="line">  </div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
]]></content>
      
        <categories>
            
            <category> ZOJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[树]]></title>
      <url>/2017/10/28/%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>-树的定义与基本性质<br><a id="more"></a><br><strong>树</strong>：树是N（N≥0）个结点的有限集合，N=0时，称为空树。<br>在任意一棵非空树中应满足：<br>1.有且仅有一个特定的称为<strong>根</strong>的结点<br>2.当N&gt;1时，其余结点可分为m（m&gt;0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，称为根结点的<strong>子树</strong></p>
<p>显然树的定义是递归的，是一种递归的数据结构。树作为一种逻辑结构，同时也使一种分层结构，具有以下两个特点：<br>1.树的根结点没有前驱结点之外，所有结点有且仅有一个前驱结点<br>2.树的所有节点可以有零个或多个后继结点</p>
<p><strong>由特点2可以推出，在n个结点的树中有n-1条边</strong></p>
<hr>
<p><strong><font size="5">基本术语</font></strong><br><strong>度</strong>：树中一个结点的子结点个数称为该结点的度，树中结点的最大度数称为树的度<br><strong>分支结点</strong>：度大于0的结点称为分支结点（又称非终端结点）<br><strong>叶子结点</strong>：度为0（没有子女结点）的结点称为叶子结点（又称终端结点）<br><strong>树的高度（深度）</strong>：树中结点的最大层数<br><strong>有序树与无序树</strong>：树中结点的子树从左到右是有次序的，不能交换，这样的树叫做有序树，有序树中，一个结点其子结点按从左到右顺序出现时有关联的。反之称为无序树<br><strong>路径与路径长度</strong>：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数<br><strong>森林</strong>：森林是m(m≥0)棵互不相交的树的集合</p>
<hr>
<p><strong><font size="5">树的基本性质</font></strong><br>1.树中结点数等于所有结点的度数加一<br>2.度为m的树中第i层上至多有m^i-1个结点<br>3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点<br>4.具有n个结点的m叉树的最小高度为[logm(n(m-1)+1)]</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Some casual words]]></title>
      <url>/2017/10/28/Some%20casual%20words/</url>
      <content type="html"><![CDATA[<p>-深夜发个牢骚？</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29572804&auto=0&height=66">  </iframe></p>
<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><p>For something，wrote this article.<br>回想了一下<br>19岁了<br>好像每一件我想要去做好的事情都被我搞砸了<br>好像每一个我想要交善的人最终都疏远了<br>小升初时<br>我想要从一个很菜的学校考到一个好点的学校去读书<br>很不意外的失败了<br>升高中时<br>我想要考到市里最好的学校去读书<br>最终还是靠着中考前签的协议去了一所还算不错的高中<br>考大学时<br>我想要考到省里最好的大学<br>最终去了一所高考前甚至不尝听闻的大学</p>
<hr>
<p>我想在竞赛中收获一二<br>却结果惨淡<br>我想在一门喜欢的课程上取得一个不错的成绩<br>却不尽人意<br>我想和真正希望守护陪伴的女孩走完一生<br>却断了联系<br>我想像中学一般有两三个挚友<br>却“不如意事十八九，可与言者无二三”<br>我想让周围的人都能快乐开心<br>却被当做“哗众取宠，扮演小丑”<br>我想要去追求的人或事<br>我基本是用我最大的努力去做的<br>也可能是自己的双商都不足吧<br>好像基本无几落空的失败了<br>这种感觉可真难受啊</p>
<hr>
<p>To sum up<br>过去的人生可以说全部搞砸了<br>回想高中曾有的一天13小时Lol的竞技水平<br>回想大一明知会点名也坚决不去的公共课<br>回想大一即使作业没完成甚至还要跑到华工中大广药玩的狼人杀…<br>以前确实浪费了挺多时间…<br>如今也该算是补偿的时候了…<br>要多多充实自己…</p>
<hr>
<p>突然发现今天是重阳节…<br>按照自己毫无章法的逻辑<br>粗俗地字面理解下<br>重新获得阳光的节日<br>那…<br>立两个flag吧<br>一段时间内：<br>1.不再参与任何的游戏活动和娱乐活动<br>2.除了学习与工作需要，不再使用任何社交工具。</p>
<hr>
<p>以上<br>虽然我也不知道我自己写的什么瓜皮东西<br>但就这样吧<br>睡醒又是新的一天</p>
<hr>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="/images/5.png" alt=""></h2>]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-4]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-4<br><a id="more"></a></p>
<p>/<strong><strong>**</strong></strong><br>【题目】已知某哈希表的装载因子小于1，哈希函数H(key)<br>为关键字(标识符)的第一个字母在字母表中的序号，处理<br>冲突的方法为线性探测开放定址法。试编写一个按第一个<br>字母的顺序输出哈希表中所有关键字的算法。<br>哈希表的类型HashTable定义如下：</p>
<p>#define SUCCESS    1</p>
<p>#define UNSUCCESS  0</p>
<p>#define DUPLICATE -1<br>typedef char StrKeyType[4];<br>typedef struct {<br>   StrKeyType key; // 关键字项<br>   int    tag;     // 标记 0:空；1:有效; -1:已删除<br>   void  <em>any;     // 其他信息<br>} RcdType;<br>typedef struct {<br>  RcdType </em>rcd;    // 存储空间基址<br>  int      size;   // 哈希表容量<br>  int      count;  // 表中当前记录个数<br>} HashTable;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PrintKeys(HashTable ht, <span class="keyword">void</span>(*<span class="built_in">print</span>)(StrKeyType))</div><div class="line"><span class="comment">/* 依题意用print输出关键字 */</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">int</span> n,i,<span class="built_in">size</span>;</div><div class="line">    <span class="built_in">char</span> c;</div><div class="line">    <span class="keyword">for</span>(c=<span class="string">'A'</span>;c&lt;=<span class="string">'Z'</span>;c++)&#123;</div><div class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ht.<span class="built_in">size</span>;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(ht.rcd[i].tag==<span class="number">-1</span>) </div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            <span class="keyword">if</span>(ht.rcd[i].<span class="built_in">key</span>[<span class="number">0</span>]==c)</div><div class="line">                <span class="built_in">print</span>(ht.rcd[i].<span class="built_in">key</span>);</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设哈希表长为m，哈希函数为H(x)，用链地址法<br>处理冲突。试编写输入一组关键字并建造哈希表的算法。<br>哈希表的类型ChainHashTab定义如下：</p>
<p>#define NUM         7</p>
<p>#define NULLKEY    -1</p>
<p>#define SUCCESS     1</p>
<p>#define UNSUCCESS   0</p>
<p>#define DUPLICATE  -1<br>typedef char HKeyType;<br>typedef struct HNode {<br>   HKeyType  data;<br>   struct HNode<em>  next;<br>}</em>HLink;<br>typedef struct {<br>   HLink  <em>rcd;   // 指针存储基址，动态分配数组<br>   int    count;  // 当前表中含有的记录个数<br>   int    size;  // 哈希表的当前容量<br>}ChainHashTab;    // 链地址哈希表<br>int Hash(ChainHashTab H, HKeyType k) { // 哈希函数<br>  return k % H.size;<br>}<br>Status Collision(ChainHashTab H, HLink &amp;p) {<br>  // 求得下一个探查地址p<br>  if (p &amp;&amp; p-&gt;next) {<br>    p = p-&gt;next;<br>    return SUCCESS;<br>  } else return UNSUCCESS;<br>}<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">int BuildHashTab(ChainHashTab &amp;H, int n, HKeyType es[]) </div><div class="line"><span class="comment">/* 直接调用下列函数                             */</span></div><div class="line"><span class="comment">/* 哈希函数：                                   */</span></div><div class="line"><span class="comment">/*    int Hash(ChainHashTab H, HKeyType k);     */</span></div><div class="line"><span class="comment">/* 冲突处理函数：                               */</span></div><div class="line"><span class="comment">/*    int Collision(ChainHashTab H, HLink &amp;p);  */</span></div><div class="line">&#123;</div><div class="line">    int i,k,j;</div><div class="line">    HLink p,q,p1;</div><div class="line">    H.rcd = (HLink*)malloc(<span class="number">7</span>*sizeof(HLink));</div><div class="line">    H.size = <span class="number">7</span>;</div><div class="line">    H.count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;es[i] &gt;= <span class="string">'A'</span>;i++)&#123;</div><div class="line">        p = (HNode*)malloc(sizeof(HNode));</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span>next = NULL;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span> = es[i];</div><div class="line">        <span class="function"><span class="title">k</span> = Hash( H, p-&gt;</span><span class="keyword">data</span>) ;</div><div class="line">        <span class="keyword">if</span>(NULL !=H.rcd[k])&#123;  <span class="comment">// 判断其中是否有相同的HKeyType</span></div><div class="line">            p1 =  H.rcd[k];</div><div class="line">            <span class="keyword">while</span>(NULL != p1)&#123;  <span class="comment">//用j作为标记，如果j = 0表示没有相同的，插入p</span></div><div class="line">                <span class="function"><span class="title">if</span>(p1-&gt;</span><span class="function"><span class="title">data</span> == p-&gt;</span><span class="keyword">data</span>)</div><div class="line">                    j = <span class="number">1</span>;</div><div class="line">                <span class="function"><span class="title">p1</span> = p1-&gt;</span>next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                q =  H.rcd[k];</div><div class="line">                <span class="function"><span class="title">p</span>-&gt;</span>next = q;</div><div class="line">                H.rcd[k] = p;</div><div class="line">            &#125;</div><div class="line">           j = <span class="number">0</span>;</div><div class="line">        &#125;         </div><div class="line">        <span class="keyword">else</span>   </div><div class="line">            H.<span class="function"><span class="title">rcd</span>[k] = p; //为什么H.rcd[k]-&gt;</span>next = p;不会报错</div><div class="line">    H.count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-3]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-3<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试以顺序表L的L.rcd[L.length+1]作为监视哨，<br>改写教材3.2节中给出的升序直接插入排序算法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void InsertSort(RcdSqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i,j;</div><div class="line">   for(i=<span class="number">1</span>;i&lt;L.length;i++)&#123;</div><div class="line">     if(L.rcd[i+<span class="number">1</span>].<span class="type">key</span>&lt;L.rcd[i].<span class="type">key</span>)&#123;</div><div class="line">        L.rcd[<span class="number">0</span>]=L.rcd[i+<span class="number">1</span>];</div><div class="line">        j=i+<span class="number">1</span>;</div><div class="line">        do&#123;</div><div class="line">           j--;</div><div class="line">           L.rcd[j+<span class="number">1</span>] = L.rcd[j];</div><div class="line">        &#125;while(L.rcd[<span class="number">0</span>].<span class="type">key</span>&lt;L.rcd[j<span class="number">-1</span>].<span class="type">key</span>);</div><div class="line">        L.rcd[j] = L.rcd[<span class="number">0</span>];</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如下所述，改写教材1.3.2节例1-10的冒泡排序算法：<br>将算法中用以起控制作用的布尔变量change改为一个整型<br>变量，指示每一趟排序中进行交换的最后一个记录的位置，<br>并以它作为下一趟起泡排序循环终止的控制值。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void BubbleSort(RcdSqList &amp;L)</div><div class="line"><span class="comment">/* 元素比较和交换必须调用如下定义的比较函数和交换函数：*/</span></div><div class="line"><span class="comment">/* Status LT(RedType a, RedType b);   比较："&lt;"        */</span></div><div class="line"><span class="comment">/* Status GT(RedType a, RedType b);   比较："&gt;"        */</span></div><div class="line"><span class="comment">/* void Swap(RedType &amp;a, RedType &amp;b); 交换             */</span></div><div class="line">&#123;</div><div class="line">   int i,change,j,k;                                                  </div><div class="line">   for(i=L.length,change = <span class="number">0</span>;i&gt;<span class="number">1</span>;i--)&#123;</div><div class="line">       change = i;</div><div class="line">      for(j=<span class="number">1</span>;j&lt;i;++j)&#123;</div><div class="line">         if(GT(L.rcd[j],L.rcd[j+<span class="number">1</span>]))&#123;</div><div class="line">            Swap(L.rcd[j],L.rcd[j+<span class="number">1</span>]);</div><div class="line">            k++;</div><div class="line">            change = j+<span class="number">1</span>;</div><div class="line">         &#125;            </div><div class="line">      &#125;</div><div class="line">      while(L.rcd[change].<span class="type">key</span> == L.rcd[change<span class="number">-1</span>].<span class="type">key</span>) <span class="comment">//用while来跳过那些相同关键字</span></div><div class="line">             change=change - <span class="number">1</span>;</div><div class="line">      i=change;</div><div class="line">      if(k==<span class="number">0</span>)    <span class="comment">//当有一次比较没有交换时使i= 1结束操作</span></div><div class="line">         i=<span class="number">1</span>;</div><div class="line">     k=<span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知记录序列L.rcd[1..L.length]中的关键<br>字各不相同，可按如下所述实现计数排序：另设数组<br>c[1..n]，对每个记录a[i]， 统计序列中关键字比它<br>小的记录个数存于c[i]，则c[i]=0的记录必为关键字<br>最小的记录，然后依c[i]值的大小对序列中记录进行<br>重新排列。试编写算法实现上述排序方法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int     length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void CountSort(RcdSqList &amp;L)</div><div class="line"><span class="comment">/* 采用顺序表存储结构，在函数内自行定义计数数组c */</span></div><div class="line">&#123;</div><div class="line">   int k=L.<span class="built_in">length</span> ;</div><div class="line">   RcdSqList L1;</div><div class="line">   int c[<span class="number">27</span>];</div><div class="line">   int i,j;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span> ;i++)</div><div class="line">      <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=L.<span class="built_in">length</span>;j++)&#123;</div><div class="line">         <span class="keyword">if</span>(L.rcd[i].<span class="built_in">key</span>&lt;L.rcd[j].<span class="built_in">key</span>)</div><div class="line">            c[i]++;</div><div class="line">      &#125;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span>;i++)</div><div class="line">         L1.rcd[c[i]+<span class="number">1</span>].<span class="built_in">key</span>=L.rcd[i].<span class="built_in">key</span>;</div><div class="line">        </div><div class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L.<span class="built_in">length</span>;i++)       </div><div class="line">         L.rcd[L.<span class="built_in">length</span>-i+<span class="number">1</span>].<span class="built_in">key</span> = L1.rcd[i].<span class="built_in">key</span>;</div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-2]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-2<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的判空操作<br>StackEmpty_Sq(SqStack S)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq(SqStack S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的取栈顶元素操作<br>GetTop_Sq(SqStack S, ElemType &amp;e)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem;  // 存储空间的基址<br>  int top;         // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;        // 当前分配的存储容量<br>  int increment;   // 扩容时，增加的存储容量<br>} SqStack;         // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status GetTop_Sq(SqStack S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 取顺序栈S的栈顶元素到e，并返回OK； */</span> </div><div class="line"><span class="comment">/* 若失败，则返回ERROR。              */</span></div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span>(S.top==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">     e=S.elem[--S.top];</div><div class="line">     <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>构建初始容量和扩容增量分别为size和inc的空顺序栈S。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Status InitStack_Sq2(SqStack2 &amp;S, <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> inc)</div><div class="line"><span class="comment">/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/</span> </div><div class="line"><span class="comment">/* 若成功，则返回OK；否则返回ERROR。                 */</span></div><div class="line">&#123;</div><div class="line">    S.elem=(ElemType*)malloc(S.<span class="built_in">size</span>*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="built_in">if</span>(S.elem==NULL)   <span class="comment">//构建失败 </span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    <span class="built_in">if</span>(<span class="built_in">size</span>&lt;<span class="number">0</span>||inc&lt;<span class="number">0</span>)     <span class="comment">//参数错误</span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    S.<span class="built_in">size</span>=<span class="built_in">size</span>;</div><div class="line">    S.increment=inc;</div><div class="line">    S.top=S.elem;</div><div class="line">    <span class="built_in">return</span> OK;           </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的判空操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq2(SqStack2 S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==S.elem)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的入栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Status Push_Sq2(SqStack2 &amp;S, ElemType e)</div><div class="line"><span class="comment">/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*/</span></div><div class="line"><span class="comment">/* 将e压入S，返回OK。                          */</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">if</span>(S.<span class="built_in">size</span>==S.increment)  <span class="comment">//顺序栈已满</span></div><div class="line">        S.elem=(ElemType*)realloc(S.elem,(S.<span class="built_in">size</span>+S.increment)*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">    <span class="built_in">if</span>(S.elem==NULL)    <span class="comment">//顺序栈扩容失败</span></div><div class="line">        <span class="built_in">return</span> ERROR;</div><div class="line">    *S.top++=e;</div><div class="line">    S.<span class="built_in">size</span>=S.<span class="built_in">size</span>+S.increment;</div><div class="line">    <span class="built_in">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的出栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status Pop_Sq2(SqStack2 &amp;S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 若顺序栈S是空的，则返回ERROR；    */</span> </div><div class="line"><span class="comment">/* 否则将S的栈顶元素出栈到e，返回OK。*/</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(S.top==S.elem)   <span class="comment">//顺序栈为空  </span></div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    e=*(--S.top);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br>可调用顺序栈接口中下列函数：<br>Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈S<br>Status DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈S<br>Status StackEmpty_Sq(SqStack S);    // 栈S判空，若空则返回TRUE，否则FALSE<br>Status Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈S<br>Status Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e<br><strong><strong>**</strong></strong></em>/<br><strong>解题思路</strong>：栈是先进后出的，因此借用S3，需要用来两次倒序，第一次倒序插入S3，再将S3倒序插入S2，即所有元素正序，即完成复制顺序栈操作。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> CopyStack_Sq(SqStack <span class="built_in">S1</span>, SqStack &amp;<span class="built_in">S2</span>) </div><div class="line"><span class="comment">/* 借助辅助栈，复制顺序栈S1得到S2。    */</span> </div><div class="line"><span class="comment">/* 若复制成功，则返回TRUE；否则FALSE。 */</span></div><div class="line">&#123;</div><div class="line">     SqStack <span class="built_in">S3</span><span class="comment">;</span></div><div class="line">     int e<span class="comment">;</span></div><div class="line">     InitStack_Sq(<span class="built_in">S2</span>,<span class="built_in">S1</span>.size,<span class="built_in">S1</span>.increment)<span class="comment">;</span></div><div class="line">     InitStack_Sq(<span class="built_in">S3</span>,<span class="built_in">S1</span>.size,<span class="built_in">S1</span>.increment)<span class="comment">;</span></div><div class="line">     <span class="meta">while</span>(StackEmpty_Sq(<span class="built_in">S1</span>)!<span class="symbol">=TRUE</span>)&#123; //先将<span class="built_in">S1</span>元素倒序插入<span class="built_in">S3</span></div><div class="line">       <span class="keyword">Pop_Sq(S1,e);</span></div><div class="line"><span class="keyword"> </span>      <span class="keyword">Push_Sq(S3,e);</span></div><div class="line"><span class="keyword"> </span>      &#125;</div><div class="line">     <span class="meta">if</span>(<span class="built_in">S3</span>.elem=<span class="symbol">=NULL</span>)    //<span class="built_in">S1</span>倒序插入<span class="built_in">S3</span>失败</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">     <span class="meta">while</span>(StackEmpty_Sq(<span class="built_in">S3</span>)!<span class="symbol">=TRUE</span>)&#123; //再将<span class="built_in">S3</span>元素倒序插入<span class="built_in">S2</span></div><div class="line">       <span class="keyword">Pop_Sq(S3,e);</span></div><div class="line"><span class="keyword"> </span>      <span class="keyword">Push_Sq(S2,e);</span></div><div class="line"><span class="keyword"> </span>      &#125;</div><div class="line">     <span class="meta">if</span>(<span class="built_in">S2</span>.elem=<span class="symbol">=NULL</span>)   //<span class="built_in">S3</span>倒序插入<span class="built_in">S2</span>失败</div><div class="line">        return FALSE<span class="comment">;</span></div><div class="line">     return OK<span class="comment">;       </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，求循环队列的长度。<br>循环队列的类型定义为：<br>typedef struct {<br>  ElemType <em>base;  // 存储空间的基址<br>  int front;       // 队头位标<br>  int rear;        // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;     // 最大长度<br>} SqQueue;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> QueueLength_S<span class="string">q(SqQueue Q)</span></div><div class="line">/* 返回队列Q中元素个数，即队列的长度。 *<span class="regexp">/ </span></div><div class="line"><span class="regexp">&#123;</span></div><div class="line"><span class="regexp">   return (Q.rear-Q.front+Q.maxSize)%Q.maxSize;</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如果希望循环队列中的元素都能得到利用，<br>则可设置一个标志域tag，并以tag值为0或1来区分尾<br>指针和头指针值相同时的队列状态是”空”还是”满”。<br>试编写与此结构相应的入队列和出队列的算法。<br>本题的循环队列CTagQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int tag;<br>  int front;<br>  int rear;<br>} CTagQueue;<br><strong><strong>**</strong></strong>/<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CTagQueue &amp;Q,ElemType x)</div><div class="line"><span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></div><div class="line"><span class="comment">/* 若失败，则返回ERROR。       */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(Q.<span class="attr">tag==1&amp;&amp;Q.front==Q.rear)</span></div><div class="line">        return ERROR;</div><div class="line">   Q.elem[Q.rear]=x;</div><div class="line">   Q.<span class="attr">rear=(Q.rear+1)%MAXQSIZE;</span></div><div class="line">   <span class="keyword">if</span>(Q.<span class="attr">front==Q.rear)</span></div><div class="line">   Q.<span class="attr">tag=1;</span></div><div class="line">   return OK ;</div><div class="line">&#125; </div><div class="line"></div><div class="line">Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)</div><div class="line"><span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></div><div class="line"><span class="comment">/* 若失败，则返回ERROR。               */</span></div><div class="line">&#123; </div><div class="line">     <span class="keyword">if</span>(Q.<span class="attr">tag==0&amp;&amp;Q.front==Q.rear)</span></div><div class="line">       return ERROR;</div><div class="line">      <span class="attr">x=Q.elem[Q.front];</span></div><div class="line">      Q.<span class="attr">front=(Q.front+1)%MAXQSIZE;</span></div><div class="line">      <span class="keyword">if</span>(Q.<span class="attr">front==Q.rear)</span></div><div class="line">         Q.<span class="attr">tag=0;</span></div><div class="line">      return OK; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】假设将循环队列定义为：以域变量rear<br>和length分别指示循环队列中队尾元素的位置和内<br>含元素的个数。试给出此循环队列的队满条件，并<br>写出相应的入队列和出队列的算法（在出队列的算<br>法中要返回队头元素）。<br>本题的循环队列CLenQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int length;<br>  int rear;<br>} CLenQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CLenQueue &amp;Q, ElemType x)</div><div class="line">  <span class="comment">/* 将元素x加入队列Q，并返回OK；*/</span></div><div class="line">  <span class="comment">/* 若失败，则返回ERROR。       */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.<span class="built_in">length</span>==MAXQSIZE)  <span class="comment">//队列满</span></div><div class="line">      <span class="keyword">return</span> ERROR;</div><div class="line">    Q.elem[Q.rear]=x;</div><div class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXQSIZE; </div><div class="line">    Q.<span class="built_in">length</span>++;</div><div class="line">    <span class="keyword">return</span> TRUE;</div><div class="line">&#125;</div><div class="line">Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x)</div><div class="line">  <span class="comment">/* 将队列Q的队头元素退队到x，并返回OK；*/</span></div><div class="line">  <span class="comment">/* 若失败，则返回ERROR。               */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.<span class="built_in">length</span>==<span class="number">0</span>)     <span class="comment">//队列空</span></div><div class="line">        <span class="keyword">return</span> ERROR;   </div><div class="line">    <span class="type">int</span> front;         </div><div class="line">    front=MAXQSIZE-Q.<span class="built_in">length</span>+Q.rear;</div><div class="line">    x=Q.elem[front%MAXQSIZE];</div><div class="line">    front=(front+<span class="number">1</span>)%MAXQSIZE;</div><div class="line">    Q.<span class="built_in">length</span>--;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶斐波那契序列的定义为:<br>    f0=0,  f1=0,  …,  fk-2=0,  fk-1=1;<br>    fn=fn-1+fn-2+…+fn-k,  n=k,k+1,…<br>试利用循环队列编写求k阶斐波那契序列中第<br>n+1项fn的算法。</p>
<p>本题的循环队列的类型定义如下：<br>typedef struct {<br>  ElemType <em>base; // 存储空间的基址<br>  int front;      // 队头位标<br>  int rear;       // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;    // 最大长度<br>} SqQueue;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">long Fib(int k, int n)</div><div class="line"><span class="comment">/* 求k阶斐波那契序列的第n+1项fn */</span></div><div class="line">&#123;</div><div class="line">    int i,j ;</div><div class="line">   <span class="keyword">if</span>(<span class="number">1</span> &gt;=k|| <span class="number">0</span> &gt; n) <span class="built_in">return</span> ERROR;</div><div class="line">   SqQueue <span class="built_in">fib</span>;</div><div class="line">   <span class="built_in">fib</span>.base = (ElemType*)malloc(<span class="number">30</span>*sizeof(ElemType));</div><div class="line">   <span class="built_in">fib</span>.maxSize = <span class="number">30</span>;</div><div class="line">   <span class="built_in">fib</span>.front = <span class="built_in">fib</span>.rear = <span class="number">0</span>;</div><div class="line">   <span class="keyword">for</span>(;<span class="built_in">fib</span>.rear &lt; k;<span class="built_in">fib</span>.rear++)</div><div class="line">   &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">fib</span>.rear&lt;k-<span class="number">1</span>) </div><div class="line">            <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] = <span class="number">1</span>;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="keyword">while</span>(<span class="built_in">fib</span>.rear &lt;= n)</div><div class="line">   &#123;</div><div class="line">        j = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(j &lt;= k)</div><div class="line">        &#123;</div><div class="line">             <span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear] +=<span class="built_in">fib</span>.base[<span class="built_in">fib</span>.rear-j];</div><div class="line">             j++;</div><div class="line">         &#125;</div><div class="line">        <span class="built_in">fib</span>.rear++;</div><div class="line">  &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">fib</span>.base[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】设A=(a1,…,am)和B=(b1,…,bn)均为有序顺序表，<br>A’和B’分别为A和B中除去最大共同前缀后的子表（例如，<br>A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大<br>的共同前缀为(x,y,y,z)， 在两表中除去最大共同前缀后<br>的子表分别为A’=(x,z)和B’=(y,x,x,z)）。若A’=B’=空表，<br>则A=B；若A’=空表，而B’≠ 空表，或者两者均不为空表，<br>且A’的首元小于B’的首元，则A<b；否则a>B。试写一个比<br>较A和B大小的算法。（注意：在算法中，不要破坏原表A<br>和B，也不一定先求得A’和B’才进行比较）。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</b；否则a></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">char Compare(SqList A, SqList B)</div><div class="line"><span class="comment">/* 比较顺序表A和B,      */</span></div><div class="line"><span class="comment">/*   返回'&lt;', 若A&lt;B;    */</span></div><div class="line"><span class="comment">/*       '=', 若A=B;    */</span></div><div class="line"><span class="comment">/*       '&gt;', 若A&gt;B     */</span></div><div class="line">&#123;     </div><div class="line">    int i=<span class="number">0</span>;  //计数器    </div><div class="line">    <span class="keyword">while</span>(A.<span class="built_in">elem</span>[i]==B.<span class="built_in">elem</span>[i]&amp;&amp;i&lt;A.<span class="built_in">length</span>&amp;&amp;i&lt;B.<span class="built_in">length</span>)         </div><div class="line">        i++;      </div><div class="line">    <span class="keyword">if</span>(A.<span class="built_in">length</span>==B.<span class="built_in">length</span>)</div><div class="line">        <span class="built_in">return</span> '=';      </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.<span class="built_in">elem</span>[i]&lt;B.<span class="built_in">elem</span>[i]||i==A.<span class="built_in">length</span>)         </div><div class="line">        <span class="built_in">return</span> '&lt;';      </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(A.<span class="built_in">elem</span>[i]&gt;B.<span class="built_in">elem</span>[i]||i==B.<span class="built_in">length</span>) </div><div class="line">        <span class="built_in">return</span> '&gt;';</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序表的就地逆置，<br>即利用原表的存储空间将线性表(a1,a2,…,an)<br>逆置为(an,an-1,…,a1)。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Inverse(SqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i;</div><div class="line">   int temp;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.<span class="built_in">length</span>/<span class="number">2</span>;i++) &#123;</div><div class="line">       temp=L.<span class="built_in">elem</span>[i];</div><div class="line">       L.<span class="built_in">elem</span>[i]=L.<span class="built_in">elem</span>[L.<span class="built_in">length</span>-i-<span class="number">1</span>];</div><div class="line">       L.<span class="built_in">elem</span>[L.<span class="built_in">length</span>-i-<span class="number">1</span>]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式<br>项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0<br>为给定值）。<br>一元稀疏多项式的顺序存储结构:<br>typedef struct {<br>  int  coef;  // 系数<br>  int   exp;  // 指数<br>} Term;<br>typedef struct {<br>  Term  <em>elem;   // 存储空间基址<br>  int    length; // 长度（项数）<br>} Poly;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">float</span> Evaluate(Poly P, <span class="built_in">float</span> x)</div><div class="line"><span class="comment">/* P.elem[i].coef 存放ai，                        */</span></div><div class="line"><span class="comment">/* P.elem[i].exp存放ei (i=1,2,...,m)              */</span></div><div class="line"><span class="comment">/* 本算法计算并返回多项式的值。不判别溢出。       */</span></div><div class="line"><span class="comment">/* 入口时要求0≤e1&lt;e2&lt;...&lt;em，算法内不对此再作验证 */</span></div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    <span class="built_in">float</span> <span class="built_in">sum</span>=<span class="number">0</span>,sum1;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;P.<span class="built_in">length</span>;i++)</div><div class="line">    &#123;</div><div class="line">        sum1=P.<span class="built_in">elem</span>[i].coef ;</div><div class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;P.<span class="built_in">elem</span>[i].<span class="built_in">exp</span>;j++)</div><div class="line">          sum1=sum1*x;</div><div class="line">        <span class="built_in">sum</span>+=sum1;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> <span class="built_in">sum</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有两个集合A和B分别用两个线性表LA和LB<br>表示(即：线性表中的数据元素即为集合中的成员），<br>试写一算法，求并集A＝A∪B。<br>顺序表类型定义如下<br>typedef struct {<br>  ElemType <em>elem;     // 存储空间的基址<br>  int length;    // 当前长度<br>  int size;      // 存储容量<br>  int increment; // 空间不够增加空间大小<br>} SqList;  // 顺序表<br>可调用顺序表的以下接口函数：<br>Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表L<br>int ListLength_Sq(SqList L);  // 返回顺序表L中元素个数<br>Status GetElem_Sq(SqList L, int i, ElemType &amp;e);<br>// 用e返回顺序表L中第i个元素的值<br>int Search_Sq(SqList L, ElemType e);<br>// 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1<br>Status Append_Sq(SqList &amp;L, ElemType e);  // 在顺序表L表尾添加元素e<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Union(SqList &amp;La, SqList Lb)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i,j;</div><div class="line">    ElemType e;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;Lb.length;i++)&#123;     </div><div class="line">         GetElem_S<span class="string">q(Lb,i+1,e)</span>;</div><div class="line">         <span class="keyword">if</span>(-<span class="number">1</span>==Search_S<span class="string">q(La,e)</span>)</div><div class="line">            Append_S<span class="string">q(La,e)</span>;</div><div class="line">    &#125;</div><div class="line">    La.length = ListLength_S<span class="string">q(La)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的判空操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_L(LStack S)</div><div class="line">/* 对链栈S判空。若S是空栈，则返回<span class="literal">TRUE</span>；否则返回<span class="literal">FALSE</span> */</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(S==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">TRUE</span>;</div><div class="line">   <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的取栈顶元素操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status GetTop_L(LStack S, ElemType &amp;e) </div><div class="line"><span class="comment">/* 取链栈S的栈顶元素到e，并返回OK; */</span></div><div class="line"><span class="comment">/* 若S是空栈，则失败，返回ERROR。  */</span></div><div class="line">&#123;</div><div class="line">    LSNode *p;</div><div class="line">    <span class="keyword">if</span>(S==NULL)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        e=S-&gt;<span class="keyword">data</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的判空操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status QueueEmpty_LQ(LQueue Q)</div><div class="line"><span class="comment">/* 判定链队列Q是否为空队列。           */</span></div><div class="line"><span class="comment">/* 若Q是空队列，则返回TRUE，否则FALSE。*/</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(Q.rear==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的求队列长度操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">QueueLength_LQ</span><span class="params">(LQueue Q)</span></span></div><div class="line"><span class="function"><span class="comment">/* 求链队列Q的长度并返回其值 */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   LQNode *p=Q.front;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">   <span class="keyword">if</span>(Q.rear==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">   <span class="keyword">while</span>(p!=Q.rear)&#123;</div><div class="line">       p = p-&gt;next;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设以带头结点的循环链表表示队列，并且<br>只设一个指针指向队尾元素结点(注意不设头指针)，<br>试编写相应的队列初始化、入队列和出队列的算法。<br>带头结点循环链队列CLQueue的类型定义为：<br>typedef struct LQNode {<br>  ElemType data;<br>  struct LQNode <em>next;<br>} LQNode, </em>CLQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Status InitCLQueue(CLQueue &amp;rear) <span class="comment">// 初始化空队列</span></div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status EnCLQueue(CLQueue &amp;rear, ElemType x) <span class="comment">// 入队</span></div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>=rear-&gt;</span>next;</div><div class="line">    <span class="function"><span class="title">rear</span>-&gt;</span>next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeCLQueue(CLQueue &amp;rear, ElemType &amp;x) <span class="comment">// 出队</span></div><div class="line">&#123; </div><div class="line">   <span class="function"><span class="title">if</span>(rear==rear-&gt;</span>next)</div><div class="line">       return ERROR;</div><div class="line">   <span class="keyword">else</span>&#123;</div><div class="line">       <span class="function"><span class="title">x</span>=rear-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="keyword">data</span>;</div><div class="line">       <span class="function"><span class="title">rear</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>=rear-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</div><div class="line">    &#125;    </div><div class="line">  return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的判空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status ListEmpty_L(LinkList L)</div><div class="line"><span class="comment">/* 判定带头结点单链表L是否为空链表。   */</span></div><div class="line"><span class="comment">/* 若L是空链表，则返回TRUE，否则FALSE。*/</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(<span class="keyword">NULL</span> == L-&gt;<span class="keyword">next</span>) </div><div class="line">        <span class="keyword">return</span> <span class="keyword">TRUE</span>;</div><div class="line">    <span class="keyword">return</span>  <span class="keyword">FALSE</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的销毁操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">DestroyList_L</span><span class="params">(LinkList &amp;L)</span></span></div><div class="line"><span class="function"><span class="comment">/* 销毁带头结点单链表L，并返回OK。*/</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">free</span>(L);</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的清空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status ClearList_L(LinkList &amp;L)</div><div class="line"><span class="comment">/* 将带头结点单链表L置为空表，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若L不是带头结点单链表，则返回ERROR。 */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(L==<span class="keyword">NULL</span>) </div><div class="line">      <span class="keyword">return</span> ERROR;</div><div class="line">   <span class="keyword">if</span>(L-&gt;<span class="keyword">next</span>==<span class="keyword">NULL</span>) </div><div class="line">      <span class="keyword">return</span> OK;</div><div class="line">   L-&gt;<span class="keyword">next</span>=<span class="keyword">NULL</span>;</div><div class="line">   <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的求表长度操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> ListLength_L(LinkList L)</div><div class="line"><span class="comment">/* 求带头结点单链表L的长度，并返回长度值。*/</span></div><div class="line"><span class="comment">/* 若L不是带头结点单链表，则返回-1。      */</span></div><div class="line">&#123;  </div><div class="line">   LNode *p;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">   <span class="keyword">if</span>(<span class="keyword">NULL</span>==L)</div><div class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">   p = L-&gt;<span class="keyword">next</span>;</div><div class="line">   <span class="keyword">while</span>(p != <span class="keyword">NULL</span>)&#123;</div><div class="line">      p = p-&gt;<span class="keyword">next</span>;</div><div class="line">      i++;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> i;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表L插入第i元素e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Status <span class="keyword">Insert_L(LinkList </span>L, int i, ElemType e)</div><div class="line"><span class="comment">/* 在带头结点单链表L插入第i元素e，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若参数不合理，则返回ERROR。              */</span> </div><div class="line">&#123;</div><div class="line">    if(i==<span class="number">0</span>)</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    LinkList p,q,p1,<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>   int <span class="keyword">j=0,k=0;</span></div><div class="line"><span class="keyword"> </span>   q=(LNode*)malloc(sizeof(LNode))<span class="comment">;</span></div><div class="line">    q-&gt;data=e<span class="comment">;</span></div><div class="line">    q-&gt;next=NULL<span class="comment">;</span></div><div class="line">    p1=L<span class="comment">;</span></div><div class="line">    <span class="keyword">b=L;</span></div><div class="line"><span class="keyword"> </span>   while(<span class="keyword">b!=NULL)&#123; </span>       </div><div class="line">        <span class="keyword">b=b-&gt;next;</span></div><div class="line"><span class="keyword"> </span>       k++<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    if(k&lt;i)</div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    while(<span class="keyword">j&lt;i)&#123;</span></div><div class="line"><span class="keyword"> </span>       p=p1<span class="comment">;</span></div><div class="line">        p1=p-&gt;next<span class="comment">;</span></div><div class="line">        <span class="keyword">j++; </span>   </div><div class="line">    &#125;</div><div class="line">    q-&gt;next=p-&gt;next<span class="comment">;</span></div><div class="line">    p-&gt;next=q<span class="comment">;</span></div><div class="line">    return OK<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表的第i元素起的<br>所有元素从链表移除，并构成一个带头结点的新链表。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Status Split_L(LinkList L, LinkList &amp;Li, <span class="keyword">int</span> i)</div><div class="line"><span class="comment">/* 在带头结点单链表L的第i元素起的所有元素 */</span></div><div class="line"><span class="comment">/* 移除，并构成带头结点链表Li，返回OK。   */</span></div><div class="line"><span class="comment">/* 若参数不合理，则Li为NULL，返回ERROR。  */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span>(i&lt;=<span class="number">0</span>||L==<span class="keyword">null</span>) &#123;</div><div class="line">     Li==<span class="keyword">null</span>;</div><div class="line">     <span class="keyword">return</span> ERROR;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   LinkList a,b,c;</div><div class="line">   <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">   Li=(LNode*)malloc(sizeof(LNode));</div><div class="line">   Li-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">   a=L;</div><div class="line">   b=L;</div><div class="line">   <span class="keyword">while</span>(a-&gt;<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</div><div class="line">     j++;</div><div class="line">     a=a-&gt;<span class="keyword">next</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">if</span>(j&lt;i) &#123;</div><div class="line">   Li=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">return</span> ERROR;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">while</span>(k&lt;i-<span class="number">1</span>)&#123;</div><div class="line">   b=b-&gt;<span class="keyword">next</span>;</div><div class="line">   k++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   c=b-&gt;<span class="keyword">next</span>;</div><div class="line">   Li-&gt;<span class="keyword">next</span>=c;</div><div class="line">   b-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">   <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素<br>起的所有元素。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Status Cut_L(LinkList L, <span class="keyword">int</span> i)</div><div class="line"><span class="comment">/* 在带头结点单链表L删除第i元素起的所有元素，并返回OK。*/</span></div><div class="line"><span class="comment">/* 若参数不合理，则返回ERROR。                         */</span></div><div class="line">&#123;</div><div class="line">    LinkList p1,p2,p3;</div><div class="line">    <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">0</span>;</div><div class="line">    p2=L;</div><div class="line">    p1=L;</div><div class="line">    p3=L;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">NULL</span>==L||L-&gt;<span class="keyword">next</span>==<span class="keyword">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">        </div><div class="line">    <span class="keyword">while</span>(p1-&gt;<span class="keyword">next</span>!=<span class="keyword">null</span>)&#123;</div><div class="line">       p1=p1-&gt;<span class="keyword">next</span>;</div><div class="line">       j++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(j&lt;i||i==<span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line"> </div><div class="line">    <span class="keyword">while</span>(k&lt;i)&#123;</div><div class="line">       p2=p3;</div><div class="line">       p3=p2-&gt;<span class="keyword">next</span>;</div><div class="line">       k++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    p2-&gt;<span class="keyword">next</span>=<span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>为x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> DeleteX_L(LinkList L, ElemType x)</div><div class="line"><span class="comment">/* 删除带头结点单链表L中所有值为x的元素，      */</span></div><div class="line"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></div><div class="line">&#123;</div><div class="line">    LinkList <span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span><span class="comment">;</span></div><div class="line">    int j<span class="number">=0</span><span class="comment">;</span></div><div class="line">    <span class="meta">if</span>(NULL=<span class="symbol">=L</span>) </div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    <span class="built_in">p1</span><span class="symbol">=p2</span><span class="symbol">=L</span><span class="comment">;</span></div><div class="line">    <span class="meta">while</span>(<span class="built_in">p2</span>!<span class="symbol">=NULL</span>)&#123;</div><div class="line">      <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">      <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>=<span class="symbol">=x</span>)&#123;</div><div class="line">        <span class="built_in">p3</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        <span class="built_in">p2</span><span class="symbol">=p3</span>-&gt;next<span class="comment">;</span></div><div class="line">        <span class="built_in">p1</span>-&gt;next<span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        free(<span class="built_in">p3</span>)<span class="comment">;</span></div><div class="line">        j++<span class="comment">;</span></div><div class="line">      &#125;</div><div class="line">      <span class="meta">else</span> <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>!<span class="symbol">=x</span>)&#123;</div><div class="line">          <span class="built_in">p1</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">          <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>小于x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">Status</span> DeleteSome_L(LinkList L, ElemType x)</div><div class="line"><span class="comment">/* 删除带头结点单链表L中所有值小于x的元素，    */</span></div><div class="line"><span class="comment">/* 并释放被删结点空间，返回实际删除的元素个数。*/</span></div><div class="line">&#123;</div><div class="line">    LinkList <span class="built_in">p1</span>,<span class="built_in">p2</span>,<span class="built_in">p3</span><span class="comment">;</span></div><div class="line">    int j<span class="number">=0</span><span class="comment">;</span></div><div class="line">    <span class="meta">if</span>(NULL=<span class="symbol">=L</span>) </div><div class="line">        return ERROR<span class="comment">;</span></div><div class="line">    <span class="built_in">p1</span><span class="symbol">=p2</span><span class="symbol">=L</span><span class="comment">;</span></div><div class="line">    <span class="meta">while</span>(<span class="built_in">p2</span>!<span class="symbol">=NULL</span>)&#123;</div><div class="line">      <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">      <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>&lt;x&amp;&amp;<span class="built_in">p2</span>!<span class="symbol">=null</span>)&#123;</div><div class="line">        <span class="built_in">p3</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        <span class="built_in">p2</span><span class="symbol">=p3</span>-&gt;next<span class="comment">;</span></div><div class="line">        <span class="built_in">p1</span>-&gt;next<span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">        free(<span class="built_in">p3</span>)<span class="comment">;</span></div><div class="line">        j++<span class="comment">;</span></div><div class="line">      &#125;</div><div class="line">      <span class="meta">else</span> <span class="meta">if</span>(<span class="built_in">p2</span>-&gt;<span class="meta">data</span>&gt;<span class="symbol">=x</span>)&#123;</div><div class="line">          <span class="built_in">p1</span><span class="symbol">=p2</span><span class="comment">;</span></div><div class="line">          <span class="built_in">p2</span><span class="symbol">=p1</span>-&gt;next<span class="comment">;</span></div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-1]]></title>
      <url>/2017/10/24/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-1<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，如果三个整数a，b和c的值<br>不是依次非递增的，则通过交换，令其为非递增。<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void Descend(int &amp;a, int &amp;<span class="keyword">b, </span>int &amp;c)</div><div class="line"><span class="comment">/* 通过交换，令 a &gt;= b &gt;= c */</span></div><div class="line">&#123;</div><div class="line">    int temp<span class="comment">;</span></div><div class="line">    if(c&gt;=<span class="keyword">b)</span></div><div class="line"><span class="keyword"> </span>   &#123;</div><div class="line">        temp=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=c;</span></div><div class="line"><span class="keyword"> </span>       c=temp<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    if(<span class="keyword">b&gt;=a)</span></div><div class="line"><span class="keyword"> </span>   &#123;</div><div class="line">        temp=a<span class="comment">;</span></div><div class="line">        a=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=temp;</span></div><div class="line"><span class="keyword"> </span>   &#125;</div><div class="line">    if(c&gt;=<span class="keyword">b)&#123;</span></div><div class="line"><span class="keyword"> </span>       temp=<span class="keyword">b;</span></div><div class="line"><span class="keyword"> </span>       <span class="keyword">b=c;</span></div><div class="line"><span class="keyword"> </span>       c=temp<span class="comment">;</span></div><div class="line">    &#125;            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法求一元多项式<br>    P(x) = a0 + a1x + a2x^2 + … + anx^n<br>的值P(x0)，并确定算法中每一语句的执行次数和整个算法<br>的时间复杂度。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">float</span> <span class="title">Polynomial</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> a[], <span class="keyword">float</span> x)</span></span></div><div class="line"><span class="function"><span class="comment">/* 求一元多项式的值P(x)。                  */</span></span></div><div class="line"><span class="function"><span class="comment">/* 数组a的元素a[i]为i次项的系数，i=0,...,n */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">double</span> px;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</div><div class="line">        px+=a[i]*<span class="built_in">pow</span>(x,i);</div><div class="line">    <span class="keyword">return</span> px;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶裴波那契序列的定义为<br>    f(0)=0, f(1)=0, …, f(k-2)=0, f(k-1)=1;<br>    f(n)=f(n-1)+f(n-2)+…+f(n-k), n=k,k+1,…<br>试编写求k阶裴波那契序列的第m项值的函数算法，<br>k和m均以值调用的形式在函数参数表中出现。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status Fibonacci(<span class="keyword">int</span> k, <span class="keyword">int</span> m, <span class="keyword">int</span> &amp;f) </div><div class="line"><span class="comment">/* 求k阶斐波那契序列的第m项的值f */</span></div><div class="line">&#123;    </div><div class="line">    <span class="keyword">int</span> t[<span class="number">60</span>],<span class="keyword">sum</span>,i,j;</div><div class="line">    <span class="keyword">if</span>(k&lt;<span class="number">2</span>||m&lt;<span class="number">0</span>) </div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    <span class="keyword">if</span>(m&lt;k<span class="number">-1</span>) </div><div class="line">        f=<span class="number">0</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m==k<span class="number">-1</span>) </div><div class="line">        f=<span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k<span class="number">-2</span>;i++)&#123;</div><div class="line">        t[i]=<span class="number">0</span>;</div><div class="line">        t[k<span class="number">-1</span>]=<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(i=k;i&lt;=m;i++)&#123;</div><div class="line">            <span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(j=i-k;j&lt;i;j++)</div><div class="line">                <span class="keyword">sum</span>+=t[j];</div><div class="line">            t[i]=<span class="keyword">sum</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    f=t[m];</div><div class="line">    &#125;                                                                                </div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法，计算i!×2^i的值并存入数组<br>a[0..n-1]的第i-1个分量中 (i=1,2,…,n)。假设计<br>算机中允许的整数最大值为MAXINT，则当对某个k<br>(1≤k≤n)使k!×2^k&gt;MAXINT时，应按出错处理。注意<br>选择你认为较好的出错处理方法。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status Series(<span class="keyword">int</span> a[], <span class="keyword">int</span> n) </div><div class="line"><span class="comment">/* 求i!*2^i序列的值并依次存入长度为n的数组a；     */</span></div><div class="line"><span class="comment">/* 若所有值均不超过MAXINT，则返回OK，否则OVERFLOW */</span></div><div class="line">&#123;</div><div class="line">   <span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> sum1=<span class="number">1</span>,sum2=<span class="number">1</span>;</div><div class="line">   <span class="keyword">int</span> j;</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">            sum1=sum1*j;</div><div class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>;j--)</div><div class="line">            sum2=sum2*<span class="number">2</span>;    </div><div class="line">    <span class="keyword">sum</span>=sum1*sum2;</div><div class="line">        </div><div class="line">    <span class="keyword">if</span>(sum1&gt;MAXINT||sum2&gt;MAXINT||<span class="keyword">sum</span>&gt;MAXINT)</div><div class="line">        <span class="keyword">return</span> OVERFLOW;             </div><div class="line">        </div><div class="line">    a[i<span class="number">-1</span>]=<span class="keyword">sum</span>;</div><div class="line">    </div><div class="line">    sum1=<span class="number">1</span>;<span class="comment">//归位</span></div><div class="line">    sum2=<span class="number">1</span>;<span class="comment">//归位</span></div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span>  OK;            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有A、B、C、D、E五个高等院校进行田径对抗赛，<br>各院校的单项成绩均以存入计算机并构成一张表，表中每一行<br>的形式为：<br>        项目名称   性别   校名   成绩   得分<br>编写算法，处理上述表格，以统计各院校的男、女总分和团体<br>总分，并输出。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">void Scores(ResultType *result, ScoreType *<span class="built_in">score</span>)</div><div class="line"><span class="comment">/* 求各校的男、女总分和团体总分, 并依次存入数组score */</span></div><div class="line"><span class="comment">/* 假设比赛结果已经储存在result[ ]数组中,            */</span></div><div class="line"><span class="comment">/* 并以特殊记录 &#123;"", male, ' ', "", 0 &#125;（域scorce=0）*/</span></div><div class="line"><span class="comment">/* 表示结束                                          */</span></div><div class="line">&#123;</div><div class="line">typedef enum &#123;female,male&#125; Sex;</div><div class="line">typedef struct&#123;</div><div class="line">  char *sport;     <span class="comment">// 项目名称</span></div><div class="line">  Sex  gender;     <span class="comment">// 性别（女：female；男：male）</span></div><div class="line">  char schoolname; <span class="comment">// 校名为'A','B','C','D'或'E'</span></div><div class="line">  char *result;    <span class="comment">// 成绩</span></div><div class="line">  int <span class="built_in">score</span>;       <span class="comment">// 得分（7,5,4,3,2或1）</span></div><div class="line">&#125; ResultType; </div><div class="line">typedef struct&#123;</div><div class="line">  int malescore;   <span class="comment">// 男子总分</span></div><div class="line">  int femalescore; <span class="comment">// 女子总分</span></div><div class="line">  int totalscore;  <span class="comment">// 男女团体总分</span></div><div class="line">&#125; ScoreType;</div><div class="line"></div><div class="line">int i=<span class="number">0</span>;</div><div class="line"> <span class="keyword">while</span>(result[i].sport!=NULL)  </div><div class="line"> &#123;  </div><div class="line"> <span class="keyword">switch</span>(result[i].schoolname)     <span class="comment">/*使用switch语句记录各院校的成绩*/</span></div><div class="line"> &#123;  </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'A'</span>:  </div><div class="line"> <span class="built_in">score</span>[<span class="number">0</span>].totalscore+=result[i].<span class="built_in">score</span>;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">0</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">0</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'B'</span>:  </div><div class="line"> <span class="built_in">score</span>[<span class="number">1</span>].totalscore+=result[i].<span class="built_in">score</span>;</div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">1</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">1</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'C'</span>:  </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">2</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">2</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">2</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'D'</span>:  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">3</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">3</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">3</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> <span class="keyword">case</span> <span class="string">'E'</span>: </div><div class="line">  </div><div class="line"></div><div class="line"> <span class="built_in">score</span>[<span class="number">4</span>].totalscore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">if</span>(result[i].gender==male)  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">4</span>].malescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> <span class="keyword">else</span>  </div><div class="line"></div><div class="line">    <span class="built_in">score</span>[<span class="number">4</span>].femalescore+=result[i].<span class="built_in">score</span>;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> i++;  </div><div class="line"></div><div class="line"> &#125;  </div><div class="line"></div><div class="line">    int j;  </div><div class="line"></div><div class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)  &#123;</div><div class="line"></div><div class="line">        printf(<span class="string">"the school %s: "</span>, result[i].schoolname) ;   <span class="comment">/*输出各院校的男女总分和团体总分*/</span></div><div class="line"></div><div class="line">        printf(<span class="string">"total: %f"</span>,&amp;<span class="built_in">score</span>[i].totalscore);  </div><div class="line"></div><div class="line">        printf(<span class="string">"male: %f"</span>,&amp;<span class="built_in">score</span>[i].malescore);  </div><div class="line"></div><div class="line">        printf(<span class="string">"female: %f"</span>,&amp;<span class="built_in">score</span>[i].femalescore);  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，对序列S的第i个元素赋以值e。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">Assign</span><span class="params">(Sequence &amp;S, <span class="keyword">int</span> i, ElemType e)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 对序列S的第i个元素赋以值e，并返回OK。 */</span></span></div><div class="line"><span class="function"><span class="comment">/* 若S或i不合法，则赋值失败，返回ERROR   */</span></span></div><div class="line"><span class="function"></span>&#123;    </div><div class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;=S.length||S.elem==<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">    S.elem[i]=e;</div><div class="line">    <span class="keyword">return</span> OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，由长度为n的一维数组a构建一个序列S。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">Status <span class="title">CreateSequence</span><span class="params">(Sequence &amp;S, <span class="keyword">int</span> n, ElemType *a)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 由长度为n的一维数组a构建一个序列S，并返回OK。 */</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回ERROR                       */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">   <span class="keyword">int</span> i;</div><div class="line">   <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> ERROR;</div><div class="line">   S.elem=(ElemType*)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(ElemType));</div><div class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</div><div class="line">        S.elem[i]=a[i];</div><div class="line">   S.length=n;     </div><div class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建一个值为x的结点。<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function">LinkList <span class="title">MakeNode</span><span class="params">(ElemType x)</span></span></div><div class="line"><span class="function"><span class="comment">/* 构建一个值为x的结点，并返回其指针。*/</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回NULL。           */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     LNode *p;</div><div class="line">     p=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">     <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">     p-&gt;next=<span class="literal">NULL</span>;</div><div class="line">     p-&gt;data=x;</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2且两个结点的值依次为x和y的链表。<br><strong><strong>**</strong></strong>/<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">LinkList <span class="title">CreateLinkList</span><span class="params">(ElemType x, ElemType y)</span> </span></div><div class="line"><span class="function"><span class="comment">/* 构建其两个结点的值依次为x和y的链表。*/</span></span></div><div class="line"><span class="function"><span class="comment">/* 若构建失败，则返回NULL。            */</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">      LNode *p;</div><div class="line">      LNode *q;</div><div class="line">      p=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">      <span class="keyword">if</span>(p==<span class="literal">NULL</span>)  <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;        </div><div class="line">      q=(LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</div><div class="line">      <span class="keyword">if</span>(q==<span class="literal">NULL</span>)  <span class="comment">//构建失败</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">      p-&gt;next=q;</div><div class="line">      q-&gt;next=<span class="literal">NULL</span>;</div><div class="line">      p-&gt;data=x;</div><div class="line">      q-&gt;data=y;</div><div class="line">      <span class="keyword">return</span> p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2的升序链表，两个结点的值<br>分别为x和y，但应小的在前，大的在后。<br><strong><strong>**</strong></strong>/<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">LinkList CreateOrdLList(ElemType x, ElemType y)</div><div class="line"><span class="comment">/* 构建长度为2的升序链表。  */</span></div><div class="line"><span class="comment">/* 若构建失败，则返回NULL。 */</span></div><div class="line">&#123;</div><div class="line">    LNode *p;</div><div class="line">    LNode *q;</div><div class="line">    </div><div class="line">    p=(LNode*)malloc(sizeof(LNode));</div><div class="line">    <span class="keyword">if</span>(p==NULL)</div><div class="line">        return NULL;</div><div class="line">        </div><div class="line">    q=(LNode*)malloc(sizeof(LNode));</div><div class="line">    <span class="keyword">if</span>(q==NULL)</div><div class="line">        return NULL;</div><div class="line">                </div><div class="line">    <span class="function"><span class="title">p</span>-&gt;</span>next=q;</div><div class="line">    <span class="function"><span class="title">q</span>-&gt;</span>next=NULL;</div><div class="line">    <span class="keyword">if</span>(x&lt;y)&#123;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=y;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="function"><span class="title">p</span>-&gt;</span><span class="keyword">data</span>=y;</div><div class="line">        <span class="function"><span class="title">q</span>-&gt;</span><span class="keyword">data</span>=x;</div><div class="line">    &#125;</div><div class="line">    return p;                            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> Anyview-GDUT </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代数系统]]></title>
      <url>/2017/10/24/%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>-代数系统概念与性质</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>如果“*”是AXA到A的二元运算，则称运算“*”对集合A是<strong>封闭</strong>的，或者称“*”是A上的二元运算</p>
<hr>
<p>设A是非空集合,<em>1,</em>2,…,<em>m分别是定义在A上的k1,k2,…,km元封闭运算，ki是正整数，i=1,2,…,m。集合A和</em>1,<em>2,…,</em>m所组成的系统称为<strong>代数系统</strong>，简称<strong>代数</strong></p>
<hr>
<p><strong>代数系统的基本运算规律</strong><br>1.结合律<br>2.交换律<br>3.消去律<br>4.幂等律<br>5.分配律<br>6.吸收律</p>
<hr>
<p><strong>代数系统的性质</strong><br><strong>幺元</strong>：单位元(英文常写作Identity Element，即IE)是集合里的一种特别的元，与该集合里的运算（可理解为实数里的*，但并不局限于）有关。当它和其他元素结合时，并不会改变那些元素。也叫幺元（么元）。若a<em>e=a，e称为右单位元；若e</em>a=a，e称为左单位元，若a<em>e=e</em>a=a，则e称为单位元。若该演算左右的元素能互换，左、右单位元相同，可称为双边单位元。<br><strong>零元</strong><br>设*是定义在集合A上的一个二元运算，如果有一个元素a1属于A，对于任意的元素x属于A，都有a1<em>x=a1，则称a为A中关于运算</em>的左零元；如果有一个元素a2属于A,a1不等于a2，对于任意的元素x属于A都有x<em>a2=a2，则称a2为A中关于运算</em>的右零元；如果A中的一个元素a，它既是左零元又是右零元，则称a为A中关于运算<em>的零元。<br><strong>逆元</strong><br>设S为一有二元运算 </em> 的集合。若e为(S,<em>)的单位元且a</em>b=e，则a称为b的左逆元素且b称为a的右逆元素。若一元素x同时是y的左逆元素和右逆元素时，x称为y的两面逆元素或简称为逆元素。S内的一有两面逆元素的元素被称为在S内为可逆的。</p>
<hr>
<p><strong>单射</strong>：设f是由集合A到集合B的映射，如果所有x,y∈A,且x≠y，都有f(x)≠f(y),则称f为由A到B的单射。</p>
<p><strong>同态</strong>：假设M，M′是两个乘集，也就是说M和M′是两个各具有一个封闭的具有结合律的运算<em>与</em>‘的代数系统。σ是M射到M′的映射，并且任意两个元的乘积的像是这两个元的像的乘积，即对于M中任意两个元a,b,满足<br>σ(a<em>b)=σ(a)</em>’σ(b)；<br>也就是说，当a→σ(a)，b→σ(b)时，a<em>b→σ(a)</em>’σ(b)，<br>那么这映射σ就叫做M到M′上的同态。<br>如果 σ 是单射， 则称为单同态；如果 σ 是满射，则称为满同态。如果σ是双射， 则称为同构。<br>如果M, M’都是群， 那么同态也叫做群同态。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九度OJ-1001]]></title>
      <url>/2017/10/23/%E4%B9%9D%E5%BA%A6OJ-1001/</url>
      <content type="html"><![CDATA[<p>-好久没有刷过OJ<br>-三次才AC<br><a id="more"></a></p>
<p>题目描述：<br>    This time, you are supposed to find A+B where A and B are two matrices, and then count the number of zero rows and columns.<br>输入：<br>    The input consists of several test cases, each starts with a pair of positive integers M and N (≤10) which are the number of rows and columns of the matrices, respectively. Then 2*M lines follow, each contains N integers in [-100, 100], separated by a space. The first M lines correspond to the elements of A and the second M lines to that of B.<br>    The input is terminated by a zero M and that case must NOT be processed.<br>输出：<br>    For each test case you should output in one line the total number of zero rows and columns of A+B.<br>样例输入：<br>2 2<br>1 1<br>1 1<br>-1 -1<br>10 9<br>2 3<br>1 2 3<br>4 5 6<br>-1 -2 -3<br>-4 -5 -6<br>0<br>样例输出：<br>1<br>5<br>来源：<br>2011年浙江大学计算机及软件工程研究生机试真题</p>
<hr>
<p>题目的意思大概是输入两个数作为数组的行数和列数，然后读入两个这样的数组，执行加法操作，算出元素均为0的行数列数的和。</p>
<hr>
<p><strong>AC代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> m,n; <span class="comment">//读入数组的行列数 </span></div><div class="line">	<span class="keyword">int</span> i,j;</div><div class="line">	<span class="keyword">int</span> count1,count2=<span class="number">0</span>; <span class="comment">//计数器 </span></div><div class="line">	</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&amp;&amp;m)&#123;</div><div class="line">		<span class="keyword">int</span> a[m][n];</div><div class="line">		<span class="keyword">int</span> b[m][n];</div><div class="line">		count2=<span class="number">0</span>; <span class="comment">//归零操作 </span></div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  <span class="comment">//读入第一个数组</span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</div><div class="line">				<span class="built_in">cin</span>&gt;&gt;a[i][j];</div><div class="line">				</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)  <span class="comment">//读入第二个数组 </span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; </div><div class="line">				<span class="built_in">cin</span>&gt;&gt;b[i][j];</div><div class="line">				a[i][j]+=b[i][j]; <span class="comment">//执行数组的加法</span></div><div class="line">			&#125; </div><div class="line">					</div><div class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)&#123;  <span class="comment">//算出有多少行是元素均为0的 </span></div><div class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)		</div><div class="line">				<span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</div><div class="line">					count1++;</div><div class="line">				<span class="keyword">if</span>(count1==n)</div><div class="line">					count2++;</div><div class="line">				count1=<span class="number">0</span>;  <span class="comment">//归零操作 </span></div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//算出有多少列是元素均为0的 </span></div><div class="line">			<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</div><div class="line">				<span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</div><div class="line">					count1++;</div><div class="line">				<span class="keyword">if</span>(count1==m)</div><div class="line">					count2++;</div><div class="line">				count1=<span class="number">0</span>; <span class="comment">//归零操作 </span></div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		<span class="built_in">cout</span>&lt;&lt;count2&lt;&lt;<span class="built_in">endl</span>;	</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;			 </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 九度OJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[证明技术]]></title>
      <url>/2017/10/23/%E8%AF%81%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>-基本证明技术<br>-典型证明技术</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">基本证明技术</font></strong><br>1.<strong>直接证明</strong><br>通过直接证明：若前提P为真，则结论Q也必然为真来证明蕴涵式P→Q成立，这样就证明了P真Q假的组合不可能存在，这种证明称为直接证明<br>2.<strong>间接证明</strong><br>因为蕴涵式P→Q等价于它的逆否命题¬Q→¬P，所以可以通过证明它的逆否命题¬Q→¬P为真来证明蕴涵式P→Q成立，这种类型的论证为间接证明</p>
<hr>
<p><strong><font size="5">典型证明技术</font></strong><br>1.<strong>空证明</strong><br>在蕴涵式P→Q中，当前件P为假时，无论其后件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明P为假，来证明P→Q，这称为空证明<br>2.<strong>平凡证明</strong><br>在蕴涵式P→Q中，当后件为真时，无论其前件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明Q为真，来证明P→Q，这称为平凡证明<br>3.<strong>归谬证明</strong><br>在蕴涵式P→Q中，当后件Q为假时，只有前件P也为假，蕴涵式P→Q才为真。因此，针对蕴涵式¬P→Q，假定可以找到矛盾式Q使得¬P→Q成立，即¬P为假，P为真。这种类型的论证称为归谬证明</p>
<hr>
<p><strong><font size="5">抽屉原理（鸽巢原理）</font></strong><br>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。 抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” </p>
<hr>
<p><strong><font size="5">数学归纳法</font></strong><br>最简单和常见的数学归纳法是证明当n等于任意一个自然数时某命题成立。证明分下面两步：<br>证明当n= 1时命题成立。<br>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谓词逻辑]]></title>
      <url>/2017/10/22/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-推理规则</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>个体词</strong>：在原子命题中，可以存在的客体（句子中的主语、宾语等）<br><strong>谓词</strong>：用以刻画客体性质或客体之间的关系的词<br><strong>个体常量</strong>：表示具体或特定的个体词<br><strong>个体变量</strong>：表示抽象或泛指的个体词<br><strong>个体域</strong>：个体词的取值范围<br><strong>全总个体域</strong>：宇宙间所有的个体域聚集在一起所构成的个体域<br><strong>存在量词</strong>：∃x（其中x称为作用变量）<br><strong>全称量词</strong>：∀x（其中x称为作用变量）<br><strong>辖域</strong>：一般将其量词加在其谓词之前，记为（∀x）F（x）， （∃x）F（x），此时，F（x）称为全称量词和存在量词的辖域<br><strong>约束出现</strong>：给定一个合适的公式G，若变元x出现在使用变元的量词的辖域之内，则称x的出现为约束出现，此时的变元x称为<strong>约束变元</strong><br><strong>自由出现</strong>：若x的出现不是约束出现，则为自由出现，此时的x称为<strong>自由变元</strong><br><strong>Skolem标准型</strong>：如果消去G中所有的存在量词和全称量词，所得到的公式称为Skolem标准型</p>
<hr>
<p><strong>谓词合式公式基本等价关系</strong><br>定义：如果公式G↔H是有效公式，则公式G，H称为<strong>等价</strong>的，记为G=H<br><strong>改名规则</strong>：<br>·（∃x）G（x）=（∃y）G（y）<br>·（∀x）G（x）=（∀y）G（y）<br><strong>量词转换律</strong><br>·¬（∃x）G（x）=（∀x）¬G（x）<br>·¬（∀x）G（x）=（∃x）¬G（x）<br><strong>量词辖域的扩张与收律</strong><br>·（∀x）G（x∨s）=（∀x）G（x）∨s<br>·（∀x）G（x∧s）=（∀x）G（x）∧s<br>·（∃x）G（x∨s）=（∃x）G（x）∨s<br>·（∃x）G（x∧s）=（∃x）G（x）∧s<br><strong>量词分配律</strong><br>·（∀x）（G（x）∧H（x））=（∀x）G（x）∧（∀x）H（x）<br>·（∃x）（G（x）∨H（x））=（∃x）G（x）∨（∃x）H（x）<br>·（∀x）G（x）∨（∀x）H（x）=（∀x）（∀y）（G（x）∨H（y））<br>·（∃x）G（x）∧（∃x）H（x）=（∃x）（∃y）（G（x）∨H（y））</p>
<hr>
<p><strong>推理规则</strong>：<br>1.<strong>US（全称特指规则）</strong>：（∀x）G（x）=&gt;G（y），其中y关于G（x）是自由的变元，不是约束的变元<br>2.<strong>ES（存在特指规则）</strong>：（∃x）G（x）=&gt;G（c），其中c为使G（c）为真的个体变量<br>3.<strong>UG（全程推广规则）</strong>：G（y）=&gt;（∀x）G（x），其中G（y）中无自由变元x<br>4.<strong>EG（存在推广原则）</strong>：G（c）=&gt;（∃x）G（x），其中c为特定个体变量</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-2]]></title>
      <url>/2017/10/19/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-2/</url>
      <content type="html"><![CDATA[<p>-主析取范式与主合取范式<br>-逻辑推理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>文字</strong>：命题变元或命题变元的否定<br><strong>析取式</strong>：有限个文字的析取称为析取式，也称子句<br><strong>合取式</strong>：有限个文字的合取称为合取式，也称短语<br><strong>互补对</strong>：P与¬P称为互补对<br><strong>析取范式</strong>：有限个短语的析取式为析取范式<br><strong>合取范式</strong>：有限个子句的合取式为合取范式<br><strong>极小项与极大项</strong>：在含有n个命题变元P1,P2,…,Pn的短语或子句中，若每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅出现一次，并且出现的次序与P1,P2,…,Pn一致，则称此短语或子句为关于P1,P2,…,Pn的一个极小项或极大项<br><strong>主析取范式</strong>：在给定的析取范式中，若每一个短语都是极小项，则称该范式为主析取范式<br><strong>主合取范式</strong>：在给定的合取范式中，若每一个子句都是极大项，则称该范式为主合取范式</p>
<hr>
<p>推理定律：<br>基于真值表技术，由如下关系：<br><strong>简化规则</strong>：<br>G∧H=&gt;G<br>G∧H=&gt;H<br><strong>添加规则</strong>：<br>G=&gt;G∨H<br>H=&gt;G∨H<br>¬G=&gt;G→H<br>H=&gt;H→G<br>G,H=&gt;G∧H<br><strong>选言三段论</strong>：<br>¬G,G→H=&gt;H<br>¬G,G⊕（异或）H=&gt;H<br><strong>肯定前件式</strong>：<br>G,G→H=&gt;H<br><strong>否定后件式</strong>：<br>¬H,G→H=&gt;¬G<br><strong>假言三段论</strong>:<br>G→H,H→I=&gt;G→I<br><strong>二难推论</strong>：<br>G∨H,G→I,H→I=&gt;I</p>
<hr>
<p><strong>规则P</strong>：前提引用规则。在推导的过程中，可随时引入前提集合中的任意一个前提<br><strong>规则T</strong>：逻辑结果引用规则。在推导的过程中，可随时引入公式S，该公式S是由其前的一个或多个公式推导出来的逻辑结果<br><strong>规则CP</strong>：附加前提规则。如果能从给定的前提的集合T与公式P推导出S，则能从此前提集合T推导出P→S</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-1]]></title>
      <url>/2017/10/18/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-基本等价关系</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>真值</strong>：命题可以取一个值，称为真值。真值只有“真”和“假”两种，分别用“1”(“T”)和“0”(“F”)表示。<br><strong>命题</strong>：具有确切真值的陈述句。</p>
<hr>
<p>一切没有判断内容的句子，都不能作为命题。</p>
<hr>
<p><strong>原子命题</strong>：不能再分解为更简单的命题。<br><strong>复合命题</strong>：可以分解为成简单的命题，与原子命题相对。<br><strong>联结词</strong>：否定联结词（非），合取联结词（并且），析取联结词（或），蕴涵联结词（推理），等价联结词。</p>
<hr>
<p>否定：真值结果取反<br>合取：P，Q同真才真，有假则假<br>析取：P，Q同假才假，有真则真<br>蕴涵：P真Q假时为假，否则为真<br>等价：PQ真值相同为真，否则为假</p>
<hr>
<p><strong>常值命题</strong>：真值不是“真”就是“假”，真值是确定的<br><strong>命题变量</strong>：没有具体的真值，与常值命题相对<br><strong>命题公式</strong>：其中的原子命题是命题变元，复合命题即为命题变元的”函数“，且该函数的真值仍为”真“或”假“<br><strong>解释</strong>：设P1,P2,…,Pn时出现在公式G中的所有命题变元，指定P1，P2，…，Pn一组真值，则这组真值称为G的一个解释<br><strong>真值表</strong>：由公式G在其所有可能的解释下所取的真值构成的表<br><strong>永真公式</strong>：在所有的解释下真值都为”真“<br><strong>永假公式（矛盾式）</strong>：在所有的解释下真值都为”假“<br><strong>可满足公式</strong>：非永假公式<br><strong>等价</strong>：设G,H是两个命题公式，P1，P2，…，Pn是出现在G，H中所有的命题变元，如果对于P1,P2，…，Pn的2的n次方个真值组合的每一个解释，G与H的真值结果都相同，则称G，H等价，记作<strong>G=H</strong></p>
<hr>
<p>命题公式的基本等价关系：<br>1.<strong>幂等律</strong>：<br>G∨G=G<br>G∧G=G<br>2.<strong>交换律</strong> ：<br>G∨H=H∨G<br>G∧H=H∧G<br>3.<strong>结合律</strong>：<br>G∨(H∨S)=(G∨H)∨S<br>G∧(H∧S)=(G∧H)∧S<br>4.<strong>同一律</strong>：<br>G∨0=G<br>G∧1=G<br>5.<strong>零律</strong>：<br>G∨1=1<br>G∧0=0<br>6.<strong>分配律</strong>：<br>G∨(H∧S)=(G∨H)∧(G∨S)<br>G∧(H∨S)=(G∧H)∨(G∧S)<br>7.<strong>吸收律</strong>：<br>G∨(G∧H)=G<br>G∧(G∨H)=G<br>8.<strong>矛盾律</strong>：<br>G∧¬G=0<br>9.<strong>排中律</strong>：<br>G∨¬G=1<br>10.<strong>双重否定律</strong>：<br>¬（¬G）=G<br>11.<strong>德摩根律</strong>：<br>¬(G∨H)=¬G∧¬H<br>¬(G∧H)=¬G∨¬H<br>12.<strong>蕴含式</strong>：<br>G→H=¬G∨H<br>13.<strong>假言易位</strong>：<br> G→H=¬H→¬G<br> 14.<strong>等价式</strong>：<br> G↔H=(G→H)∧(H→G)=(¬G∨H)∧(¬H∨G)<br> 15.<strong>等价否定等式</strong>：<br> G↔H=¬G↔¬H<br> 16.<strong>归谬论</strong>：</p>
<h2 id="G→H-∧-G→¬H-¬G"><a href="#G→H-∧-G→¬H-¬G" class="headerlink" title=" (G→H)∧(G→¬H)=¬G"></a> (G→H)∧(G→¬H)=¬G</h2><p> 更多查看我的blog:<a href="https://beatjerome.github.io" target="_blank" rel="external">https://beatjerome.github.io</a></p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-2]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-2/</url>
      <content type="html"><![CDATA[<p>-处理冲突的方法<br>-散列表查找及性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">处理冲突的方法<font></font></font></strong><br>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。<br>假设已经选定散列函数H(key)，下面用Hi表示发生冲突后第i次探测的散列地址。<br><strong><font size="4">一.开放定址法<font></font></font></strong><br>所谓开放定址法，指的是可存放新表项的空闲地址既指向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式<strong>Hi=（H（key）+di）%m</strong>，其中，i=1,2,…,k（k&lt;=m-1）；m表示散列表表长；di为增量序列。<br>当增量序列即di确定后，则对应的处理方法是确定的。通常有以下四种取法：<br><strong>1）线性探测法</strong><br>当di=1，2，…，m-1，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中的下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出下一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<br><strong>2）平方探测法</strong><br>当di=1²，-1²，2²，-2²，…，k²，-k²，其中k≤m/2，m必须是一个可以表示成4k+3的质数，又称二次探测法。<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一般单元。<br><strong>3）再散列法</strong><br>当di=Hash2（Key），又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H（Key）得到的地址发生冲突时，则利用第二个散列函数Hash2（Key）计算该关键字的地址增量。再散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置。<br><strong>4）伪随机序列法</strong><br>当di=伪随机数序列，称为伪随机序列法。</p>
<p><strong>注意：在开放地址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他<br>具有相同散列地址的元素的查找地址。所以，若想删除一个元素时，给它做一个删除标记，进<br>行逻辑删除。但这样做的副作用是：在执行多次删除后，表面看上去散列表是满的，实际上有<br>许多位置没有利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</strong></p>
<p><strong><font size="4">二.拉链法</font></strong><br>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表中的第i个单元中，因而查找，插入，删除操作主要在同义词链中进行。拉链法适合于经常进行插入删除操作的情况。</p>
<hr>
<p><strong><font size="6">散列表查找及性能分析</font></strong><br>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：<br><strong>初始化：Addr=Hash（key）；</strong><br>①检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败；若有记录，比较它与key值，若相等，返回查找成功标志，否则执行下一步。<br>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置wei此地址，转入步骤①</p>
<pre><code>散列表的查找效率取决与三个因素：散列函数，处理冲突的方法和装填因子
</code></pre><p><strong>装填因子</strong>：散列表的装填因子一般记为α，定义为一个表的装满程度，即<strong>α=表中记录数n/散列表长度m</strong><br>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观上看，α越大，装填程度越满，发生冲突的可能性就越大，反之发生冲突的可能性越小。</p>
<hr>
<p>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的发生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表的查找效率的度量。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-1]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-1/</url>
      <content type="html"><![CDATA[<p>-散列表的基本内容<br>-散列函数的构造方法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">散列表的基本概念<font></font></font></strong><br><strong>散列函数</strong><br>一个把查找表中关键字映射成该关键字对应的地址的函数，记为<strong>Hash(key)=Addr</strong>。（这里的地址可以是数组下标，索引，或内存地址等）<br>散列函数可能会把两个或者两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的办法。<br><strong><font size="5">散列表<font></font></font></strong><br><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。<br><strong>散列函数的构造方法</strong><br>在构造散列函数时，必须注意以下几点：<br>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。<br>2）散列函数计算出来的地址应该能等概率，均匀地分布在整个地址空间，从而减少冲突的发生。<br>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</p>
<hr>
<p><strong><font size="6">常用的散列函数<font></font></font></strong><br><strong>1.直接定址法</strong><br>    直接取关键字的某个线性函数值为散列地址，散列函数为<strong>H(key)=a*key+b</strong>。在这个函数式中，a和b是常数。这种方法计算最简单，并且不会产生冲突。它适合关键字的分布基本连续的情况，如果关键字分布不连续，空位较多，将造成存储空间的浪费。<br><strong>2.除留余数法</strong><br>    这是一种最简单，最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用下列公式把关键字转换成散列地址。散列函数为<strong>H(key)=key%p</strong>。<br>    除留余数法的关键在于选好p，使得每一个关键字在通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减小冲突的可能性。<br><strong>3.数字分析法</strong><br>    设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合。如果更换了关键字，就需要重新构造新的散列函数。<br><strong>4.平方取中法</strong><br>    顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。适合于关键字的每一位取值都不够均匀或均小于散列地址所需的位数的情况。<br><strong>5.折叠法</strong><br>    将关键字分割位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</p>
<hr>
<p>在不同的情况下，不同的散列函数会发挥出不同的性能，因此不能笼统地说哪种散列函数最好。实际选择中，采用何种散列函数的方法取决于关键字集合的情况，但目标是为了使散列产生冲突的可能性尽量地降低。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
