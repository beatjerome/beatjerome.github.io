<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Anyview数据结构-4]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-4/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-4<br><a id="more"></a></p>
<p>/<strong><strong>**</strong></strong><br>【题目】已知某哈希表的装载因子小于1，哈希函数H(key)<br>为关键字(标识符)的第一个字母在字母表中的序号，处理<br>冲突的方法为线性探测开放定址法。试编写一个按第一个<br>字母的顺序输出哈希表中所有关键字的算法。<br>哈希表的类型HashTable定义如下：</p>
<p>#define SUCCESS    1</p>
<p>#define UNSUCCESS  0</p>
<p>#define DUPLICATE -1<br>typedef char StrKeyType[4];<br>typedef struct {<br>   StrKeyType key; // 关键字项<br>   int    tag;     // 标记 0:空；1:有效; -1:已删除<br>   void  <em>any;     // 其他信息<br>} RcdType;<br>typedef struct {<br>  RcdType </em>rcd;    // 存储空间基址<br>  int      size;   // 哈希表容量<br>  int      count;  // 表中当前记录个数<br>} HashTable;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void PrintKeys(HashTable ht, void(*print)(StrKeyType))</div><div class="line">/* 依题意用print输出关键字 */</div><div class="line">&#123;</div><div class="line">    int n,i,size;</div><div class="line">    char c;</div><div class="line">    for(c=&apos;A&apos;;c&lt;=&apos;Z&apos;;c++)&#123;</div><div class="line">        for(i=0;i&lt;ht.size;i++)&#123;</div><div class="line">            if(ht.rcd[i].tag==-1) </div><div class="line">                continue;</div><div class="line">            if(ht.rcd[i].key[0]==c)</div><div class="line">                print(ht.rcd[i].key);</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设哈希表长为m，哈希函数为H(x)，用链地址法<br>处理冲突。试编写输入一组关键字并建造哈希表的算法。<br>哈希表的类型ChainHashTab定义如下：</p>
<p>#define NUM         7</p>
<p>#define NULLKEY    -1</p>
<p>#define SUCCESS     1</p>
<p>#define UNSUCCESS   0</p>
<p>#define DUPLICATE  -1<br>typedef char HKeyType;<br>typedef struct HNode {<br>   HKeyType  data;<br>   struct HNode<em>  next;<br>}</em>HLink;<br>typedef struct {<br>   HLink  <em>rcd;   // 指针存储基址，动态分配数组<br>   int    count;  // 当前表中含有的记录个数<br>   int    size;  // 哈希表的当前容量<br>}ChainHashTab;    // 链地址哈希表<br>int Hash(ChainHashTab H, HKeyType k) { // 哈希函数<br>  return k % H.size;<br>}<br>Status Collision(ChainHashTab H, HLink &amp;p) {<br>  // 求得下一个探查地址p<br>  if (p &amp;&amp; p-&gt;next) {<br>    p = p-&gt;next;<br>    return SUCCESS;<br>  } else return UNSUCCESS;<br>}<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">int BuildHashTab(ChainHashTab &amp;H, int n, HKeyType es[]) </div><div class="line">/* 直接调用下列函数                             */</div><div class="line">/* 哈希函数：                                   */</div><div class="line">/*    int Hash(ChainHashTab H, HKeyType k);     */</div><div class="line">/* 冲突处理函数：                               */</div><div class="line">/*    int Collision(ChainHashTab H, HLink &amp;p);  */</div><div class="line">&#123;</div><div class="line">    int i,k,j;</div><div class="line">    HLink p,q,p1;</div><div class="line">    H.rcd = (HLink*)malloc(7*sizeof(HLink));</div><div class="line">    H.size = 7;</div><div class="line">    H.count = 0;</div><div class="line">    for(i = 0;es[i] &gt;= &apos;A&apos;;i++)&#123;</div><div class="line">        p = (HNode*)malloc(sizeof(HNode));</div><div class="line">        p-&gt;next = NULL;</div><div class="line">        p-&gt;data = es[i];</div><div class="line">        k = Hash( H, p-&gt;data) ;</div><div class="line">        if(NULL !=H.rcd[k])&#123;  // 判断其中是否有相同的HKeyType</div><div class="line">            p1 =  H.rcd[k];</div><div class="line">            while(NULL != p1)&#123;  //用j作为标记，如果j = 0表示没有相同的，插入p</div><div class="line">                if(p1-&gt;data == p-&gt;data)</div><div class="line">                    j = 1;</div><div class="line">                p1 = p1-&gt;next;</div><div class="line">            &#125;</div><div class="line">            if(j == 0)&#123;</div><div class="line">                q =  H.rcd[k];</div><div class="line">                p-&gt;next = q;</div><div class="line">                H.rcd[k] = p;</div><div class="line">            &#125;</div><div class="line">           j = 0;</div><div class="line">        &#125;         </div><div class="line">        else   </div><div class="line">            H.rcd[k] = p; //为什么H.rcd[k]-&gt;next = p;不会报错</div><div class="line">    H.count++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> GDUT-Anyview </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-3]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-3<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试以顺序表L的L.rcd[L.length+1]作为监视哨，<br>改写教材3.2节中给出的升序直接插入排序算法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void InsertSort(RcdSqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i,j;</div><div class="line">   for(i=1;i&lt;L.length;i++)&#123;</div><div class="line">     if(L.rcd[i+1].key&lt;L.rcd[i].key)&#123;</div><div class="line">        L.rcd[0]=L.rcd[i+1];</div><div class="line">        j=i+1;</div><div class="line">        do&#123;</div><div class="line">           j--;</div><div class="line">           L.rcd[j+1] = L.rcd[j];</div><div class="line">        &#125;while(L.rcd[0].key&lt;L.rcd[j-1].key);</div><div class="line">        L.rcd[j] = L.rcd[0];</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如下所述，改写教材1.3.2节例1-10的冒泡排序算法：<br>将算法中用以起控制作用的布尔变量change改为一个整型<br>变量，指示每一趟排序中进行交换的最后一个记录的位置，<br>并以它作为下一趟起泡排序循环终止的控制值。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void BubbleSort(RcdSqList &amp;L)</div><div class="line">/* 元素比较和交换必须调用如下定义的比较函数和交换函数：*/</div><div class="line">/* Status LT(RedType a, RedType b);   比较：&quot;&lt;&quot;        */</div><div class="line">/* Status GT(RedType a, RedType b);   比较：&quot;&gt;&quot;        */</div><div class="line">/* void Swap(RedType &amp;a, RedType &amp;b); 交换             */</div><div class="line">&#123;</div><div class="line">   int i,change,j,k;                                                  </div><div class="line">   for(i=L.length,change = 0;i&gt;1;i--)&#123;</div><div class="line">       change = i;</div><div class="line">      for(j=1;j&lt;i;++j)&#123;</div><div class="line">         if(GT(L.rcd[j],L.rcd[j+1]))&#123;</div><div class="line">            Swap(L.rcd[j],L.rcd[j+1]);</div><div class="line">            k++;</div><div class="line">            change = j+1;</div><div class="line">         &#125;            </div><div class="line">      &#125;</div><div class="line">      while(L.rcd[change].key == L.rcd[change-1].key) //用while来跳过那些相同关键字</div><div class="line">             change=change - 1;</div><div class="line">      i=change;</div><div class="line">      if(k==0)    //当有一次比较没有交换时使i= 1结束操作</div><div class="line">         i=1;</div><div class="line">     k=0;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知记录序列L.rcd[1..L.length]中的关键<br>字各不相同，可按如下所述实现计数排序：另设数组<br>c[1..n]，对每个记录a[i]， 统计序列中关键字比它<br>小的记录个数存于c[i]，则c[i]=0的记录必为关键字<br>最小的记录，然后依c[i]值的大小对序列中记录进行<br>重新排列。试编写算法实现上述排序方法。<br>顺序表的类型RcdSqList定义如下：<br>typedef struct {<br>   KeyType key;<br>   …<br>} RcdType;<br>typedef struct {<br>   RcdType rcd[MAXSIZE+1]; // rcd[0]闲置<br>   int     length;<br>} RcdSqList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void CountSort(RcdSqList &amp;L)</div><div class="line">/* 采用顺序表存储结构，在函数内自行定义计数数组c */</div><div class="line">&#123;</div><div class="line">   int k=L.length ;</div><div class="line">   RcdSqList L1;</div><div class="line">   int c[27];</div><div class="line">   int i,j;</div><div class="line">   for(i=1;i&lt;=L.length ;i++)</div><div class="line">      for(j=1;j&lt;=L.length;j++)&#123;</div><div class="line">         if(L.rcd[i].key&lt;L.rcd[j].key)</div><div class="line">            c[i]++;</div><div class="line">      &#125;</div><div class="line">        </div><div class="line">    for(i=1;i&lt;=L.length;i++)</div><div class="line">         L1.rcd[c[i]+1].key=L.rcd[i].key;</div><div class="line">        </div><div class="line">    for(i=1;i&lt;=L.length;i++)       </div><div class="line">         L.rcd[L.length-i+1].key = L1.rcd[i].key;</div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> GDUT-Anyview </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-2]]></title>
      <url>/2017/10/27/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-2<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的判空操作<br>StackEmpty_Sq(SqStack S)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq(SqStack S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回TRUE；否则返回FALSE */</div><div class="line">&#123;</div><div class="line">    if(S.top==0)</div><div class="line">        return TRUE;</div><div class="line">    else</div><div class="line">        return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序栈的取栈顶元素操作<br>GetTop_Sq(SqStack S, ElemType &amp;e)。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem;  // 存储空间的基址<br>  int top;         // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;        // 当前分配的存储容量<br>  int increment;   // 扩容时，增加的存储容量<br>} SqStack;         // 顺序栈<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status GetTop_Sq(SqStack S, ElemType &amp;e) </div><div class="line">/* 取顺序栈S的栈顶元素到e，并返回OK； */ </div><div class="line">/* 若失败，则返回ERROR。              */</div><div class="line">&#123;</div><div class="line">     if(S.top==0)</div><div class="line">        return ERROR;</div><div class="line">     e=S.elem[--S.top];</div><div class="line">     return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>构建初始容量和扩容增量分别为size和inc的空顺序栈S。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Status InitStack_Sq2(SqStack2 &amp;S, int size, int inc)</div><div class="line">/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/ </div><div class="line">/* 若成功，则返回OK；否则返回ERROR。                 */</div><div class="line">&#123;</div><div class="line">    S.elem=(ElemType*)malloc(S.size*sizeof(ElemType));</div><div class="line">    if(S.elem==NULL)   //构建失败 </div><div class="line">        return ERROR;</div><div class="line">    if(size&lt;0||inc&lt;0)     //参数错误</div><div class="line">        return ERROR;</div><div class="line">    S.size=size;</div><div class="line">    S.increment=inc;</div><div class="line">    S.top=S.elem;</div><div class="line">    return OK;           </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的判空操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_Sq2(SqStack2 S)</div><div class="line">/* 对顺序栈S判空。                      */ </div><div class="line">/* 若S是空栈，则返回TRUE；否则返回FALSE */</div><div class="line">&#123;</div><div class="line">    if(S.top==S.elem)</div><div class="line">        return TRUE;</div><div class="line">    else</div><div class="line">        return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的入栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Status Push_Sq2(SqStack2 &amp;S, ElemType e)</div><div class="line">/* 若顺序栈S是满的，则扩容，若失败则返回ERROR。*/</div><div class="line">/* 将e压入S，返回OK。                          */</div><div class="line">&#123;</div><div class="line">    if(S.size==S.increment)  //顺序栈已满</div><div class="line">        S.elem=(ElemType*)realloc(S.elem,(S.size+S.increment)*sizeof(ElemType));</div><div class="line">    if(S.elem==NULL)    //顺序栈扩容失败</div><div class="line">        return ERROR;</div><div class="line">    *S.top++=e;</div><div class="line">    S.size=S.size+S.increment;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】若顺序栈的类型重新定义如下。试编写算法，<br>实现顺序栈的出栈操作。<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  ElemType </em>top;  // 栈顶元素的下一个位置<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack2;<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status Pop_Sq2(SqStack2 &amp;S, ElemType &amp;e) </div><div class="line">/* 若顺序栈S是空的，则返回ERROR；    */ </div><div class="line">/* 否则将S的栈顶元素出栈到e，返回OK。*/</div><div class="line">&#123;</div><div class="line">    if(S.top==S.elem)   //顺序栈为空  </div><div class="line">        return ERROR;</div><div class="line">    e=*(--S.top);</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，借助辅助栈，复制顺序栈S1得到S2。<br>顺序栈的类型定义为：<br>typedef struct {<br>  ElemType <em>elem; // 存储空间的基址<br>  int top;        // 栈顶元素的下一个位置，简称栈顶位标<br>  int size;       // 当前分配的存储容量<br>  int increment;  // 扩容时，增加的存储容量<br>} SqStack;        // 顺序栈<br>可调用顺序栈接口中下列函数：<br>Status InitStack_Sq(SqStack &amp;S, int size, int inc); // 初始化顺序栈S<br>Status DestroyStack_Sq(SqStack &amp;S); // 销毁顺序栈S<br>Status StackEmpty_Sq(SqStack S);    // 栈S判空，若空则返回TRUE，否则FALSE<br>Status Push_Sq(SqStack &amp;S, ElemType e); // 将元素e压入栈S<br>Status Pop_Sq(SqStack &amp;S, ElemType &amp;e); // 栈S的栈顶元素出栈到e<br><strong><strong>**</strong></strong></em>/<br><strong>解题思路</strong>：栈是先进后出的，因此借用S3，需要用来两次倒序，第一次倒序插入S3，再将S3倒序插入S2，即所有元素正序，即完成复制顺序栈操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Status CopyStack_Sq(SqStack S1, SqStack &amp;S2) </div><div class="line">/* 借助辅助栈，复制顺序栈S1得到S2。    */ </div><div class="line">/* 若复制成功，则返回TRUE；否则FALSE。 */</div><div class="line">&#123;</div><div class="line">     SqStack S3;</div><div class="line">     int e;</div><div class="line">     InitStack_Sq(S2,S1.size,S1.increment);</div><div class="line">     InitStack_Sq(S3,S1.size,S1.increment);</div><div class="line">     while(StackEmpty_Sq(S1)!=TRUE)&#123; //先将S1元素倒序插入S3</div><div class="line">       Pop_Sq(S1,e);</div><div class="line">       Push_Sq(S3,e);</div><div class="line">       &#125;</div><div class="line">     if(S3.elem==NULL)    //S1倒序插入S3失败</div><div class="line">        return ERROR;</div><div class="line">     while(StackEmpty_Sq(S3)!=TRUE)&#123; //再将S3元素倒序插入S2</div><div class="line">       Pop_Sq(S3,e);</div><div class="line">       Push_Sq(S2,e);</div><div class="line">       &#125;</div><div class="line">     if(S2.elem==NULL)   //S3倒序插入S2失败</div><div class="line">        return FALSE;</div><div class="line">     return OK;       </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，求循环队列的长度。<br>循环队列的类型定义为：<br>typedef struct {<br>  ElemType <em>base;  // 存储空间的基址<br>  int front;       // 队头位标<br>  int rear;        // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;     // 最大长度<br>} SqQueue;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int QueueLength_Sq(SqQueue Q)</div><div class="line">/* 返回队列Q中元素个数，即队列的长度。 */ </div><div class="line">&#123;</div><div class="line">   return (Q.rear-Q.front+Q.maxSize)%Q.maxSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】如果希望循环队列中的元素都能得到利用，<br>则可设置一个标志域tag，并以tag值为0或1来区分尾<br>指针和头指针值相同时的队列状态是”空”还是”满”。<br>试编写与此结构相应的入队列和出队列的算法。<br>本题的循环队列CTagQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int tag;<br>  int front;<br>  int rear;<br>} CTagQueue;<br><strong><strong>**</strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CTagQueue &amp;Q,ElemType x)</div><div class="line">/* 将元素x加入队列Q，并返回OK；*/</div><div class="line">/* 若失败，则返回ERROR。       */</div><div class="line">&#123;</div><div class="line">   if(Q.tag==1&amp;&amp;Q.front==Q.rear)</div><div class="line">        return ERROR;</div><div class="line">   Q.elem[Q.rear]=x;</div><div class="line">   Q.rear=(Q.rear+1)%MAXQSIZE;</div><div class="line">   if(Q.front==Q.rear)</div><div class="line">   Q.tag=1;</div><div class="line">   return OK ;</div><div class="line">&#125; </div><div class="line"></div><div class="line">Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)</div><div class="line">/* 将队列Q的队头元素退队到x，并返回OK；*/</div><div class="line">/* 若失败，则返回ERROR。               */</div><div class="line">&#123; </div><div class="line">     if(Q.tag==0&amp;&amp;Q.front==Q.rear)</div><div class="line">       return ERROR;</div><div class="line">      x=Q.elem[Q.front];</div><div class="line">      Q.front=(Q.front+1)%MAXQSIZE;</div><div class="line">      if(Q.front==Q.rear)</div><div class="line">         Q.tag=0;</div><div class="line">      return OK; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】假设将循环队列定义为：以域变量rear<br>和length分别指示循环队列中队尾元素的位置和内<br>含元素的个数。试给出此循环队列的队满条件，并<br>写出相应的入队列和出队列的算法（在出队列的算<br>法中要返回队头元素）。<br>本题的循环队列CLenQueue的类型定义如下：<br>typedef struct {<br>  ElemType elem[MAXQSIZE];<br>  int length;<br>  int rear;<br>} CLenQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status EnCQueue(CLenQueue &amp;Q, ElemType x)</div><div class="line">  /* 将元素x加入队列Q，并返回OK；*/</div><div class="line">  /* 若失败，则返回ERROR。       */</div><div class="line">&#123;</div><div class="line">    if(Q.length==MAXQSIZE)  //队列满</div><div class="line">      return ERROR;</div><div class="line">    Q.elem[Q.rear]=x;</div><div class="line">    Q.rear=(Q.rear+1)%MAXQSIZE; </div><div class="line">    Q.length++;</div><div class="line">    return TRUE;</div><div class="line">&#125;</div><div class="line">Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x)</div><div class="line">  /* 将队列Q的队头元素退队到x，并返回OK；*/</div><div class="line">  /* 若失败，则返回ERROR。               */</div><div class="line">&#123;</div><div class="line">    if(Q.length==0)     //队列空</div><div class="line">        return ERROR;   </div><div class="line">    int front;         </div><div class="line">    front=MAXQSIZE-Q.length+Q.rear;</div><div class="line">    x=Q.elem[front%MAXQSIZE];</div><div class="line">    front=(front+1)%MAXQSIZE;</div><div class="line">    Q.length--;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶斐波那契序列的定义为:<br>    f0=0,  f1=0,  …,  fk-2=0,  fk-1=1;<br>    fn=fn-1+fn-2+…+fn-k,  n=k,k+1,…<br>试利用循环队列编写求k阶斐波那契序列中第<br>n+1项fn的算法。</p>
<p>本题的循环队列的类型定义如下：<br>typedef struct {<br>  ElemType <em>base; // 存储空间的基址<br>  int front;      // 队头位标<br>  int rear;       // 队尾位标，指示队尾元素的下一位置<br>  int maxSize;    // 最大长度<br>} SqQueue;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">long Fib(int k, int n)</div><div class="line">/* 求k阶斐波那契序列的第n+1项fn */</div><div class="line">&#123;</div><div class="line">    int i,j ;</div><div class="line">   if(1 &gt;=k|| 0 &gt; n) return ERROR;</div><div class="line">   SqQueue fib;</div><div class="line">   fib.base = (ElemType*)malloc(30*sizeof(ElemType));</div><div class="line">   fib.maxSize = 30;</div><div class="line">   fib.front = fib.rear = 0;</div><div class="line">   for(;fib.rear &lt; k;fib.rear++)</div><div class="line">   &#123;</div><div class="line">        if(fib.rear&lt;k-1) </div><div class="line">            fib.base[fib.rear] = 0;</div><div class="line">        else</div><div class="line">            fib.base[fib.rear] = 1;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   while(fib.rear &lt;= n)</div><div class="line">   &#123;</div><div class="line">        j = 1;</div><div class="line">        while(j &lt;= k)</div><div class="line">        &#123;</div><div class="line">             fib.base[fib.rear] +=fib.base[fib.rear-j];</div><div class="line">             j++;</div><div class="line">         &#125;</div><div class="line">        fib.rear++;</div><div class="line">  &#125;</div><div class="line">    return fib.base[n];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】设A=(a1,…,am)和B=(b1,…,bn)均为有序顺序表，<br>A’和B’分别为A和B中除去最大共同前缀后的子表（例如，<br>A=(x,y,y,z,x,z)，B=(x,y,y,z,y,x,x,z)，则两者中最大<br>的共同前缀为(x,y,y,z)， 在两表中除去最大共同前缀后<br>的子表分别为A’=(x,z)和B’=(y,x,x,z)）。若A’=B’=空表，<br>则A=B；若A’=空表，而B’≠ 空表，或者两者均不为空表，<br>且A’的首元小于B’的首元，则A<b；否则a>B。试写一个比<br>较A和B大小的算法。（注意：在算法中，不要破坏原表A<br>和B，也不一定先求得A’和B’才进行比较）。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</b；否则a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">char Compare(SqList A, SqList B)</div><div class="line">/* 比较顺序表A和B,      */</div><div class="line">/*   返回&apos;&lt;&apos;, 若A&lt;B;    */</div><div class="line">/*       &apos;=&apos;, 若A=B;    */</div><div class="line">/*       &apos;&gt;&apos;, 若A&gt;B     */</div><div class="line">&#123;     </div><div class="line">    int i=0;  //计数器    </div><div class="line">    while(A.elem[i]==B.elem[i]&amp;&amp;i&lt;A.length&amp;&amp;i&lt;B.length)         </div><div class="line">        i++;      </div><div class="line">    if(A.length==B.length)</div><div class="line">        return &apos;=&apos;;      </div><div class="line">    else if(A.elem[i]&lt;B.elem[i]||i==A.length)         </div><div class="line">        return &apos;&lt;&apos;;      </div><div class="line">    else if(A.elem[i]&gt;B.elem[i]||i==B.length) </div><div class="line">        return &apos;&gt;&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现顺序表的就地逆置，<br>即利用原表的存储空间将线性表(a1,a2,…,an)<br>逆置为(an,an-1,…,a1)。<br>顺序表类型定义如下：<br>typedef struct {<br>  ElemType <em>elem;<br>  int       length;<br>  int       size;<br>  int       increment;<br>} SqList;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void Inverse(SqList &amp;L)</div><div class="line">&#123;</div><div class="line">   int i;</div><div class="line">   int temp;</div><div class="line">   for(i=0;i&lt;L.length/2;i++) &#123;</div><div class="line">       temp=L.elem[i];</div><div class="line">       L.elem[i]=L.elem[L.length-i-1];</div><div class="line">       L.elem[L.length-i-1]=temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试对一元稀疏多项式Pn(x)采用存储量同多项式<br>项数m成正比的顺序存储结构，编写求Pn(x0)的算法（x0<br>为给定值）。<br>一元稀疏多项式的顺序存储结构:<br>typedef struct {<br>  int  coef;  // 系数<br>  int   exp;  // 指数<br>} Term;<br>typedef struct {<br>  Term  <em>elem;   // 存储空间基址<br>  int    length; // 长度（项数）<br>} Poly;<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">float Evaluate(Poly P, float x)</div><div class="line">/* P.elem[i].coef 存放ai，                        */</div><div class="line">/* P.elem[i].exp存放ei (i=1,2,...,m)              */</div><div class="line">/* 本算法计算并返回多项式的值。不判别溢出。       */</div><div class="line">/* 入口时要求0≤e1&lt;e2&lt;...&lt;em，算法内不对此再作验证 */</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    float sum=0,sum1;</div><div class="line">    for(i=0;i&lt;P.length;i++)</div><div class="line">    &#123;</div><div class="line">        sum1=P.elem[i].coef ;</div><div class="line">        for(j=0;j&lt;P.elem[i].exp;j++)</div><div class="line">          sum1=sum1*x;</div><div class="line">        sum+=sum1;</div><div class="line">    &#125;</div><div class="line">    return sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有两个集合A和B分别用两个线性表LA和LB<br>表示(即：线性表中的数据元素即为集合中的成员），<br>试写一算法，求并集A＝A∪B。<br>顺序表类型定义如下<br>typedef struct {<br>  ElemType <em>elem;     // 存储空间的基址<br>  int length;    // 当前长度<br>  int size;      // 存储容量<br>  int increment; // 空间不够增加空间大小<br>} SqList;  // 顺序表<br>可调用顺序表的以下接口函数：<br>Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表L<br>int ListLength_Sq(SqList L);  // 返回顺序表L中元素个数<br>Status GetElem_Sq(SqList L, int i, ElemType &amp;e);<br>// 用e返回顺序表L中第i个元素的值<br>int Search_Sq(SqList L, ElemType e);<br>// 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1<br>Status Append_Sq(SqList &amp;L, ElemType e);  // 在顺序表L表尾添加元素e<br><strong><strong>*</strong></strong></em>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void Union(SqList &amp;La, SqList Lb)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    ElemType e;</div><div class="line">    for(i=0;i&lt;Lb.length;i++)&#123;     </div><div class="line">         GetElem_Sq(Lb,i+1,e);</div><div class="line">         if(-1==Search_Sq(La,e))</div><div class="line">            Append_Sq(La,e);</div><div class="line">    &#125;</div><div class="line">    La.length = ListLength_Sq(La);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的判空操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status StackEmpty_L(LStack S)</div><div class="line">/* 对链栈S判空。若S是空栈，则返回TRUE；否则返回FALSE */</div><div class="line">&#123;</div><div class="line">   if(S==NULL)</div><div class="line">        return TRUE;</div><div class="line">   else</div><div class="line">        return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链栈的取栈顶元素操作。<br>链栈的类型定义为：<br>typedef struct LSNode {<br>  ElemType data;       // 数据域<br>  struct LSNode <em>next; // 指针域<br>} LSNode, </em>LStack;    // 结点和链栈类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status GetTop_L(LStack S, ElemType &amp;e) </div><div class="line">/* 取链栈S的栈顶元素到e，并返回OK; */</div><div class="line">/* 若S是空栈，则失败，返回ERROR。  */</div><div class="line">&#123;</div><div class="line">    LSNode *p;</div><div class="line">    if(S==NULL)</div><div class="line">        return ERROR;</div><div class="line">    else</div><div class="line">        e=S-&gt;data;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的判空操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status QueueEmpty_LQ(LQueue Q)</div><div class="line">/* 判定链队列Q是否为空队列。           */</div><div class="line">/* 若Q是空队列，则返回TRUE，否则FALSE。*/</div><div class="line">&#123;</div><div class="line">    if(Q.rear==NULL)</div><div class="line">        return TRUE;</div><div class="line">    else</div><div class="line">        return FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现链队列的求队列长度操作。<br>链队列的类型定义为：<br>typedef struct LQNode {<br>  ElemType  data;<br>  struct LQNode  <em>next;<br>} LQNode, </em>QueuePtr; // 结点和结点指针类型<br>typedef struct {<br>  QueuePtr  front;  // 队头指针<br>  QueuePtr  rear;   // 队尾指针<br>} LQueue;  // 链队列类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int QueueLength_LQ(LQueue Q)</div><div class="line">/* 求链队列Q的长度并返回其值 */</div><div class="line">&#123;</div><div class="line">   LQNode *p=Q.front;</div><div class="line">   int i=1;</div><div class="line">   if(Q.rear==NULL)</div><div class="line">        return ERROR;</div><div class="line">   while(p!=Q.rear)&#123;</div><div class="line">       p = p-&gt;next;</div><div class="line">       i++;</div><div class="line">   &#125;</div><div class="line">   return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设以带头结点的循环链表表示队列，并且<br>只设一个指针指向队尾元素结点(注意不设头指针)，<br>试编写相应的队列初始化、入队列和出队列的算法。<br>带头结点循环链队列CLQueue的类型定义为：<br>typedef struct LQNode {<br>  ElemType data;<br>  struct LQNode <em>next;<br>} LQNode, </em>CLQueue;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">Status InitCLQueue(CLQueue &amp;rear) // 初始化空队列</div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    if(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    p-&gt;next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status EnCLQueue(CLQueue &amp;rear, ElemType x) // 入队</div><div class="line">&#123; </div><div class="line">    LQNode *p;</div><div class="line">    p=(LQNode*)malloc(sizeof(LQNode));</div><div class="line">    if(p==NULL)</div><div class="line">        return ERROR;</div><div class="line">    p-&gt;data=x;</div><div class="line">    p-&gt;next=rear-&gt;next;</div><div class="line">    rear-&gt;next=p;</div><div class="line">    rear=p;</div><div class="line">    return OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeCLQueue(CLQueue &amp;rear, ElemType &amp;x) // 出队</div><div class="line">&#123; </div><div class="line">   if(rear==rear-&gt;next)</div><div class="line">       return ERROR;</div><div class="line">   else&#123;</div><div class="line">       x=rear-&gt;next-&gt;next-&gt;data;</div><div class="line">       rear-&gt;next-&gt;next=rear-&gt;next-&gt;next-&gt;next;</div><div class="line">    &#125;    </div><div class="line">  return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的判空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Status ListEmpty_L(LinkList L)</div><div class="line">/* 判定带头结点单链表L是否为空链表。   */</div><div class="line">/* 若L是空链表，则返回TRUE，否则FALSE。*/</div><div class="line">&#123;</div><div class="line">   if(NULL == L-&gt;next) </div><div class="line">        return TRUE;</div><div class="line">    return  FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的销毁操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Status DestroyList_L(LinkList &amp;L)</div><div class="line">/* 销毁带头结点单链表L，并返回OK。*/</div><div class="line">&#123;</div><div class="line">    free(L);</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的清空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Status ClearList_L(LinkList &amp;L)</div><div class="line">/* 将带头结点单链表L置为空表，并返回OK。*/</div><div class="line">/* 若L不是带头结点单链表，则返回ERROR。 */</div><div class="line">&#123;</div><div class="line">   if(L==NULL) </div><div class="line">      return ERROR;</div><div class="line">   if(L-&gt;next==NULL) </div><div class="line">      return OK;</div><div class="line">   L-&gt;next=NULL;</div><div class="line">   return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的求表长度操作。<br>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int ListLength_L(LinkList L)</div><div class="line">/* 求带头结点单链表L的长度，并返回长度值。*/</div><div class="line">/* 若L不是带头结点单链表，则返回-1。      */</div><div class="line">&#123;  </div><div class="line">   LNode *p;</div><div class="line">   int i=0;</div><div class="line">   if(NULL==L)</div><div class="line">      return -1;</div><div class="line">   p = L-&gt;next;</div><div class="line">   while(p != NULL)&#123;</div><div class="line">      p = p-&gt;next;</div><div class="line">      i++;</div><div class="line">   &#125;</div><div class="line">   return i;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表L插入第i元素e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Status Insert_L(LinkList L, int i, ElemType e)</div><div class="line">/* 在带头结点单链表L插入第i元素e，并返回OK。*/</div><div class="line">/* 若参数不合理，则返回ERROR。              */ </div><div class="line">&#123;</div><div class="line">    if(i==0)</div><div class="line">        return ERROR;</div><div class="line">    LinkList p,q,p1,b;</div><div class="line">    int j=0,k=0;</div><div class="line">    q=(LNode*)malloc(sizeof(LNode));</div><div class="line">    q-&gt;data=e;</div><div class="line">    q-&gt;next=NULL;</div><div class="line">    p1=L;</div><div class="line">    b=L;</div><div class="line">    while(b!=NULL)&#123;        </div><div class="line">        b=b-&gt;next;</div><div class="line">        k++;</div><div class="line">    &#125;</div><div class="line">    if(k&lt;i)</div><div class="line">        return ERROR;</div><div class="line">    while(j&lt;i)&#123;</div><div class="line">        p=p1;</div><div class="line">        p1=p-&gt;next;</div><div class="line">        j++;    </div><div class="line">    &#125;</div><div class="line">    q-&gt;next=p-&gt;next;</div><div class="line">    p-&gt;next=q;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表的第i元素起的<br>所有元素从链表移除，并构成一个带头结点的新链表。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Status Split_L(LinkList L, LinkList &amp;Li, int i)</div><div class="line">/* 在带头结点单链表L的第i元素起的所有元素 */</div><div class="line">/* 移除，并构成带头结点链表Li，返回OK。   */</div><div class="line">/* 若参数不合理，则Li为NULL，返回ERROR。  */</div><div class="line">&#123;</div><div class="line">   if(i&lt;=0||L==null) &#123;</div><div class="line">     Li==null;</div><div class="line">     return ERROR;</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">   LinkList a,b,c;</div><div class="line">   int j=0,k=0;</div><div class="line">   Li=(LNode*)malloc(sizeof(LNode));</div><div class="line">   Li-&gt;next=null;</div><div class="line">   a=L;</div><div class="line">   b=L;</div><div class="line">   while(a-&gt;next!=null)&#123;</div><div class="line">     j++;</div><div class="line">     a=a-&gt;next;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   if(j&lt;i) &#123;</div><div class="line">   Li=null;</div><div class="line">   return ERROR;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   while(k&lt;i-1)&#123;</div><div class="line">   b=b-&gt;next;</div><div class="line">   k++;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   c=b-&gt;next;</div><div class="line">   Li-&gt;next=c;</div><div class="line">   b-&gt;next=null;</div><div class="line">   return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素<br>起的所有元素。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">Status Cut_L(LinkList L, int i)</div><div class="line">/* 在带头结点单链表L删除第i元素起的所有元素，并返回OK。*/</div><div class="line">/* 若参数不合理，则返回ERROR。                         */</div><div class="line">&#123;</div><div class="line">    LinkList p1,p2,p3;</div><div class="line">    int j=0,k=0;</div><div class="line">    p2=L;</div><div class="line">    p1=L;</div><div class="line">    p3=L;</div><div class="line"></div><div class="line">    if(NULL==L||L-&gt;next==NULL)</div><div class="line">        return ERROR;</div><div class="line">        </div><div class="line">    while(p1-&gt;next!=null)&#123;</div><div class="line">       p1=p1-&gt;next;</div><div class="line">       j++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    if(j&lt;i||i==0)</div><div class="line">        return ERROR;</div><div class="line"> </div><div class="line">    while(k&lt;i)&#123;</div><div class="line">       p2=p3;</div><div class="line">       p3=p2-&gt;next;</div><div class="line">       k++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    p2-&gt;next=null;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>为x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status DeleteX_L(LinkList L, ElemType x)</div><div class="line">/* 删除带头结点单链表L中所有值为x的元素，      */</div><div class="line">/* 并释放被删结点空间，返回实际删除的元素个数。*/</div><div class="line">&#123;</div><div class="line">    LinkList p1,p2,p3;</div><div class="line">    int j=0;</div><div class="line">    if(NULL==L) </div><div class="line">        return ERROR;</div><div class="line">    p1=p2=L;</div><div class="line">    while(p2!=NULL)&#123;</div><div class="line">      p2=p1-&gt;next;</div><div class="line">      if(p2-&gt;data==x)&#123;</div><div class="line">        p3=p2;</div><div class="line">        p2=p3-&gt;next;</div><div class="line">        p1-&gt;next=p2;</div><div class="line">        free(p3);</div><div class="line">        j++;</div><div class="line">      &#125;</div><div class="line">      else if(p2-&gt;data!=x)&#123;</div><div class="line">          p1=p2;</div><div class="line">          p2=p1-&gt;next;</div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，删除带头结点单链表中所有值<br>小于x的元素，并释放被删结点空间。<br>单链表类型定义如下：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status DeleteSome_L(LinkList L, ElemType x)</div><div class="line">/* 删除带头结点单链表L中所有值小于x的元素，    */</div><div class="line">/* 并释放被删结点空间，返回实际删除的元素个数。*/</div><div class="line">&#123;</div><div class="line">    LinkList p1,p2,p3;</div><div class="line">    int j=0;</div><div class="line">    if(NULL==L) </div><div class="line">        return ERROR;</div><div class="line">    p1=p2=L;</div><div class="line">    while(p2!=NULL)&#123;</div><div class="line">      p2=p1-&gt;next;</div><div class="line">      if(p2-&gt;data&lt;x&amp;&amp;p2!=null)&#123;</div><div class="line">        p3=p2;</div><div class="line">        p2=p3-&gt;next;</div><div class="line">        p1-&gt;next=p2;</div><div class="line">        free(p3);</div><div class="line">        j++;</div><div class="line">      &#125;</div><div class="line">      else if(p2-&gt;data&gt;=x)&#123;</div><div class="line">          p1=p2;</div><div class="line">          p2=p1-&gt;next;</div><div class="line">       &#125;            </div><div class="line">    &#125;    </div><div class="line">    return j;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> GDUT-Anyview </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Anyview数据结构-1]]></title>
      <url>/2017/10/24/AnyView%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/</url>
      <content type="html"><![CDATA[<p>-广工Anyview题解<br>-数据结构部分-1<br><a id="more"></a><br>/<strong><strong>**</strong></strong><br>【题目】试写一算法，如果三个整数a，b和c的值<br>不是依次非递增的，则通过交换，令其为非递增。<br><strong><strong><em>*</em></strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void Descend(int &amp;a, int &amp;b, int &amp;c)</div><div class="line">/* 通过交换，令 a &gt;= b &gt;= c */</div><div class="line">&#123;</div><div class="line">    int temp;</div><div class="line">    if(c&gt;=b)</div><div class="line">    &#123;</div><div class="line">        temp=b;</div><div class="line">        b=c;</div><div class="line">        c=temp;</div><div class="line">    &#125;</div><div class="line">    if(b&gt;=a)</div><div class="line">    &#123;</div><div class="line">        temp=a;</div><div class="line">        a=b;</div><div class="line">        b=temp;</div><div class="line">    &#125;</div><div class="line">    if(c&gt;=b)&#123;</div><div class="line">        temp=b;</div><div class="line">        b=c;</div><div class="line">        c=temp;</div><div class="line">    &#125;            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法求一元多项式<br>    P(x) = a0 + a1x + a2x^2 + … + anx^n<br>的值P(x0)，并确定算法中每一语句的执行次数和整个算法<br>的时间复杂度。<br><strong><strong>**</strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">float Polynomial(int n, int a[], float x)</div><div class="line">/* 求一元多项式的值P(x)。                  */</div><div class="line">/* 数组a的元素a[i]为i次项的系数，i=0,...,n */</div><div class="line">&#123;</div><div class="line">    double px;</div><div class="line">    int i;</div><div class="line">    for(i=0;i&lt;=n;i++)</div><div class="line">        px+=a[i]*pow(x,i);</div><div class="line">    return px;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】已知k阶裴波那契序列的定义为<br>    f(0)=0, f(1)=0, …, f(k-2)=0, f(k-1)=1;<br>    f(n)=f(n-1)+f(n-2)+…+f(n-k), n=k,k+1,…<br>试编写求k阶裴波那契序列的第m项值的函数算法，<br>k和m均以值调用的形式在函数参数表中出现。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Status Fibonacci(int k, int m, int &amp;f) </div><div class="line">/* 求k阶斐波那契序列的第m项的值f */</div><div class="line">&#123;    </div><div class="line">    int t[60],sum,i,j;</div><div class="line">    if(k&lt;2||m&lt;0) </div><div class="line">        return ERROR;</div><div class="line">    if(m&lt;k-1) </div><div class="line">        f=0;</div><div class="line">    else if(m==k-1) </div><div class="line">        f=1;</div><div class="line">    else&#123;</div><div class="line">      for(i=0;i&lt;=k-2;i++)&#123;</div><div class="line">        t[i]=0;</div><div class="line">        t[k-1]=1;</div><div class="line">        for(i=k;i&lt;=m;i++)&#123;</div><div class="line">            sum=0;</div><div class="line">            for(j=i-k;j&lt;i;j++)</div><div class="line">                sum+=t[j];</div><div class="line">            t[i]=sum;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    f=t[m];</div><div class="line">    &#125;                                                                                </div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试编写算法，计算i!×2^i的值并存入数组<br>a[0..n-1]的第i-1个分量中 (i=1,2,…,n)。假设计<br>算机中允许的整数最大值为MAXINT，则当对某个k<br>(1≤k≤n)使k!×2^k&gt;MAXINT时，应按出错处理。注意<br>选择你认为较好的出错处理方法。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Status Series(int a[], int n) </div><div class="line">/* 求i!*2^i序列的值并依次存入长度为n的数组a；     */</div><div class="line">/* 若所有值均不超过MAXINT，则返回OK，否则OVERFLOW */</div><div class="line">&#123;</div><div class="line">   int i=0,sum=0;</div><div class="line">   int sum1=1,sum2=1;</div><div class="line">   int j;</div><div class="line">   for(i=1;i&lt;=n;i++)&#123;</div><div class="line">        for(j=i;j&gt;0;j--)</div><div class="line">            sum1=sum1*j;</div><div class="line">        for(j=i;j&gt;0;j--)</div><div class="line">            sum2=sum2*2;    </div><div class="line">    sum=sum1*sum2;</div><div class="line">        </div><div class="line">    if(sum1&gt;MAXINT||sum2&gt;MAXINT||sum&gt;MAXINT)</div><div class="line">        return OVERFLOW;             </div><div class="line">        </div><div class="line">    a[i-1]=sum;</div><div class="line">    </div><div class="line">    sum1=1;//归位</div><div class="line">    sum2=1;//归位</div><div class="line">    &#125;</div><div class="line">   return  OK;            </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】假设有A、B、C、D、E五个高等院校进行田径对抗赛，<br>各院校的单项成绩均以存入计算机并构成一张表，表中每一行<br>的形式为：<br>        项目名称   性别   校名   成绩   得分<br>编写算法，处理上述表格，以统计各院校的男、女总分和团体<br>总分，并输出。<br><strong><strong>**</strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">void Scores(ResultType *result, ScoreType *score)</div><div class="line">/* 求各校的男、女总分和团体总分, 并依次存入数组score */</div><div class="line">/* 假设比赛结果已经储存在result[ ]数组中,            */</div><div class="line">/* 并以特殊记录 &#123;&quot;&quot;, male, &apos; &apos;, &quot;&quot;, 0 &#125;（域scorce=0）*/</div><div class="line">/* 表示结束                                          */</div><div class="line">&#123;</div><div class="line">typedef enum &#123;female,male&#125; Sex;</div><div class="line">typedef struct&#123;</div><div class="line">  char *sport;     // 项目名称</div><div class="line">  Sex  gender;     // 性别（女：female；男：male）</div><div class="line">  char schoolname; // 校名为&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;或&apos;E&apos;</div><div class="line">  char *result;    // 成绩</div><div class="line">  int score;       // 得分（7,5,4,3,2或1）</div><div class="line">&#125; ResultType; </div><div class="line">typedef struct&#123;</div><div class="line">  int malescore;   // 男子总分</div><div class="line">  int femalescore; // 女子总分</div><div class="line">  int totalscore;  // 男女团体总分</div><div class="line">&#125; ScoreType;</div><div class="line"></div><div class="line">int i=0;</div><div class="line"> while(result[i].sport!=NULL)  </div><div class="line"> &#123;  </div><div class="line"> switch(result[i].schoolname)     /*使用switch语句记录各院校的成绩*/</div><div class="line"> &#123;  </div><div class="line"></div><div class="line"> case &apos;A&apos;:  </div><div class="line"> score[0].totalscore+=result[i].score;</div><div class="line"></div><div class="line"> if(result[i].gender==male)  </div><div class="line"></div><div class="line">    score[0].malescore+=result[i].score;  </div><div class="line"></div><div class="line"> else  </div><div class="line"></div><div class="line">    score[0].femalescore+=result[i].score;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> case &apos;B&apos;:  </div><div class="line"> score[1].totalscore+=result[i].score;</div><div class="line"></div><div class="line"> if(result[i].gender==male)  </div><div class="line"></div><div class="line">    score[1].malescore+=result[i].score;  </div><div class="line"></div><div class="line"> else  </div><div class="line"></div><div class="line">    score[1].femalescore+=result[i].score;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> case &apos;C&apos;:  </div><div class="line"></div><div class="line"> score[2].totalscore+=result[i].score;  </div><div class="line"></div><div class="line"> if(result[i].gender==male)  </div><div class="line"></div><div class="line">    score[2].malescore+=result[i].score;  </div><div class="line"></div><div class="line"> else  </div><div class="line"></div><div class="line">    score[2].femalescore+=result[i].score;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> case &apos;D&apos;:  </div><div class="line"> </div><div class="line"></div><div class="line"> score[3].totalscore+=result[i].score;  </div><div class="line"> </div><div class="line"></div><div class="line"> if(result[i].gender==male)  </div><div class="line"></div><div class="line">    score[3].malescore+=result[i].score;  </div><div class="line"></div><div class="line"> else  </div><div class="line"></div><div class="line">    score[3].femalescore+=result[i].score;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"> </div><div class="line"></div><div class="line"> case &apos;E&apos;: </div><div class="line">  </div><div class="line"></div><div class="line"> score[4].totalscore+=result[i].score;  </div><div class="line"></div><div class="line"> if(result[i].gender==male)  </div><div class="line"></div><div class="line">    score[4].malescore+=result[i].score;  </div><div class="line"></div><div class="line"> else  </div><div class="line"></div><div class="line">    score[4].femalescore+=result[i].score;  </div><div class="line"></div><div class="line"> break;  </div><div class="line"></div><div class="line"> &#125;</div><div class="line"></div><div class="line"> i++;  </div><div class="line"></div><div class="line"> &#125;  </div><div class="line"></div><div class="line">    int j;  </div><div class="line"></div><div class="line">    for( j=0;j&lt;5;j++)  &#123;</div><div class="line"></div><div class="line">        printf(&quot;the school %s: &quot;, result[i].schoolname) ;   /*输出各院校的男女总分和团体总分*/</div><div class="line"></div><div class="line">        printf(&quot;total: %f&quot;,&amp;score[i].totalscore);  </div><div class="line"></div><div class="line">        printf(&quot;male: %f&quot;,&amp;score[i].malescore);  </div><div class="line"></div><div class="line">        printf(&quot;female: %f&quot;,&amp;score[i].femalescore);  </div><div class="line"></div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，对序列S的第i个元素赋以值e。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Status Assign(Sequence &amp;S, int i, ElemType e) </div><div class="line">/* 对序列S的第i个元素赋以值e，并返回OK。 */</div><div class="line">/* 若S或i不合法，则赋值失败，返回ERROR   */</div><div class="line">&#123;    </div><div class="line">    if(i&lt;1||i&gt;=S.length||S.elem==NULL)</div><div class="line">        return ERROR;</div><div class="line">    S.elem[i]=e;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，由长度为n的一维数组a构建一个序列S。<br>序列的类型定义为：<br>typedef struct {<br>  ElemType  <em>elem;<br>  int  length;<br>} Sequence;<br><strong><strong>**</strong></strong></em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Status CreateSequence(Sequence &amp;S, int n, ElemType *a) </div><div class="line">/* 由长度为n的一维数组a构建一个序列S，并返回OK。 */</div><div class="line">/* 若构建失败，则返回ERROR                       */</div><div class="line">&#123;</div><div class="line">   int i;</div><div class="line">   if(n&lt;1)</div><div class="line">        return ERROR;</div><div class="line">   S.elem=(ElemType*)malloc(n*sizeof(ElemType));</div><div class="line">   for(i=0;i&lt;n;i++)</div><div class="line">        S.elem[i]=a[i];</div><div class="line">   S.length=n;     </div><div class="line">   return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建一个值为x的结点。<br><strong><strong><em>*</em></strong></strong>/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LinkList MakeNode(ElemType x)</div><div class="line">/* 构建一个值为x的结点，并返回其指针。*/</div><div class="line">/* 若构建失败，则返回NULL。           */</div><div class="line">&#123;</div><div class="line">     LNode *p;</div><div class="line">     p=(LNode*)malloc(sizeof(LNode));</div><div class="line">     if(p==NULL) //构建失败</div><div class="line">        return NULL;</div><div class="line">     p-&gt;next=NULL;</div><div class="line">     p-&gt;data=x;</div><div class="line">     return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2且两个结点的值依次为x和y的链表。<br><strong><strong>**</strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">LinkList CreateLinkList(ElemType x, ElemType y) </div><div class="line">/* 构建其两个结点的值依次为x和y的链表。*/</div><div class="line">/* 若构建失败，则返回NULL。            */</div><div class="line">&#123;</div><div class="line">      LNode *p;</div><div class="line">      LNode *q;</div><div class="line">      p=(LNode*)malloc(sizeof(LNode));</div><div class="line">      if(p==NULL)  //构建失败</div><div class="line">        return NULL;        </div><div class="line">      q=(LNode*)malloc(sizeof(LNode));</div><div class="line">      if(q==NULL)  //构建失败</div><div class="line">        return NULL;</div><div class="line">      p-&gt;next=q;</div><div class="line">      q-&gt;next=NULL;</div><div class="line">      p-&gt;data=x;</div><div class="line">      q-&gt;data=y;</div><div class="line">      return p;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>/<strong><strong>**</strong></strong><br>【题目】链表的结点和指针类型定义如下<br>    typedef struct LNode {<br>       ElemType  data;<br>       struct LNode <em>next;<br>    } LNode, </em>LinkList;<br>试写一函数，构建长度为2的升序链表，两个结点的值<br>分别为x和y，但应小的在前，大的在后。<br><strong><strong>**</strong></strong>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">LinkList CreateOrdLList(ElemType x, ElemType y)</div><div class="line">/* 构建长度为2的升序链表。  */</div><div class="line">/* 若构建失败，则返回NULL。 */</div><div class="line">&#123;</div><div class="line">    LNode *p;</div><div class="line">    LNode *q;</div><div class="line">    </div><div class="line">    p=(LNode*)malloc(sizeof(LNode));</div><div class="line">    if(p==NULL)</div><div class="line">        return NULL;</div><div class="line">        </div><div class="line">    q=(LNode*)malloc(sizeof(LNode));</div><div class="line">    if(q==NULL)</div><div class="line">        return NULL;</div><div class="line">                </div><div class="line">    p-&gt;next=q;</div><div class="line">    q-&gt;next=NULL;</div><div class="line">    if(x&lt;y)&#123;</div><div class="line">        p-&gt;data=x;</div><div class="line">        q-&gt;data=y;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        p-&gt;data=y;</div><div class="line">        q-&gt;data=x;</div><div class="line">    &#125;</div><div class="line">    return p;                            </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
]]></content>
      
        <categories>
            
            <category> GDUT-Anyview </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AnyView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[代数系统]]></title>
      <url>/2017/10/24/%E4%BB%A3%E6%95%B0%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p>-代数系统概念与性质</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>如果“*”是AXA到A的二元运算，则称运算“*”对集合A是<strong>封闭</strong>的，或者称“*”是A上的二元运算</p>
<hr>
<p>设A是非空集合,<em>1,</em>2,…,<em>m分别是定义在A上的k1,k2,…,km元封闭运算，ki是正整数，i=1,2,…,m。集合A和</em>1,<em>2,…,</em>m所组成的系统称为<strong>代数系统</strong>，简称<strong>代数</strong></p>
<hr>
<p><strong>代数系统的基本运算规律</strong><br>1.结合律<br>2.交换律<br>3.消去律<br>4.幂等律<br>5.分配律<br>6.吸收律</p>
<hr>
<p><strong>代数系统的性质</strong><br><strong>幺元</strong>：单位元(英文常写作Identity Element，即IE)是集合里的一种特别的元，与该集合里的运算（可理解为实数里的*，但并不局限于）有关。当它和其他元素结合时，并不会改变那些元素。也叫幺元（么元）。若a<em>e=a，e称为右单位元；若e</em>a=a，e称为左单位元，若a<em>e=e</em>a=a，则e称为单位元。若该演算左右的元素能互换，左、右单位元相同，可称为双边单位元。<br><strong>零元</strong><br>设*是定义在集合A上的一个二元运算，如果有一个元素a1属于A，对于任意的元素x属于A，都有a1<em>x=a1，则称a为A中关于运算</em>的左零元；如果有一个元素a2属于A,a1不等于a2，对于任意的元素x属于A都有x<em>a2=a2，则称a2为A中关于运算</em>的右零元；如果A中的一个元素a，它既是左零元又是右零元，则称a为A中关于运算<em>的零元。<br><strong>逆元</strong><br>设S为一有二元运算 </em> 的集合。若e为(S,<em>)的单位元且a</em>b=e，则a称为b的左逆元素且b称为a的右逆元素。若一元素x同时是y的左逆元素和右逆元素时，x称为y的两面逆元素或简称为逆元素。S内的一有两面逆元素的元素被称为在S内为可逆的。</p>
<hr>
<p><strong>单射</strong>：设f是由集合A到集合B的映射，如果所有x,y∈A,且x≠y，都有f(x)≠f(y),则称f为由A到B的单射。</p>
<p><strong>同态</strong>：假设M，M′是两个乘集，也就是说M和M′是两个各具有一个封闭的具有结合律的运算<em>与</em>‘的代数系统。σ是M射到M′的映射，并且任意两个元的乘积的像是这两个元的像的乘积，即对于M中任意两个元a,b,满足<br>σ(a<em>b)=σ(a)</em>’σ(b)；<br>也就是说，当a→σ(a)，b→σ(b)时，a<em>b→σ(a)</em>’σ(b)，<br>那么这映射σ就叫做M到M′上的同态。<br>如果 σ 是单射， 则称为单同态；如果 σ 是满射，则称为满同态。如果σ是双射， 则称为同构。<br>如果M, M’都是群， 那么同态也叫做群同态。</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[九度OJ-1001]]></title>
      <url>/2017/10/23/%E4%B9%9D%E5%BA%A6OJ-1001/</url>
      <content type="html"><![CDATA[<p>-好久没有刷过OJ<br>-三次才AC<br><a id="more"></a></p>
<p>题目描述：<br>    This time, you are supposed to find A+B where A and B are two matrices, and then count the number of zero rows and columns.<br>输入：<br>    The input consists of several test cases, each starts with a pair of positive integers M and N (≤10) which are the number of rows and columns of the matrices, respectively. Then 2*M lines follow, each contains N integers in [-100, 100], separated by a space. The first M lines correspond to the elements of A and the second M lines to that of B.<br>    The input is terminated by a zero M and that case must NOT be processed.<br>输出：<br>    For each test case you should output in one line the total number of zero rows and columns of A+B.<br>样例输入：<br>2 2<br>1 1<br>1 1<br>-1 -1<br>10 9<br>2 3<br>1 2 3<br>4 5 6<br>-1 -2 -3<br>-4 -5 -6<br>0<br>样例输出：<br>1<br>5<br>来源：<br>2011年浙江大学计算机及软件工程研究生机试真题</p>
<hr>
<p>题目的意思大概是输入两个数作为数组的行数和列数，然后读入两个这样的数组，执行加法操作，算出元素均为0的行数列数的和。</p>
<hr>
<p><strong>AC代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#include&lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()&#123;</div><div class="line">	int m,n; //读入数组的行列数 </div><div class="line">	int i,j;</div><div class="line">	int count1,count2=0; //计数器 </div><div class="line">	</div><div class="line">	while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)&#123;</div><div class="line">		int a[m][n];</div><div class="line">		int b[m][n];</div><div class="line">		count2=0; //归零操作 </div><div class="line">		</div><div class="line">		for(i=0;i&lt;m;i++)  //读入第一个数组</div><div class="line">			for(j=0;j&lt;n;j++)</div><div class="line">				cin&gt;&gt;a[i][j];</div><div class="line">				</div><div class="line"></div><div class="line">		for(i=0;i&lt;m;i++)  //读入第二个数组 </div><div class="line">			for(j=0;j&lt;n;j++)&#123; </div><div class="line">				cin&gt;&gt;b[i][j];</div><div class="line">				a[i][j]+=b[i][j]; //执行数组的加法</div><div class="line">			&#125; </div><div class="line">					</div><div class="line">		for(i=0;i&lt;m;i++)&#123;  //算出有多少行是元素均为0的 </div><div class="line">			for(j=0;j&lt;n;j++)		</div><div class="line">				if(a[i][j]==0)</div><div class="line">					count1++;</div><div class="line">				if(count1==n)</div><div class="line">					count2++;</div><div class="line">				count1=0;  //归零操作 </div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		for(j=0;j&lt;n;j++)&#123; //算出有多少列是元素均为0的 </div><div class="line">			for(i=0;i&lt;m;i++)</div><div class="line">				if(a[i][j]==0)</div><div class="line">					count1++;</div><div class="line">				if(count1==m)</div><div class="line">					count2++;</div><div class="line">				count1=0; //归零操作 </div><div class="line">			&#125;</div><div class="line">		</div><div class="line">		cout&lt;&lt;count2&lt;&lt;endl;	</div><div class="line">	&#125;</div><div class="line">	return 0;			 </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 九度OJ题解目录 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Online judge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[证明技术]]></title>
      <url>/2017/10/23/%E8%AF%81%E6%98%8E%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<p>-基本证明技术<br>-典型证明技术</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="5">基本证明技术</font></strong><br>1.<strong>直接证明</strong><br>通过直接证明：若前提P为真，则结论Q也必然为真来证明蕴涵式P→Q成立，这样就证明了P真Q假的组合不可能存在，这种证明称为直接证明<br>2.<strong>间接证明</strong><br>因为蕴涵式P→Q等价于它的逆否命题¬Q→¬P，所以可以通过证明它的逆否命题¬Q→¬P为真来证明蕴涵式P→Q成立，这种类型的论证为间接证明</p>
<hr>
<p><strong><font size="5">典型证明技术</font></strong><br>1.<strong>空证明</strong><br>在蕴涵式P→Q中，当前件P为假时，无论其后件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明P为假，来证明P→Q，这称为空证明<br>2.<strong>平凡证明</strong><br>在蕴涵式P→Q中，当后件为真时，无论其前件Q为真与否，蕴涵式P→Q都为真。<br>因此，可通过证明Q为真，来证明P→Q，这称为平凡证明<br>3.<strong>归谬证明</strong><br>在蕴涵式P→Q中，当后件Q为假时，只有前件P也为假，蕴涵式P→Q才为真。因此，针对蕴涵式¬P→Q，假定可以找到矛盾式Q使得¬P→Q成立，即¬P为假，P为真。这种类型的论证称为归谬证明</p>
<hr>
<p><strong><font size="5">抽屉原理（鸽巢原理）</font></strong><br>桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。 抽屉原理的一般含义为：“如果每个抽屉代表一个集合，每一个苹果就可以代表一个元素，假如有n+1个元素放到n个集合中去，其中必定有一个集合里至少有两个元素。” </p>
<hr>
<p><strong><font size="5">数学归纳法</font></strong><br>最简单和常见的数学归纳法是证明当n等于任意一个自然数时某命题成立。证明分下面两步：<br>证明当n= 1时命题成立。<br>假设n=m时命题成立，那么可以推导出在n=m+1时命题也成立。（m代表任意自然数）</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谓词逻辑]]></title>
      <url>/2017/10/22/%E8%B0%93%E8%AF%8D%E9%80%BB%E8%BE%91/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-推理规则</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>个体词</strong>：在原子命题中，可以存在的客体（句子中的主语、宾语等）<br><strong>谓词</strong>：用以刻画客体性质或客体之间的关系的词<br><strong>个体常量</strong>：表示具体或特定的个体词<br><strong>个体变量</strong>：表示抽象或泛指的个体词<br><strong>个体域</strong>：个体词的取值范围<br><strong>全总个体域</strong>：宇宙间所有的个体域聚集在一起所构成的个体域<br><strong>存在量词</strong>：∃x（其中x称为作用变量）<br><strong>全称量词</strong>：∀x（其中x称为作用变量）<br><strong>辖域</strong>：一般将其量词加在其谓词之前，记为（∀x）F（x）， （∃x）F（x），此时，F（x）称为全称量词和存在量词的辖域<br><strong>约束出现</strong>：给定一个合适的公式G，若变元x出现在使用变元的量词的辖域之内，则称x的出现为约束出现，此时的变元x称为<strong>约束变元</strong><br><strong>自由出现</strong>：若x的出现不是约束出现，则为自由出现，此时的x称为<strong>自由变元</strong><br><strong>Skolem标准型</strong>：如果消去G中所有的存在量词和全称量词，所得到的公式称为Skolem标准型</p>
<hr>
<p><strong>谓词合式公式基本等价关系</strong><br>定义：如果公式G↔H是有效公式，则公式G，H称为<strong>等价</strong>的，记为G=H<br><strong>改名规则</strong>：<br>·（∃x）G（x）=（∃y）G（y）<br>·（∀x）G（x）=（∀y）G（y）<br><strong>量词转换律</strong><br>·¬（∃x）G（x）=（∀x）¬G（x）<br>·¬（∀x）G（x）=（∃x）¬G（x）<br><strong>量词辖域的扩张与收律</strong><br>·（∀x）G（x∨s）=（∀x）G（x）∨s<br>·（∀x）G（x∧s）=（∀x）G（x）∧s<br>·（∃x）G（x∨s）=（∃x）G（x）∨s<br>·（∃x）G（x∧s）=（∃x）G（x）∧s<br><strong>量词分配律</strong><br>·（∀x）（G（x）∧H（x））=（∀x）G（x）∧（∀x）H（x）<br>·（∃x）（G（x）∨H（x））=（∃x）G（x）∨（∃x）H（x）<br>·（∀x）G（x）∨（∀x）H（x）=（∀x）（∀y）（G（x）∨H（y））<br>·（∃x）G（x）∧（∃x）H（x）=（∃x）（∃y）（G（x）∨H（y））</p>
<hr>
<p><strong>推理规则</strong>：<br>1.<strong>US（全称特指规则）</strong>：（∀x）G（x）=&gt;G（y），其中y关于G（x）是自由的变元，不是约束的变元<br>2.<strong>ES（存在特指规则）</strong>：（∃x）G（x）=&gt;G（c），其中c为使G（c）为真的个体变量<br>3.<strong>UG（全程推广规则）</strong>：G（y）=&gt;（∀x）G（x），其中G（y）中无自由变元x<br>4.<strong>EG（存在推广原则）</strong>：G（c）=&gt;（∃x）G（x），其中c为特定个体变量</p>
<hr>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-2]]></title>
      <url>/2017/10/19/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-2/</url>
      <content type="html"><![CDATA[<p>-主析取范式与主合取范式<br>-逻辑推理</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>文字</strong>：命题变元或命题变元的否定<br><strong>析取式</strong>：有限个文字的析取称为析取式，也称子句<br><strong>合取式</strong>：有限个文字的合取称为合取式，也称短语<br><strong>互补对</strong>：P与¬P称为互补对<br><strong>析取范式</strong>：有限个短语的析取式为析取范式<br><strong>合取范式</strong>：有限个子句的合取式为合取范式<br><strong>极小项与极大项</strong>：在含有n个命题变元P1,P2,…,Pn的短语或子句中，若每个命题变元与其否定不同时存在，但二者之一恰好出现一次且仅出现一次，并且出现的次序与P1,P2,…,Pn一致，则称此短语或子句为关于P1,P2,…,Pn的一个极小项或极大项<br><strong>主析取范式</strong>：在给定的析取范式中，若每一个短语都是极小项，则称该范式为主析取范式<br><strong>主合取范式</strong>：在给定的合取范式中，若每一个子句都是极大项，则称该范式为主合取范式</p>
<hr>
<p>推理定律：<br>基于真值表技术，由如下关系：<br><strong>简化规则</strong>：<br>G∧H=&gt;G<br>G∧H=&gt;H<br><strong>添加规则</strong>：<br>G=&gt;G∨H<br>H=&gt;G∨H<br>¬G=&gt;G→H<br>H=&gt;H→G<br>G,H=&gt;G∧H<br><strong>选言三段论</strong>：<br>¬G,G→H=&gt;H<br>¬G,G⊕（异或）H=&gt;H<br><strong>肯定前件式</strong>：<br>G,G→H=&gt;H<br><strong>否定后件式</strong>：<br>¬H,G→H=&gt;¬G<br><strong>假言三段论</strong>:<br>G→H,H→I=&gt;G→I<br><strong>二难推论</strong>：<br>G∨H,G→I,H→I=&gt;I</p>
<hr>
<p><strong>规则P</strong>：前提引用规则。在推导的过程中，可随时引入前提集合中的任意一个前提<br><strong>规则T</strong>：逻辑结果引用规则。在推导的过程中，可随时引入公式S，该公式S是由其前的一个或多个公式推导出来的逻辑结果<br><strong>规则CP</strong>：附加前提规则。如果能从给定的前提的集合T与公式P推导出S，则能从此前提集合T推导出P→S</p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[命题逻辑-1]]></title>
      <url>/2017/10/18/%E5%91%BD%E9%A2%98%E9%80%BB%E8%BE%91-1/</url>
      <content type="html"><![CDATA[<p>-基本概念<br>-基本等价关系</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong>真值</strong>：命题可以取一个值，称为真值。真值只有“真”和“假”两种，分别用“1”(“T”)和“0”(“F”)表示。<br><strong>命题</strong>：具有确切真值的陈述句。</p>
<hr>
<p>一切没有判断内容的句子，都不能作为命题。</p>
<hr>
<p><strong>原子命题</strong>：不能再分解为更简单的命题。<br><strong>复合命题</strong>：可以分解为成简单的命题，与原子命题相对。<br><strong>联结词</strong>：否定联结词（非），合取联结词（并且），析取联结词（或），蕴涵联结词（推理），等价联结词。</p>
<hr>
<p>否定：真值结果取反<br>合取：P，Q同真才真，有假则假<br>析取：P，Q同假才假，有真则真<br>蕴涵：P真Q假时为假，否则为真<br>等价：PQ真值相同为真，否则为假</p>
<hr>
<p><strong>常值命题</strong>：真值不是“真”就是“假”，真值是确定的<br><strong>命题变量</strong>：没有具体的真值，与常值命题相对<br><strong>命题公式</strong>：其中的原子命题是命题变元，复合命题即为命题变元的”函数“，且该函数的真值仍为”真“或”假“<br><strong>解释</strong>：设P1,P2,…,Pn时出现在公式G中的所有命题变元，指定P1，P2，…，Pn一组真值，则这组真值称为G的一个解释<br><strong>真值表</strong>：由公式G在其所有可能的解释下所取的真值构成的表<br><strong>永真公式</strong>：在所有的解释下真值都为”真“<br><strong>永假公式（矛盾式）</strong>：在所有的解释下真值都为”假“<br><strong>可满足公式</strong>：非永假公式<br><strong>等价</strong>：设G,H是两个命题公式，P1，P2，…，Pn是出现在G，H中所有的命题变元，如果对于P1,P2，…，Pn的2的n次方个真值组合的每一个解释，G与H的真值结果都相同，则称G，H等价，记作<strong>G=H</strong></p>
<hr>
<p>命题公式的基本等价关系：<br>1.<strong>幂等律</strong>：<br>G∨G=G<br>G∧G=G<br>2.<strong>交换律</strong> ：<br>G∨H=H∨G<br>G∧H=H∧G<br>3.<strong>结合律</strong>：<br>G∨(H∨S)=(G∨H)∨S<br>G∧(H∧S)=(G∧H)∧S<br>4.<strong>同一律</strong>：<br>G∨0=G<br>G∧1=G<br>5.<strong>零律</strong>：<br>G∨1=1<br>G∧0=0<br>6.<strong>分配律</strong>：<br>G∨(H∧S)=(G∨H)∧(G∨S)<br>G∧(H∨S)=(G∧H)∨(G∧S)<br>7.<strong>吸收律</strong>：<br>G∨(G∧H)=G<br>G∧(G∨H)=G<br>8.<strong>矛盾律</strong>：<br>G∧¬G=0<br>9.<strong>排中律</strong>：<br>G∨¬G=1<br>10.<strong>双重否定律</strong>：<br>¬（¬G）=G<br>11.<strong>德摩根律</strong>：<br>¬(G∨H)=¬G∧¬H<br>¬(G∧H)=¬G∨¬H<br>12.<strong>蕴含式</strong>：<br>G→H=¬G∨H<br>13.<strong>假言易位</strong>：<br> G→H=¬H→¬G<br> 14.<strong>等价式</strong>：<br> G↔H=(G→H)∧(H→G)=(¬G∨H)∧(¬H∨G)<br> 15.<strong>等价否定等式</strong>：<br> G↔H=¬G↔¬H<br> 16.<strong>归谬论</strong>：</p>
<h2 id="G→H-∧-G→¬H-¬G"><a href="#G→H-∧-G→¬H-¬G" class="headerlink" title=" (G→H)∧(G→¬H)=¬G"></a> (G→H)∧(G→¬H)=¬G</h2><p> 更多查看我的blog:<a href="https://beatjerome.github.io" target="_blank" rel="external">https://beatjerome.github.io</a></p>
]]></content>
      
        <categories>
            
            <category> Discrete mathematics </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Computer Basics </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-2]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-2/</url>
      <content type="html"><![CDATA[<p>-处理冲突的方法<br>-散列表查找及性能分析</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">处理冲突的方法<font></font></font></strong><br>任何设计出来的散列函数都不可能绝对地避免冲突，为此，必须考虑在发生冲突时应该如何进行处理，即为产生冲突的关键字寻找下一个“空”的Hash地址。<br>假设已经选定散列函数H(key)，下面用Hi表示发生冲突后第i次探测的散列地址。<br><strong><font size="4">一.开放定址法<font></font></font></strong><br>所谓开放定址法，指的是可存放新表项的空闲地址既指向它的同义词表项开放，又向它的非同义词表项开放。其数学递推公式<strong>Hi=（H（key）+di）%m</strong>，其中，i=1,2,…,k（k&lt;=m-1）；m表示散列表表长；di为增量序列。<br>当增量序列即di确定后，则对应的处理方法是确定的。通常有以下四种取法：<br><strong>1）线性探测法</strong><br>当di=1，2，…，m-1，称为线性探测法。这种方法的特点是：冲突发生时，顺序查看表中的下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出下一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。<br><strong>2）平方探测法</strong><br>当di=1²，-1²，2²，-2²，…，k²，-k²，其中k≤m/2，m必须是一个可以表示成4k+3的质数，又称二次探测法。<br>平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一般单元。<br><strong>3）再散列法</strong><br>当di=Hash2（Key），又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H（Key）得到的地址发生冲突时，则利用第二个散列函数Hash2（Key）计算该关键字的地址增量。再散列法中，最多经过m-1次探测会遍历表中所有位置，回到H0位置。<br><strong>4）伪随机序列法</strong><br>当di=伪随机数序列，称为伪随机序列法。</p>
<p><strong>注意：在开放地址的情形下，不能随便物理删除表中已有元素，因为若删除元素将会截断其他<br>具有相同散列地址的元素的查找地址。所以，若想删除一个元素时，给它做一个删除标记，进<br>行逻辑删除。但这样做的副作用是：在执行多次删除后，表面看上去散列表是满的，实际上有<br>许多位置没有利用，因此需要定期维护散列表，要把删除标记的元素物理删除。</strong></p>
<p><strong><font size="4">二.拉链法</font></strong><br>对于不同的关键字可能会通过散列函数映射到同一地址，为了避免同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。假设散列地址为i的同义词链表的头指针存放在散列表中的第i个单元中，因而查找，插入，删除操作主要在同义词链中进行。拉链法适合于经常进行插入删除操作的情况。</p>
<hr>
<p><strong><font size="6">散列表查找及性能分析</font></strong><br>散列表的查找过程与构造散列表的过程基本一致。对于一个给定的关键字key，根据散列函数可以计算出其散列地址，执行步骤如下：<br><strong>初始化：Addr=Hash（key）；</strong><br>①检测查找表中地址为Addr的位置上是否有记录，若没有记录，返回查找失败；若有记录，比较它与key值，若相等，返回查找成功标志，否则执行下一步。<br>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置wei此地址，转入步骤①</p>
<pre><code>散列表的查找效率取决与三个因素：散列函数，处理冲突的方法和装填因子
</code></pre><p><strong>装填因子</strong>：散列表的装填因子一般记为α，定义为一个表的装满程度，即<strong>α=表中记录数n/散列表长度m</strong><br>散列表的平均查找长度依赖于散列表的装填因子α，而不直接依赖于n或m。直观上看，α越大，装填程度越满，发生冲突的可能性就越大，反之发生冲突的可能性越小。</p>
<hr>
<p>虽然散列表在关键字与记录的存储位置之间建立了直接映像，但由于冲突的发生，使得散列表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量散列表的查找效率的度量。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[散列表-1]]></title>
      <url>/2017/10/16/%E6%95%A3%E5%88%97%E8%A1%A8-1/</url>
      <content type="html"><![CDATA[<p>-散列表的基本内容<br>-散列函数的构造方法</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p><strong><font size="6">散列表的基本概念<font></font></font></strong><br><strong>散列函数</strong><br>一个把查找表中关键字映射成该关键字对应的地址的函数，记为<strong>Hash(key)=Addr</strong>。（这里的地址可以是数组下标，索引，或内存地址等）<br>散列函数可能会把两个或者两个以上的不同关键字映射到同一地址，称这种情况为<strong>冲突</strong>，这些发生碰撞的不同关键字称为<strong>同义词</strong>。一方面，设计好的散列函数应尽量减少这样的冲突；另一方面，由于这样的冲突总是不可避免的，所以还要设计好处理冲突的办法。<br><strong><font size="5">散列表<font></font></font></strong><br><strong>散列表</strong>是根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。<br><strong>散列函数的构造方法</strong><br>在构造散列函数时，必须注意以下几点：<br>1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。<br>2）散列函数计算出来的地址应该能等概率，均匀地分布在整个地址空间，从而减少冲突的发生。<br>3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。</p>
<hr>
<p><strong><font size="6">常用的散列函数<font></font></font></strong><br><strong>1.直接定址法</strong><br>    直接取关键字的某个线性函数值为散列地址，散列函数为<strong>H(key)=a*key+b</strong>。在这个函数式中，a和b是常数。这种方法计算最简单，并且不会产生冲突。它适合关键字的分布基本连续的情况，如果关键字分布不连续，空位较多，将造成存储空间的浪费。<br><strong>2.除留余数法</strong><br>    这是一种最简单，最常用的方法，假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用下列公式把关键字转换成散列地址。散列函数为<strong>H(key)=key%p</strong>。<br>    除留余数法的关键在于选好p，使得每一个关键字在通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减小冲突的可能性。<br><strong>3.数字分析法</strong><br>    设关键字是r进制数(如十进制数)，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合。如果更换了关键字，就需要重新构造新的散列函数。<br><strong>4.平方取中法</strong><br>    顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。适合于关键字的每一位取值都不够均匀或均小于散列地址所需的位数的情况。<br><strong>5.折叠法</strong><br>    将关键字分割位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。</p>
<hr>
<p>在不同的情况下，不同的散列函数会发挥出不同的性能，因此不能笼统地说哪种散列函数最好。实际选择中，采用何种散列函数的方法取决于关键字集合的情况，但目标是为了使散列产生冲突的可能性尽量地降低。</p>
]]></content>
      
        <categories>
            
            <category> Data structure </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
